{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Add pydantic-settings dependency",
        "description": "Add pydantic>=2.0 and pydantic-settings>=2.0 to pyproject.toml dependencies.",
        "details": "Edit pyproject.toml to add dependencies:\n\n```toml\n[project]\ndependencies = [\n  ...\n  \"pydantic>=2.0,<3\",\n  \"pydantic-settings>=2.0,<3\",\n]\n```\n\nRun `uv sync --all-groups` to install. Verify imports work:\n```python\nfrom pydantic import BaseModel\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n```",
        "testStrategy": "Run `uv sync --all-groups` and verify no errors. Import pydantic and pydantic_settings in a Python shell to confirm installation.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Review pyproject.toml dependencies structure",
            "description": "Examine current pyproject.toml to understand dependencies array format and verify pydantic is not already a direct dependency.",
            "dependencies": [],
            "details": "Open pyproject.toml and inspect the [project].dependencies array (lines 13-25). Note the version constraint format used: `package>=X.Y.Z,<N`. Confirm pydantic and pydantic-settings are NOT listed as direct dependencies (they exist in uv.lock only as transitive deps). Identify insertion point for new deps (alphabetically or at end of list).",
            "status": "done",
            "testStrategy": "Visual confirmation that pydantic/pydantic-settings are absent from dependencies array.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:22:42.920Z"
          },
          {
            "id": 2,
            "title": "Add pydantic>=2.0,<3 to dependencies",
            "description": "Edit pyproject.toml to add pydantic as a direct dependency with version constraint matching project's major-bound style.",
            "dependencies": [
              1
            ],
            "details": "Edit pyproject.toml [project].dependencies array to add:\n```toml\n\"pydantic>=2.0,<3\",\n```\nFollow existing version constraint pattern (>=min,<major). Place alphabetically between 'pexpect' and 'pyyaml' entries for consistency.",
            "status": "done",
            "testStrategy": "Verify pyproject.toml parses correctly with `uv pip compile pyproject.toml --dry-run`.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:23:36.263Z"
          },
          {
            "id": 3,
            "title": "Add pydantic-settings>=2.0,<3 to dependencies",
            "description": "Edit pyproject.toml to add pydantic-settings as a direct dependency alongside pydantic.",
            "dependencies": [
              2
            ],
            "details": "Edit pyproject.toml [project].dependencies array to add:\n```toml\n\"pydantic-settings>=2.0,<3\",\n```\nPlace directly after the pydantic entry to keep related packages grouped. This package provides BaseSettings class for env var configuration.",
            "status": "done",
            "testStrategy": "Verify pyproject.toml syntax is valid and both deps are listed.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:23:36.312Z"
          },
          {
            "id": 4,
            "title": "Run uv sync to install dependencies",
            "description": "Execute uv sync --all-groups to resolve, lock, and install the new pydantic dependencies.",
            "dependencies": [
              3
            ],
            "details": "Run:\n```bash\nuv sync --all-groups\n```\nThis will update uv.lock with explicit direct dependency entries for pydantic and pydantic-settings, then install to the virtual environment. Command should complete without errors or version conflicts.",
            "status": "done",
            "testStrategy": "Command exits with code 0. Check uv.lock shows pydantic/pydantic-settings entries.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:26:14.370Z"
          },
          {
            "id": 5,
            "title": "Verify pydantic and pydantic-settings imports",
            "description": "Test that both packages import correctly and key classes are accessible.",
            "dependencies": [
              4
            ],
            "details": "Run verification script:\n```bash\nuv run python -c \"from pydantic import BaseModel, Field; from pydantic_settings import BaseSettings, SettingsConfigDict; print('OK')\"\n```\nThis confirms:\n- pydantic BaseModel and Field for data models\n- pydantic_settings BaseSettings for env var configuration\n- SettingsConfigDict for settings customization",
            "status": "done",
            "testStrategy": "Python command prints 'OK' without ImportError or ModuleNotFoundError.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:29:10.475Z"
          }
        ],
        "updatedAt": "2026-01-02T17:29:10.475Z"
      },
      {
        "id": "2",
        "title": "Create ToolSettings base model",
        "description": "Create ToolSettings BaseModel class that serves as the base for all tool-specific settings.",
        "details": "Create `src/buvis/pybase/configuration/settings.py`:\n\n```python\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass ToolSettings(BaseModel):\n    \"\"\"Base for tool-specific settings.\n    \n    All tool namespaces inherit from this. Each tool gets enabled: bool = True.\n    Subclasses add tool-specific fields. Uses BaseModel (not BaseSettings) since\n    parent GlobalSettings handles ENV resolution.\n    \"\"\"\n    model_config = ConfigDict(frozen=True, extra=\"forbid\")\n    \n    enabled: bool = True\n```\n\nKey points:\n- `frozen=True` makes settings immutable after creation\n- `extra=\"forbid\"` rejects unknown fields per anti-patterns section",
        "testStrategy": "Test instantiation with defaults, test that enabled=True by default, test frozen=True prevents mutation, test extra='forbid' rejects unknown fields.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add pydantic dependency to pyproject.toml",
            "description": "Add pydantic as a project dependency since it's not currently in the dependencies list and is required for the BaseModel and ConfigDict imports.",
            "dependencies": [],
            "details": "Add `pydantic>=2.0.0,<3` to the dependencies array in pyproject.toml. The project uses semantic versioning bounds (major version pins) as seen with other deps like `pyyaml>=6.0.3,<7`. After adding, run `uv sync --all-groups` to update uv.lock.",
            "status": "done",
            "testStrategy": "Run `uv sync --all-groups` and verify no errors. Run `uv run python -c 'from pydantic import BaseModel, ConfigDict'` to confirm import works.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:06:59.754Z"
          },
          {
            "id": 2,
            "title": "Create settings.py with ToolSettings class",
            "description": "Create the new settings.py file in src/buvis/pybase/configuration/ with the ToolSettings BaseModel class.",
            "dependencies": [
              1
            ],
            "details": "Create `src/buvis/pybase/configuration/settings.py` with:\n- `from __future__ import annotations` (project convention)\n- Import BaseModel and ConfigDict from pydantic\n- ToolSettings class with model_config = ConfigDict(frozen=True, extra=\"forbid\")\n- Single field: `enabled: bool = True`\n- Google-style docstring explaining the base class purpose",
            "status": "done",
            "testStrategy": "Run `uv run python -c 'from buvis.pybase.configuration.settings import ToolSettings; print(ToolSettings())'` to verify import and instantiation.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:07:51.265Z"
          },
          {
            "id": 3,
            "title": "Export ToolSettings in configuration __init__.py",
            "description": "Add ToolSettings to the configuration module's public API by updating __init__.py exports.",
            "dependencies": [
              2
            ],
            "details": "Update `src/buvis/pybase/configuration/__init__.py` to:\n- Add import: `from .settings import ToolSettings`\n- Append \"ToolSettings\" to `__all__` list\nFollow existing pattern of explicit imports and __all__ declaration.",
            "status": "done",
            "testStrategy": "Run `uv run python -c 'from buvis.pybase.configuration import ToolSettings; assert ToolSettings().enabled is True'`",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:07:51.309Z"
          },
          {
            "id": 4,
            "title": "Create tests/configuration directory and test file scaffold",
            "description": "Create the test directory structure and basic test file for configuration settings tests.",
            "dependencies": [
              3
            ],
            "details": "Create `tests/configuration/test_settings.py` with:\n- Import pytest and ValidationError from pydantic\n- Import ToolSettings from buvis.pybase.configuration.settings\n- Create TestToolSettings class with test_defaults method verifying enabled=True\n- Use class-based test organization matching existing test patterns",
            "status": "done",
            "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py::TestToolSettings::test_defaults -v` to verify test passes.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:07:51.346Z"
          },
          {
            "id": 5,
            "title": "Add immutability and extra fields rejection tests",
            "description": "Add tests verifying frozen=True prevents mutation and extra='forbid' rejects unknown fields.",
            "dependencies": [
              4
            ],
            "details": "Add to TestToolSettings class in test_settings.py:\n- test_immutable: create ToolSettings(), assert pytest.raises(ValidationError) when setting settings.enabled = False\n- test_extra_forbid: assert pytest.raises(ValidationError) when creating ToolSettings(unknown_field=True)\nThese tests verify the ConfigDict settings work as expected.",
            "status": "done",
            "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py -v` - all 3 tests (defaults, immutable, extra_forbid) should pass.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:07:51.389Z"
          }
        ],
        "updatedAt": "2026-01-02T18:07:51.389Z"
      },
      {
        "id": "3",
        "title": "Implement GlobalSettings class",
        "description": "Create GlobalSettings BaseSettings class with debug, log_level, and output_format fields.",
        "details": "Add to `settings.py`:\n\n```python\nfrom typing import Literal\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass GlobalSettings(BaseSettings):\n    \"\"\"Global runtime settings for BUVIS tools.\n    \n    Loads from environment variables with BUVIS_ prefix.\n    Nested delimiter is __ (e.g., BUVIS_PAYROLL__ENABLED).\n    \"\"\"\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_\",\n        env_nested_delimiter=\"__\",\n        case_sensitive=False,\n        frozen=True,\n        extra=\"forbid\",\n    )\n    \n    debug: bool = False\n    log_level: Literal[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"] = \"INFO\"\n    output_format: Literal[\"text\", \"json\", \"yaml\"] = \"text\"\n```\n\nNote: Literal type enforces valid values at validation time.",
        "testStrategy": "Test defaults (debug=False, log_level='INFO', output_format='text'). Test invalid log_level raises ValidationError. Test ENV loading with BUVIS_DEBUG=true.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add pydantic-settings dependency to pyproject.toml",
            "description": "Add pydantic-settings as a project dependency since it's required for BaseSettings class",
            "dependencies": [],
            "details": "Add `pydantic-settings>=2.0,<3` to the dependencies list in pyproject.toml. Run `uv sync` to install. This provides BaseSettings and SettingsConfigDict imports.",
            "status": "done",
            "testStrategy": "Verify `uv sync` completes without errors and `from pydantic_settings import BaseSettings` works in Python REPL",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:08:17.125Z"
          },
          {
            "id": 2,
            "title": "Create settings.py with GlobalSettings class",
            "description": "Create src/buvis/pybase/configuration/settings.py with the GlobalSettings BaseSettings class",
            "dependencies": [
              1
            ],
            "details": "Create settings.py with:\n- `from __future__ import annotations`\n- `from typing import Literal`\n- `from pydantic_settings import BaseSettings, SettingsConfigDict`\n- GlobalSettings class with model_config (env_prefix='BUVIS_', env_nested_delimiter='__', case_sensitive=False, frozen=True, extra='forbid')\n- Fields: debug: bool = False, log_level: Literal['DEBUG','INFO','WARNING','ERROR','CRITICAL'] = 'INFO', output_format: Literal['text','json','yaml'] = 'text'\n- Google-style docstring explaining env var loading",
            "status": "done",
            "testStrategy": "Import GlobalSettings and verify it instantiates with defaults",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:09:07.321Z"
          },
          {
            "id": 3,
            "title": "Export GlobalSettings in configuration __init__.py",
            "description": "Update configuration/__init__.py to export GlobalSettings class",
            "dependencies": [
              2
            ],
            "details": "Add `from .settings import GlobalSettings` import and append 'GlobalSettings' to __all__ list. Follow existing pattern used for Configuration class.",
            "status": "done",
            "testStrategy": "Verify `from buvis.pybase.configuration import GlobalSettings` works",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:09:07.356Z"
          },
          {
            "id": 4,
            "title": "Create tests/configuration/test_global_settings.py",
            "description": "Create test file for GlobalSettings with tests for defaults, validation, and env loading",
            "dependencies": [
              3
            ],
            "details": "Create tests/configuration/test_global_settings.py with class-based tests:\n- TestGlobalSettingsDefaults: verify debug=False, log_level='INFO', output_format='text'\n- TestGlobalSettingsValidation: verify invalid log_level raises ValidationError, invalid output_format raises ValidationError\n- TestGlobalSettingsEnvLoading: use monkeypatch to set BUVIS_DEBUG=true, BUVIS_LOG_LEVEL=DEBUG, verify they load correctly\n- TestGlobalSettingsImmutability: verify mutation raises ValidationError (frozen=True)",
            "status": "done",
            "testStrategy": "Run `uv run pytest tests/configuration/test_global_settings.py -v` and verify all tests pass",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:09:07.398Z"
          },
          {
            "id": 5,
            "title": "Verify extra='forbid' rejects unknown fields",
            "description": "Add test verifying that unknown environment variables with BUVIS_ prefix raise validation errors",
            "dependencies": [
              4
            ],
            "details": "Add test to test_global_settings.py:\n- TestGlobalSettingsExtraForbid: use monkeypatch to set BUVIS_UNKNOWN_FIELD=value, verify instantiation raises ValidationError due to extra='forbid' config. This ensures typos in env vars are caught.",
            "status": "done",
            "testStrategy": "Run pytest and verify ValidationError raised for unknown BUVIS_ prefixed env vars",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:09:07.437Z"
          }
        ],
        "updatedAt": "2026-01-02T18:09:07.437Z"
      },
      {
        "id": "4",
        "title": "Add startup validation",
        "description": "Ensure all settings validated at load time, not at use time.",
        "details": "Pydantic v2 validates on instantiation by default. Add explicit test coverage:\n\n```python\n# In test file\nimport pytest\nfrom pydantic import ValidationError\nfrom buvis.pybase.configuration.settings import GlobalSettings\n\ndef test_invalid_log_level_raises_at_instantiation():\n    with pytest.raises(ValidationError) as exc_info:\n        GlobalSettings(log_level=\"INVALID\")\n    assert \"log_level\" in str(exc_info.value)\n\ndef test_invalid_output_format_raises():\n    with pytest.raises(ValidationError):\n        GlobalSettings(output_format=\"xml\")\n```\n\nNo code changes needed - Pydantic validates automatically. This task ensures test coverage for the validation behavior.",
        "testStrategy": "Pass invalid values for each Literal field and verify ValidationError raised immediately on instantiation.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test file structure for settings validation tests",
            "description": "Create the test file tests/configuration/test_settings_validation.py with proper imports and fixtures for testing GlobalSettings validation behavior.",
            "dependencies": [],
            "details": "Create tests/configuration/test_settings_validation.py with imports for pytest, ValidationError from pydantic, and the GlobalSettings model. Include a docstring explaining these tests verify Pydantic validates at instantiation time. Follow existing test patterns using class-based organization.",
            "status": "done",
            "testStrategy": "File exists with correct imports and passes ruff check",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:10:19.995Z"
          },
          {
            "id": 2,
            "title": "Add tests for invalid log_level validation",
            "description": "Add test cases that verify ValidationError is raised when invalid log_level values are passed to GlobalSettings at instantiation.",
            "dependencies": [
              1
            ],
            "details": "Create TestLogLevelValidation class with tests: test_invalid_log_level_raises_at_instantiation (value like 'INVALID'), test_invalid_log_level_case_sensitive (if 'info' lowercase should fail), test_validation_error_mentions_log_level (assert 'log_level' in error message). Use pytest.raises(ValidationError) context manager.",
            "status": "done",
            "testStrategy": "Run pytest on the new test class and verify all tests pass when GlobalSettings enforces Literal constraint",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:10:20.038Z"
          },
          {
            "id": 3,
            "title": "Add tests for invalid output_format validation",
            "description": "Add test cases that verify ValidationError is raised for invalid output_format values at instantiation time.",
            "dependencies": [
              1
            ],
            "details": "Create TestOutputFormatValidation class with tests: test_invalid_output_format_raises (value like 'xml'), test_output_format_error_message (verify field name in error). Keep tests parallel to log_level tests for consistency. Use pytest.raises(ValidationError) as exc_info pattern to capture and inspect errors.",
            "status": "done",
            "testStrategy": "Run pytest on the new test class and verify tests pass with proper Literal['text', 'json', 'yaml'] constraint",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:10:20.081Z"
          },
          {
            "id": 4,
            "title": "Add tests for valid settings instantiation",
            "description": "Add positive test cases confirming valid values are accepted without raising errors at instantiation.",
            "dependencies": [
              1
            ],
            "details": "Create TestValidSettingsInstantiation class with: test_default_values_valid (no args instantiation), test_all_valid_log_levels (parametrized test for DEBUG/INFO/WARNING/ERROR/CRITICAL), test_all_valid_output_formats (parametrized for text/json/yaml), test_valid_debug_boolean. Use @pytest.mark.parametrize for enumerated values.",
            "status": "done",
            "testStrategy": "All tests should pass without raising ValidationError, confirming Pydantic accepts all Literal variants",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:10:20.124Z"
          },
          {
            "id": 5,
            "title": "Add tests for ToolSettings validation and error details",
            "description": "Add tests verifying ToolSettings validates properly and that ValidationError provides useful field path information.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create TestToolSettingsValidation class with: test_tool_settings_enabled_requires_bool (pass string 'yes' instead of bool), test_validation_error_contains_field_path (verify exc_info.value.errors() contains 'loc' with field name). Also add TestValidationErrorDetails class to verify error messages are actionable with field names and expected types.",
            "status": "done",
            "testStrategy": "Run pytest and verify ToolSettings rejects invalid types and ValidationError.errors() provides structured error info with field locations",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:10:20.167Z"
          }
        ],
        "updatedAt": "2026-01-02T18:10:20.167Z"
      },
      {
        "id": "5",
        "title": "Implement immutability enforcement",
        "description": "Ensure settings cannot be modified after initial resolution.",
        "details": "Already implemented via `frozen=True` in model_config. Add test coverage:\n\n```python\nimport pytest\nfrom pydantic import ValidationError\n\ndef test_settings_immutable():\n    settings = GlobalSettings()\n    with pytest.raises(ValidationError):\n        settings.debug = True\n\ndef test_tool_settings_immutable():\n    tool = ToolSettings()\n    with pytest.raises(ValidationError):\n        tool.enabled = False\n```\n\nNote: Pydantic v2 frozen models raise ValidationError on mutation attempts.",
        "testStrategy": "Attempt to mutate each field on instantiated settings objects and verify ValidationError raised.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test file for settings immutability",
            "description": "Create tests/configuration/test_settings_immutability.py with imports and test class structure for immutability testing.",
            "dependencies": [],
            "details": "Create tests/configuration/test_settings_immutability.py with:\n- Import pytest, ValidationError from pydantic\n- Import GlobalSettings from buvis.pybase.configuration\n- Import ToolSettings from buvis.pybase.configuration\n- Create TestGlobalSettingsImmutability class and TestToolSettingsImmutability class\n- Follow existing test patterns: class-based organization, pytest.raises context managers",
            "status": "pending",
            "testStrategy": "Verify file exists and imports work: uv run python -c 'from tests.configuration.test_settings_immutability import *'",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add GlobalSettings immutability tests",
            "description": "Add test methods verifying GlobalSettings fields cannot be mutated after instantiation.",
            "dependencies": [
              1
            ],
            "details": "Add to TestGlobalSettingsImmutability class:\n- test_debug_immutable: create GlobalSettings(), assert pytest.raises(ValidationError) when setting debug=True\n- test_log_level_immutable: verify log_level field rejects mutation\n- test_output_format_immutable: verify output_format field rejects mutation\nPydantic v2 frozen models raise ValidationError on mutation attempts.",
            "status": "pending",
            "testStrategy": "Run uv run pytest tests/configuration/test_settings_immutability.py::TestGlobalSettingsImmutability -v",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add ToolSettings immutability tests",
            "description": "Add test methods verifying ToolSettings fields cannot be mutated after instantiation.",
            "dependencies": [
              1
            ],
            "details": "Add to TestToolSettingsImmutability class:\n- test_enabled_immutable: create ToolSettings(), assert pytest.raises(ValidationError) when setting enabled=False\n- test_any_field_immutable: parametrized test for any additional fields on ToolSettings\nFollow pattern: instantiate, attempt mutation, verify ValidationError raised.",
            "status": "pending",
            "testStrategy": "Run uv run pytest tests/configuration/test_settings_immutability.py::TestToolSettingsImmutability -v",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add validation error content tests",
            "description": "Add tests verifying the ValidationError message includes helpful information about immutability.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add TestImmutabilityErrorMessages class with:\n- test_error_mentions_frozen: capture ValidationError with pytest.raises(...) as exc_info, verify 'frozen' or 'immutable' appears in str(exc_info.value)\n- test_error_mentions_field_name: verify the field name appears in error message\nThis ensures users get clear error messages when attempting mutations.",
            "status": "pending",
            "testStrategy": "Run uv run pytest tests/configuration/test_settings_immutability.py::TestImmutabilityErrorMessages -v",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify all settings tests pass together",
            "description": "Run full test suite for configuration module to ensure immutability tests integrate correctly.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Run complete test suite:\n- uv run pytest tests/configuration/ -v --tb=short\n- Verify all immutability tests pass alongside other settings tests\n- Check test_settings.py tests still pass (if exists)\n- Ensure no test isolation issues between test files\nFix any integration issues discovered.",
            "status": "pending",
            "testStrategy": "All tests in tests/configuration/ pass: uv run pytest tests/configuration/ -v exits with code 0",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:05:21.333Z"
      },
      {
        "id": "6",
        "title": "Add nested tool namespace support",
        "description": "Enable consumers to register tool-specific settings as nested namespaces on GlobalSettings.",
        "details": "Consumers define their own GlobalSettings subclass with tool namespaces:\n\n```python\n# In consumer code (not in pybase)\nfrom buvis.pybase.configuration.settings import GlobalSettings, ToolSettings\n\nclass PayrollSettings(ToolSettings):\n    cutoff_day: int = 15\n\nclass MyAppSettings(GlobalSettings):\n    payroll: PayrollSettings = PayrollSettings()\n    hcm: ToolSettings = ToolSettings()  # default enabled only\n\n# Usage:\nsettings = MyAppSettings()\nassert settings.payroll.enabled is True\nassert settings.payroll.cutoff_day == 15\n```\n\nENV loading: `BUVIS_PAYROLL__ENABLED=false` sets `settings.payroll.enabled`.\n\nNo code changes to base classes needed - Pydantic handles nested models automatically.",
        "testStrategy": "Create test subclass with nested ToolSettings, verify attribute access works, verify ENV var loading with double underscore delimiter.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ToolSettings BaseModel in settings.py",
            "description": "Create src/buvis/pybase/configuration/settings.py with ToolSettings BaseModel class that serves as base for all tool-specific settings.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/settings.py` with:\n- `from __future__ import annotations` (project convention)\n- Import BaseModel and ConfigDict from pydantic\n- ToolSettings class with:\n  - `model_config = ConfigDict(frozen=True, extra=\"forbid\")`\n  - Single field: `enabled: bool = True`\n  - Google-style docstring explaining base class purpose\n\nThis provides immutable, validated tool settings that reject unknown fields.",
            "status": "pending",
            "testStrategy": "Run `uv run python -c 'from buvis.pybase.configuration.settings import ToolSettings; s = ToolSettings(); assert s.enabled is True'`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add GlobalSettings BaseSettings with env_nested_delimiter",
            "description": "Add GlobalSettings class to settings.py with SettingsConfigDict configured for nested model ENV var loading via double underscore delimiter.",
            "dependencies": [
              1
            ],
            "details": "Add to settings.py:\n- Import BaseSettings and SettingsConfigDict from pydantic_settings\n- GlobalSettings class with:\n  - `model_config = SettingsConfigDict(env_prefix=\"BUVIS_\", env_nested_delimiter=\"__\", case_sensitive=False, frozen=True, extra=\"forbid\")`\n  - Fields: `debug: bool = False`, `log_level: Literal[\"DEBUG\",\"INFO\",\"WARNING\",\"ERROR\",\"CRITICAL\"] = \"INFO\"`, `output_format: Literal[\"text\",\"json\",\"yaml\"] = \"text\"`\n\nThe `env_nested_delimiter=\"__\"` enables BUVIS_PAYROLL__ENABLED to set settings.payroll.enabled when consumers add nested ToolSettings fields.",
            "status": "pending",
            "testStrategy": "Verify instantiation works and env_nested_delimiter is set: `from buvis.pybase.configuration.settings import GlobalSettings; print(GlobalSettings.model_config)`",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Export ToolSettings and GlobalSettings from configuration module",
            "description": "Update src/buvis/pybase/configuration/__init__.py to export ToolSettings and GlobalSettings classes for consumer imports.",
            "dependencies": [
              2
            ],
            "details": "Edit __init__.py to add:\n```python\nfrom .settings import GlobalSettings, ToolSettings\n```\n\nUpdate __all__ list:\n```python\n__all__ = [\n    \"Configuration\",\n    \"ConfigurationKeyNotFoundError\",\n    \"cfg\",\n    \"GlobalSettings\",\n    \"ToolSettings\",\n]\n```\n\nThis allows consumers to import via: `from buvis.pybase.configuration import GlobalSettings, ToolSettings`",
            "status": "pending",
            "testStrategy": "Run `uv run python -c 'from buvis.pybase.configuration import GlobalSettings, ToolSettings; print(\"OK\")'`",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create tests/configuration/test_nested_settings.py for nested namespace tests",
            "description": "Create test file demonstrating nested ToolSettings work correctly with attribute access and ENV var loading via double underscore delimiter.",
            "dependencies": [
              3
            ],
            "details": "Create `tests/configuration/test_nested_settings.py` with:\n\n```python\nclass TestNestedToolSettings:\n    def test_nested_attribute_access(self):\n        class PayrollSettings(ToolSettings):\n            cutoff_day: int = 15\n        class AppSettings(GlobalSettings):\n            payroll: PayrollSettings = PayrollSettings()\n        settings = AppSettings()\n        assert settings.payroll.enabled is True\n        assert settings.payroll.cutoff_day == 15\n\n    @patch.dict(os.environ, {\"BUVIS_PAYROLL__ENABLED\": \"false\"})\n    def test_nested_env_loading_with_double_underscore(self):\n        class AppSettings(GlobalSettings):\n            payroll: ToolSettings = ToolSettings()\n        settings = AppSettings()\n        assert settings.payroll.enabled is False\n\n    @patch.dict(os.environ, {\"BUVIS_PAYROLL__CUTOFF_DAY\": \"20\"})\n    def test_nested_custom_field_env_loading(self):\n        class PayrollSettings(ToolSettings):\n            cutoff_day: int = 15\n        class AppSettings(GlobalSettings):\n            payroll: PayrollSettings = PayrollSettings()\n        settings = AppSettings()\n        assert settings.payroll.cutoff_day == 20\n```",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_nested_settings.py -v` and verify all nested namespace tests pass.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add test for multiple nested tool namespaces",
            "description": "Add tests verifying multiple tool namespaces work simultaneously and default ToolSettings (enabled-only) works correctly.",
            "dependencies": [
              4
            ],
            "details": "Add to test_nested_settings.py:\n\n```python\nclass TestMultipleToolNamespaces:\n    def test_multiple_tools_independent(self):\n        class AppSettings(GlobalSettings):\n            payroll: ToolSettings = ToolSettings()\n            hcm: ToolSettings = ToolSettings()\n        settings = AppSettings()\n        assert settings.payroll.enabled is True\n        assert settings.hcm.enabled is True\n\n    @patch.dict(os.environ, {\"BUVIS_PAYROLL__ENABLED\": \"false\", \"BUVIS_HCM__ENABLED\": \"true\"})\n    def test_env_affects_correct_namespace(self):\n        class AppSettings(GlobalSettings):\n            payroll: ToolSettings = ToolSettings()\n            hcm: ToolSettings = ToolSettings()\n        settings = AppSettings()\n        assert settings.payroll.enabled is False\n        assert settings.hcm.enabled is True\n```\n\nRun full test suite: `uv run pytest tests/configuration/ -v` to verify no regressions.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_nested_settings.py::TestMultipleToolNamespaces -v` - all tests pass.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:06:04.561Z"
      },
      {
        "id": "7",
        "title": "Add unknown field rejection",
        "description": "Reject unknown fields with clear error messages.",
        "details": "Already implemented via `extra=\"forbid\"`. Add test coverage:\n\n```python\nimport pytest\nfrom pydantic import ValidationError\n\ndef test_unknown_field_rejected():\n    with pytest.raises(ValidationError) as exc_info:\n        GlobalSettings(unknown_field=\"value\")\n    assert \"extra\" in str(exc_info.value).lower()\n\ndef test_unknown_tool_field_rejected():\n    with pytest.raises(ValidationError) as exc_info:\n        ToolSettings(secret_key=\"oops\")\n    assert \"extra\" in str(exc_info.value).lower()\n```",
        "testStrategy": "Pass unknown fields to GlobalSettings and ToolSettings constructors, verify ValidationError with clear message about extra fields.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test file and imports for unknown field rejection tests",
            "description": "Create tests/configuration/test_unknown_field_rejection.py with required imports for testing pydantic ValidationError on extra fields.",
            "dependencies": [],
            "details": "Create new test file at tests/configuration/test_unknown_field_rejection.py. Add imports: pytest, ValidationError from pydantic, GlobalSettings and ToolSettings from buvis.pybase.configuration. Follow existing test patterns from tests/adapters/ using class-based organization.",
            "status": "pending",
            "testStrategy": "Verify file exists and imports resolve correctly by running pytest --collect-only on the new file.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add tests for GlobalSettings unknown field rejection",
            "description": "Write tests verifying GlobalSettings rejects unknown fields with ValidationError containing 'extra' in error message.",
            "dependencies": [
              1
            ],
            "details": "Create TestGlobalSettingsUnknownFields class with test_unknown_field_rejected method. Pass unknown_field='value' to GlobalSettings constructor. Use pytest.raises(ValidationError) context manager. Assert 'extra' appears in str(exc_info.value).lower() to verify error message clarity.",
            "status": "pending",
            "testStrategy": "Run pytest tests/configuration/test_unknown_field_rejection.py::TestGlobalSettingsUnknownFields and verify test passes when GlobalSettings has extra='forbid' config.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add tests for ToolSettings unknown field rejection",
            "description": "Write tests verifying ToolSettings rejects unknown fields like secret_key with clear ValidationError.",
            "dependencies": [
              1
            ],
            "details": "Create TestToolSettingsUnknownFields class with test_unknown_tool_field_rejected method. Pass secret_key='oops' to ToolSettings constructor. Use pytest.raises(ValidationError). Assert error message contains 'extra' to confirm clear feedback about the forbidden field.",
            "status": "pending",
            "testStrategy": "Run pytest on the ToolSettings tests. Verify ValidationError raised with descriptive message when extra='forbid' is set in model_config.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add tests for multiple unknown fields simultaneously",
            "description": "Test that passing multiple unknown fields at once results in ValidationError listing all invalid fields.",
            "dependencies": [
              1
            ],
            "details": "Add test_multiple_unknown_fields_rejected to both test classes. Pass multiple unknown kwargs like GlobalSettings(foo='a', bar='b', baz='c'). Verify ValidationError is raised. Check that error message mentions multiple fields or at least clearly indicates extra fields forbidden.",
            "status": "pending",
            "testStrategy": "Run pytest and verify all unknown fields are caught. Check error message contains information about extra fields being rejected.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add edge case tests for unknown field names similar to valid fields",
            "description": "Test that typos or field names similar to valid ones are still rejected with helpful error messages.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add test_typo_field_rejected tests. If GlobalSettings has 'debug' field, test that 'debugg' or 'debg' raises ValidationError. Verify error message contains 'extra' so users understand the field doesn't exist. This helps catch common user errors with near-miss field names.",
            "status": "pending",
            "testStrategy": "Run pytest on edge case tests. Verify typo fields rejected. Confirm error messages are clear enough for users to identify the problem field name.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:06:41.993Z"
      },
      {
        "id": "8",
        "title": "Export settings from configuration module",
        "description": "Update configuration/__init__.py to export new settings classes.",
        "details": "Edit `src/buvis/pybase/configuration/__init__.py`:\n\n```python\nfrom .configuration import Configuration, ConfigurationKeyNotFoundError, cfg\nfrom .settings import GlobalSettings, ToolSettings\n\n__all__ = [\n    \"Configuration\",\n    \"ConfigurationKeyNotFoundError\", \n    \"cfg\",\n    \"GlobalSettings\",\n    \"ToolSettings\",\n]\n```\n\nThis allows consumers to import:\n```python\nfrom buvis.pybase.configuration import GlobalSettings, ToolSettings\n```",
        "testStrategy": "Import GlobalSettings and ToolSettings from buvis.pybase.configuration, verify successful import.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify settings.py module exists with GlobalSettings and ToolSettings",
            "description": "Confirm that Task 3 (dependency) created src/buvis/pybase/configuration/settings.py with GlobalSettings and ToolSettings classes.",
            "dependencies": [],
            "details": "Check that settings.py exists in the configuration directory and contains both GlobalSettings (BaseSettings subclass) and ToolSettings (BaseModel subclass) as specified in PRD-00001. This is a prerequisite validation before modifying __init__.py.",
            "status": "pending",
            "testStrategy": "Run: python -c \"from buvis.pybase.configuration.settings import GlobalSettings, ToolSettings; print('OK')\"",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add import statement for settings classes in __init__.py",
            "description": "Add the import line to bring GlobalSettings and ToolSettings into the configuration module namespace.",
            "dependencies": [
              1
            ],
            "details": "Edit src/buvis/pybase/configuration/__init__.py to add: `from .settings import GlobalSettings, ToolSettings`. Place this import after the existing configuration import, following the project's convention of alphabetical module ordering.",
            "status": "pending",
            "testStrategy": "Syntax check passes, no ImportError when loading the module.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update __all__ list to include GlobalSettings and ToolSettings",
            "description": "Add the new exported symbols to the __all__ list for explicit public API definition.",
            "dependencies": [
              2
            ],
            "details": "Modify the __all__ list in __init__.py to include 'GlobalSettings' and 'ToolSettings'. Follow project convention: alphabetically ordered list with Configuration, ConfigurationKeyNotFoundError, GlobalSettings, ToolSettings, cfg.",
            "status": "pending",
            "testStrategy": "Verify __all__ contains exactly: Configuration, ConfigurationKeyNotFoundError, GlobalSettings, ToolSettings, cfg.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Verify package-level imports work correctly",
            "description": "Test that consumers can import GlobalSettings and ToolSettings from buvis.pybase.configuration.",
            "dependencies": [
              3
            ],
            "details": "Validate the public API by importing from the package level: `from buvis.pybase.configuration import GlobalSettings, ToolSettings`. Ensure both classes are accessible and properly typed. Check that existing imports (Configuration, cfg) still work.",
            "status": "pending",
            "testStrategy": "Run: python -c \"from buvis.pybase.configuration import GlobalSettings, ToolSettings, Configuration, cfg; print(GlobalSettings, ToolSettings)\"",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run test suite to verify no regressions",
            "description": "Execute pytest to ensure the __init__.py changes don't break existing functionality.",
            "dependencies": [
              4
            ],
            "details": "Run `uv run pytest` to execute all tests. Focus on configuration module tests in tests/configuration/. Verify that existing Configuration and cfg usage patterns remain functional and no import errors occur across the codebase.",
            "status": "pending",
            "testStrategy": "All tests pass with `uv run pytest`. Zero failures or errors in configuration-related tests.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:06:54.544Z"
      },
      {
        "id": "9",
        "title": "Create comprehensive test suite",
        "description": "Create tests/configuration/test_settings.py with all required test cases.",
        "details": "Create `tests/configuration/test_settings.py`:\n\n```python\nimport os\nfrom unittest.mock import patch\n\nimport pytest\nfrom pydantic import ValidationError\n\nfrom buvis.pybase.configuration.settings import GlobalSettings, ToolSettings\n\n\nclass TestToolSettings:\n    def test_defaults(self):\n        settings = ToolSettings()\n        assert settings.enabled is True\n\n    def test_immutable(self):\n        settings = ToolSettings()\n        with pytest.raises(ValidationError):\n            settings.enabled = False\n\n    def test_extra_forbidden(self):\n        with pytest.raises(ValidationError):\n            ToolSettings(secret=\"oops\")\n\n\nclass TestGlobalSettings:\n    def test_defaults(self):\n        settings = GlobalSettings()\n        assert settings.debug is False\n        assert settings.log_level == \"INFO\"\n        assert settings.output_format == \"text\"\n\n    def test_invalid_log_level(self):\n        with pytest.raises(ValidationError):\n            GlobalSettings(log_level=\"TRACE\")\n\n    def test_invalid_output_format(self):\n        with pytest.raises(ValidationError):\n            GlobalSettings(output_format=\"xml\")\n\n    def test_immutable(self):\n        settings = GlobalSettings()\n        with pytest.raises(ValidationError):\n            settings.debug = True\n\n    def test_extra_forbidden(self):\n        with pytest.raises(ValidationError):\n            GlobalSettings(api_key=\"secret\")\n\n    @patch.dict(os.environ, {\"BUVIS_DEBUG\": \"true\"})\n    def test_env_loading(self):\n        settings = GlobalSettings()\n        assert settings.debug is True\n\n    @patch.dict(os.environ, {\"BUVIS_LOG_LEVEL\": \"DEBUG\"})\n    def test_env_log_level(self):\n        settings = GlobalSettings()\n        assert settings.log_level == \"DEBUG\"\n\n\nclass TestNestedToolSettings:\n    def test_nested_access(self):\n        class PayrollSettings(ToolSettings):\n            cutoff_day: int = 15\n\n        class AppSettings(GlobalSettings):\n            payroll: PayrollSettings = PayrollSettings()\n\n        settings = AppSettings()\n        assert settings.payroll.enabled is True\n        assert settings.payroll.cutoff_day == 15\n\n    @patch.dict(os.environ, {\"BUVIS_PAYROLL__ENABLED\": \"false\"})\n    def test_nested_env_loading(self):\n        class AppSettings(GlobalSettings):\n            payroll: ToolSettings = ToolSettings()\n\n        settings = AppSettings()\n        assert settings.payroll.enabled is False\n```",
        "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py -v` and verify all tests pass.",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test directory and file scaffold with imports",
            "description": "Create tests/configuration/ directory and test_settings.py with required imports and pytest fixtures.",
            "dependencies": [],
            "details": "Create `tests/configuration/test_settings.py` with:\n- `import os`\n- `from unittest.mock import patch`\n- `import pytest`\n- `from pydantic import ValidationError`\n- `from buvis.pybase.configuration.settings import GlobalSettings, ToolSettings`\n\nFollow existing test file patterns (see test_shell_adapter.py). No fixtures needed since settings are stateless. Directory must exist before file creation.",
            "status": "pending",
            "testStrategy": "Verify file exists and imports succeed: `uv run python -c 'import tests.configuration.test_settings'`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement TestToolSettings class with all tests",
            "description": "Add TestToolSettings class with test_defaults, test_immutable, and test_extra_forbidden test methods.",
            "dependencies": [
              1
            ],
            "details": "Add to test_settings.py:\n\n```python\nclass TestToolSettings:\n    def test_defaults(self):\n        settings = ToolSettings()\n        assert settings.enabled is True\n\n    def test_immutable(self):\n        settings = ToolSettings()\n        with pytest.raises(ValidationError):\n            settings.enabled = False\n\n    def test_extra_forbidden(self):\n        with pytest.raises(ValidationError):\n            ToolSettings(secret=\"oops\")\n```\n\nThese verify frozen=True and extra='forbid' ConfigDict settings work correctly.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py::TestToolSettings -v` - all 3 tests pass",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement TestGlobalSettings defaults and validation tests",
            "description": "Add TestGlobalSettings class with tests for defaults, invalid log_level, and invalid output_format.",
            "dependencies": [
              1
            ],
            "details": "Add to test_settings.py:\n\n```python\nclass TestGlobalSettings:\n    def test_defaults(self):\n        settings = GlobalSettings()\n        assert settings.debug is False\n        assert settings.log_level == \"INFO\"\n        assert settings.output_format == \"text\"\n\n    def test_invalid_log_level(self):\n        with pytest.raises(ValidationError):\n            GlobalSettings(log_level=\"TRACE\")\n\n    def test_invalid_output_format(self):\n        with pytest.raises(ValidationError):\n            GlobalSettings(output_format=\"xml\")\n```\n\nLiteral type validation ensures only valid values accepted.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py::TestGlobalSettings::test_defaults -v` etc.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add GlobalSettings immutability, extra forbidden, and env loading tests",
            "description": "Extend TestGlobalSettings with test_immutable, test_extra_forbidden, test_env_loading, and test_env_log_level.",
            "dependencies": [
              3
            ],
            "details": "Add to TestGlobalSettings class:\n\n```python\n    def test_immutable(self):\n        settings = GlobalSettings()\n        with pytest.raises(ValidationError):\n            settings.debug = True\n\n    def test_extra_forbidden(self):\n        with pytest.raises(ValidationError):\n            GlobalSettings(api_key=\"secret\")\n\n    @patch.dict(os.environ, {\"BUVIS_DEBUG\": \"true\"})\n    def test_env_loading(self):\n        settings = GlobalSettings()\n        assert settings.debug is True\n\n    @patch.dict(os.environ, {\"BUVIS_LOG_LEVEL\": \"DEBUG\"})\n    def test_env_log_level(self):\n        settings = GlobalSettings()\n        assert settings.log_level == \"DEBUG\"\n```\n\nUses unittest.mock.patch.dict for env var mocking (matches existing patterns).",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py::TestGlobalSettings -v` - all 7 tests pass",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement TestNestedToolSettings class with nested access and env tests",
            "description": "Add TestNestedToolSettings class testing nested tool settings access and double-underscore env var loading.",
            "dependencies": [
              2,
              4
            ],
            "details": "Add to test_settings.py:\n\n```python\nclass TestNestedToolSettings:\n    def test_nested_access(self):\n        class PayrollSettings(ToolSettings):\n            cutoff_day: int = 15\n\n        class AppSettings(GlobalSettings):\n            payroll: PayrollSettings = PayrollSettings()\n\n        settings = AppSettings()\n        assert settings.payroll.enabled is True\n        assert settings.payroll.cutoff_day == 15\n\n    @patch.dict(os.environ, {\"BUVIS_PAYROLL__ENABLED\": \"false\"})\n    def test_nested_env_loading(self):\n        class AppSettings(GlobalSettings):\n            payroll: ToolSettings = ToolSettings()\n\n        settings = AppSettings()\n        assert settings.payroll.enabled is False\n```\n\nTests env_nested_delimiter='__' from SettingsConfigDict works correctly.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py -v` - all 12 tests pass",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:07:21.463Z"
      },
      {
        "id": "10",
        "title": "Run full test suite and verify",
        "description": "Run pre-commit hooks and full test suite to ensure no regressions.",
        "details": "Run:\n```bash\nuv run pre-commit run --all-files\nuv run pytest\n```\n\nVerify:\n1. All existing tests still pass\n2. New settings tests pass\n3. ruff reports no linting errors\n4. No type errors\n\nFix any issues that arise before marking complete.",
        "testStrategy": "All pre-commit hooks pass, full pytest suite passes with no failures or errors.",
        "priority": "high",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Run ruff linting and formatting checks",
            "description": "Execute ruff linting and formatting pre-commit hooks on all files to catch style violations and formatting issues.",
            "dependencies": [],
            "details": "Run `uv run pre-commit run ruff --all-files` and `uv run pre-commit run ruff-format --all-files`. Check exit codes - 0 means pass. Review any reported issues for file paths and error codes. Common issues: unused imports (F401), line length (E501), missing type annotations in non-test files.",
            "status": "pending",
            "testStrategy": "Both ruff and ruff-format hooks exit with code 0, no errors or warnings printed to stderr.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Run existing adapter test suite",
            "description": "Execute pytest on existing adapter tests (test_shell_adapter.py, test_poetry_adapter.py, test_console_adapter.py) to verify no regressions.",
            "dependencies": [
              1
            ],
            "details": "Run `uv run pytest tests/adapters/ -v` to execute adapter tests with verbose output. These tests existed before settings changes and must continue to pass. Check for fixture availability, mock setup correctness, and assertion failures. Any failures here indicate regression from settings changes.",
            "status": "pending",
            "testStrategy": "All tests in tests/adapters/ pass with exit code 0. Verify output shows 'passed' for each test case.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Run new settings and configuration tests",
            "description": "Execute pytest on new configuration/settings tests from tasks 4, 5, 42, 43, 52 to verify implementation correctness.",
            "dependencies": [
              1
            ],
            "details": "Run `uv run pytest tests/configuration/ -v` to test settings functionality. Expected tests: immutability enforcement (frozen=True raises ValidationError), startup validation (invalid Literal values rejected at instantiation), nested env var resolution (__), direct field resolution, JSON list parsing. If tests/configuration/ doesn't exist yet, this indicates dependent tasks incomplete.",
            "status": "pending",
            "testStrategy": "All configuration tests pass. Verify ValidationError raised for immutable mutations, env var parsing works with __ and direct fields, JSON arrays parse to list[Model].",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Run full pre-commit and pytest suite",
            "description": "Execute complete pre-commit hooks and full pytest suite to ensure all checks pass together.",
            "dependencies": [
              2,
              3
            ],
            "details": "Run `uv run pre-commit run --all-files` followed by `uv run pytest`. This runs all hooks (ruff, ruff-format, pytest) and validates the entire test suite. Check final summary for total passed/failed/skipped. Ensure no warnings that indicate issues (deprecation, fixture scope problems).",
            "status": "pending",
            "testStrategy": "pre-commit exits 0 with 'Passed' for all hooks. pytest shows all tests passed, coverage acceptable, no errors or unexpected warnings.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Fix issues and verify clean state",
            "description": "Address any failures from previous steps, re-run suite until clean, and document final verification.",
            "dependencies": [
              4
            ],
            "details": "If any failures occurred: for ruff errors, fix linting/formatting issues in reported files; for test failures, debug with `pytest -x --pdb` or add `-s` for print output; for type errors, check pydantic model definitions and imports. After fixes, re-run `uv run pre-commit run --all-files && uv run pytest`. Repeat until exit code 0. Record final test count and confirm no skipped tests unless intentional.",
            "status": "pending",
            "testStrategy": "Final run of full suite passes cleanly. No failures, no unexpected skips, no warnings. Git status shows no untracked test artifacts.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:07:58.109Z"
      },
      {
        "id": "11",
        "title": "Create ConfigurationLoader class scaffold",
        "description": "Create the base ConfigurationLoader class in src/buvis/pybase/configuration/loader.py with static method signatures.",
        "details": "Create loader.py with:\n```python\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n\nclass ConfigurationLoader:\n    \"\"\"Discovers config files across standard locations.\"\"\"\n    \n    @staticmethod\n    def find_config_files(tool_name: str | None = None) -> list[Path]:\n        \"\"\"Return existing config files in priority order.\"\"\"\n        ...\n```\nFollow existing patterns: use `from __future__ import annotations`, static methods for stateless operations, Google docstrings.",
        "testStrategy": "Unit test that class exists and has find_config_files method accepting optional tool_name parameter.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create loader.py file with imports and class stub",
            "description": "Create src/buvis/pybase/configuration/loader.py with the required imports and empty ConfigurationLoader class.",
            "dependencies": [],
            "details": "Create loader.py with:\n```python\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n\nclass ConfigurationLoader:\n    \"\"\"Discovers config files across standard locations.\"\"\"\n```\nFollow existing pattern from dir_tree.py: use `from __future__ import annotations`, no instance state.",
            "status": "done",
            "testStrategy": "Verify file exists and imports without errors: `python -c 'from buvis.pybase.configuration.loader import ConfigurationLoader'`",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:40:41.671Z"
          },
          {
            "id": 2,
            "title": "Add find_config_files static method signature",
            "description": "Add the find_config_files static method with proper type hints and placeholder implementation.",
            "dependencies": [
              1
            ],
            "details": "Add to ConfigurationLoader class:\n```python\n@staticmethod\ndef find_config_files(tool_name: str | None = None) -> list[Path]:\n    \"\"\"Return existing config files in priority order.\n    \n    Args:\n        tool_name: Optional tool name to scope config search.\n    \n    Returns:\n        List of existing config file paths in priority order.\n    \"\"\"\n    raise NotImplementedError\n```\nUse `@staticmethod` decorator per DirTree pattern. Return type is `list[Path]` not `List[Path]`.",
            "status": "done",
            "testStrategy": "Test method signature: `hasattr(ConfigurationLoader, 'find_config_files')` and check it accepts `tool_name` parameter.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:40:41.717Z"
          },
          {
            "id": 3,
            "title": "Add Google-style docstrings with full documentation",
            "description": "Enhance docstrings with Google format including Args, Returns, Raises, and Example sections.",
            "dependencies": [
              2
            ],
            "details": "Update class and method docstrings to Google format matching existing patterns:\n```python\nclass ConfigurationLoader:\n    \"\"\"Discovers config files across standard locations.\n    \n    Searches XDG dirs, home config, project-local configs.\n    Returns paths in priority order (highest priority first).\n    \"\"\"\n```\nFor the method, add Args/Returns sections. Match formatting from dir_tree.py docstrings.",
            "status": "done",
            "testStrategy": "Verify docstrings exist: `ConfigurationLoader.__doc__` and `ConfigurationLoader.find_config_files.__doc__` are non-empty.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:40:41.758Z"
          },
          {
            "id": 4,
            "title": "Update configuration __init__.py exports",
            "description": "Add ConfigurationLoader to configuration module's __init__.py for public export.",
            "dependencies": [
              3
            ],
            "details": "Modify src/buvis/pybase/configuration/__init__.py:\n```python\nfrom .configuration import Configuration, ConfigurationKeyNotFoundError, cfg\nfrom .loader import ConfigurationLoader\n\n__all__ = [\"Configuration\", \"ConfigurationKeyNotFoundError\", \"cfg\", \"ConfigurationLoader\"]\n```\nFollow existing pattern of importing from submodule and explicit __all__ list.",
            "status": "done",
            "testStrategy": "Verify public import works: `from buvis.pybase.configuration import ConfigurationLoader`",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:40:41.923Z"
          },
          {
            "id": 5,
            "title": "Create tests/configuration/test_loader.py scaffold",
            "description": "Create test file with basic test cases for ConfigurationLoader class existence and method signature.",
            "dependencies": [
              4
            ],
            "details": "Create tests/configuration/test_loader.py:\n```python\nimport pytest\nfrom pathlib import Path\n\nfrom buvis.pybase.configuration.loader import ConfigurationLoader\n\n\nclass TestConfigurationLoaderScaffold:\n    def test_class_exists(self) -> None:\n        assert ConfigurationLoader is not None\n\n    def test_find_config_files_method_exists(self) -> None:\n        assert hasattr(ConfigurationLoader, 'find_config_files')\n\n    def test_find_config_files_accepts_tool_name(self) -> None:\n        with pytest.raises(NotImplementedError):\n            ConfigurationLoader.find_config_files(tool_name='test')\n\n    def test_find_config_files_accepts_no_args(self) -> None:\n        with pytest.raises(NotImplementedError):\n            ConfigurationLoader.find_config_files()\n```\nFollow test_shell_adapter.py pattern with class-based organization and type hints.",
            "status": "done",
            "testStrategy": "Run `uv run pytest tests/configuration/test_loader.py -v` - all tests should pass.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:40:42.341Z"
          }
        ],
        "updatedAt": "2026-01-02T17:40:42.341Z"
      },
      {
        "id": "12",
        "title": "Implement search path building",
        "description": "Build the 4-location search path list: BUVIS_CONFIG_DIR, XDG_CONFIG_HOME, ~/.buvis, cwd.",
        "details": "Implement internal method `_get_search_paths() -> list[Path]`:\n```python\n@staticmethod\ndef _get_search_paths() -> list[Path]:\n    paths: list[Path] = []\n    \n    # 1. Explicit override\n    if env_dir := os.getenv(\"BUVIS_CONFIG_DIR\"):\n        if env_dir:  # Handle empty string as unset\n            paths.append(Path(env_dir).expanduser())\n    \n    # 2. XDG standard\n    xdg = os.getenv(\"XDG_CONFIG_HOME\", \"\")\n    xdg_path = Path(xdg).expanduser() if xdg else Path.home() / \".config\"\n    paths.append(xdg_path / \"buvis\")\n    \n    # 3. Legacy\n    paths.append(Path.home() / \".buvis\")\n    \n    # 4. Project-local\n    paths.append(Path.cwd())\n    \n    return paths\n```\nEdge cases: empty BUVIS_CONFIG_DIR treated as unset, empty XDG_CONFIG_HOME uses ~/.config.",
        "testStrategy": "Test with various env var combinations: set/unset/empty for BUVIS_CONFIG_DIR and XDG_CONFIG_HOME. Verify correct order and path resolution.",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ConfigurationLoader class with _get_search_paths signature",
            "description": "Add ConfigurationLoader class to configuration module with the static method signature and return type.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/loader.py` with:\n```python\nfrom __future__ import annotations\nimport os\nfrom pathlib import Path\n\nclass ConfigurationLoader:\n    @staticmethod\n    def _get_search_paths() -> list[Path]:\n        paths: list[Path] = []\n        # Implementation in subsequent subtasks\n        return paths\n```\nExport in `__init__.py`. Follow existing pattern from Configuration class.",
            "status": "done",
            "testStrategy": "Verify class exists, method is static, returns empty list[Path] initially.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:11:39.091Z"
          },
          {
            "id": 2,
            "title": "Implement BUVIS_CONFIG_DIR env var handling",
            "description": "Add highest-priority path from BUVIS_CONFIG_DIR, treating empty string as unset.",
            "dependencies": [
              1
            ],
            "details": "In `_get_search_paths()`, add:\n```python\n# 1. Explicit override - highest priority\nif env_dir := os.getenv(\"BUVIS_CONFIG_DIR\"):\n    if env_dir:  # Empty string treated as unset\n        paths.append(Path(env_dir).expanduser())\n```\nUse walrus operator for concise check. `expanduser()` handles ~ in paths.",
            "status": "done",
            "testStrategy": "Test with: BUVIS_CONFIG_DIR set to valid path, set to empty string, unset. Use @patch.dict(os.environ, ...) pattern from test_shell_adapter.py.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:11:39.146Z"
          },
          {
            "id": 3,
            "title": "Implement XDG_CONFIG_HOME path with fallback",
            "description": "Add XDG standard location, defaulting to ~/.config when XDG_CONFIG_HOME is empty/unset.",
            "dependencies": [
              1
            ],
            "details": "In `_get_search_paths()`, after BUVIS_CONFIG_DIR handling:\n```python\n# 2. XDG standard location\nxdg = os.getenv(\"XDG_CONFIG_HOME\", \"\")\nxdg_path = Path(xdg).expanduser() if xdg else Path.home() / \".config\"\npaths.append(xdg_path / \"buvis\")\n```\nEmpty XDG_CONFIG_HOME falls back to ~/.config per XDG spec.",
            "status": "done",
            "testStrategy": "Test: XDG_CONFIG_HOME set (use custom path), empty string (use ~/.config), unset (use ~/.config). Verify /buvis suffix added.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:11:39.207Z"
          },
          {
            "id": 4,
            "title": "Implement legacy ~/.buvis and cwd paths",
            "description": "Add legacy home directory path and project-local cwd as final search locations.",
            "dependencies": [
              1
            ],
            "details": "Complete `_get_search_paths()` with:\n```python\n# 3. Legacy location\npaths.append(Path.home() / \".buvis\")\n\n# 4. Project-local (lowest priority)\npaths.append(Path.cwd())\n\nreturn paths\n```\nThese are unconditional - always added to search path. Order matters for priority.",
            "status": "done",
            "testStrategy": "Verify ~/.buvis always present. Verify cwd() is last in list. Test from different working directories.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:11:39.379Z"
          },
          {
            "id": 5,
            "title": "Add comprehensive test coverage for _get_search_paths",
            "description": "Create test file with full coverage of env var combinations and path ordering.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create `tests/configuration/test_configuration_loader.py`:\n```python\nclass TestGetSearchPaths:\n    def test_all_env_vars_set(self): # 4 paths returned\n    def test_buvis_config_dir_empty_string(self): # treated as unset\n    def test_xdg_config_home_empty_fallback(self): # uses ~/.config\n    def test_path_order_priority(self): # BUVIS_CONFIG_DIR first, cwd last\n    def test_expanduser_tilde_paths(self): # ~/custom expands\n```\nUse `@patch.dict(os.environ, ...)` and `monkeypatch` for cwd.",
            "status": "done",
            "testStrategy": "Run pytest on new test file. Verify all env combinations covered. Check edge cases: empty strings, tilde expansion, cwd changes.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:11:39.805Z"
          }
        ],
        "updatedAt": "2026-01-02T18:11:39.805Z"
      },
      {
        "id": "13",
        "title": "Implement file candidate generation",
        "description": "Generate candidate file paths for both buvis.yaml and tool-specific buvis-{tool}.yaml files.",
        "details": "Implement `_get_candidate_files(paths: list[Path], tool_name: str | None) -> list[Path]`:\n```python\n@staticmethod\ndef _get_candidate_files(paths: list[Path], tool_name: str | None) -> list[Path]:\n    candidates: list[Path] = []\n    for base in paths:\n        candidates.append(base / \"buvis.yaml\")\n        if tool_name:\n            candidates.append(base / f\"buvis-{tool_name}.yaml\")\n    return candidates\n```\nThis keeps base and tool-specific files interleaved per location, maintaining priority order.",
        "testStrategy": "Test with/without tool_name. Verify buvis.yaml and buvis-{tool}.yaml generated for each path. Verify ordering matches priority spec.",
        "priority": "high",
        "dependencies": [
          "12"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add _get_candidate_files method signature to ConfigurationLoader",
            "description": "Add the static method signature with proper type hints to the ConfigurationLoader class in loader.py.",
            "dependencies": [],
            "details": "In `src/buvis/pybase/configuration/loader.py`, add the method stub after `_get_search_paths`:\n```python\n@staticmethod\ndef _get_candidate_files(paths: list[Path], tool_name: str | None) -> list[Path]:\n    \"\"\"Generate candidate config file paths from search locations.\n    \n    Args:\n        paths: Base directories to search for config files.\n        tool_name: Optional tool name for tool-specific configs.\n        \n    Returns:\n        Ordered list of candidate paths (buvis.yaml + buvis-{tool}.yaml per location).\n    \"\"\"\n    candidates: list[Path] = []\n    return candidates\n```\nFollow existing static method pattern from `_get_search_paths`. No instance state needed.",
            "status": "done",
            "testStrategy": "Verify method exists: `hasattr(ConfigurationLoader, '_get_candidate_files')` and accepts (list[Path], str | None) -> list[Path].",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:12:50.545Z"
          },
          {
            "id": 2,
            "title": "Implement buvis.yaml candidate generation for each path",
            "description": "Add loop to append buvis.yaml for each base path in the input list.",
            "dependencies": [
              1
            ],
            "details": "Update `_get_candidate_files` to iterate through paths and add base config:\n```python\n@staticmethod\ndef _get_candidate_files(paths: list[Path], tool_name: str | None) -> list[Path]:\n    candidates: list[Path] = []\n    for base in paths:\n        candidates.append(base / \"buvis.yaml\")\n    return candidates\n```\nThis ensures every search location has its buvis.yaml added. The base file is always included regardless of tool_name.",
            "status": "done",
            "testStrategy": "Test with paths=[Path('/a'), Path('/b')], tool_name=None. Verify returns [Path('/a/buvis.yaml'), Path('/b/buvis.yaml')].",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:12:50.592Z"
          },
          {
            "id": 3,
            "title": "Implement tool-specific buvis-{tool}.yaml candidate generation",
            "description": "Add conditional logic to append tool-specific config files when tool_name is provided.",
            "dependencies": [
              2
            ],
            "details": "Complete the method with tool_name conditional logic:\n```python\n@staticmethod\ndef _get_candidate_files(paths: list[Path], tool_name: str | None) -> list[Path]:\n    candidates: list[Path] = []\n    for base in paths:\n        candidates.append(base / \"buvis.yaml\")\n        if tool_name:\n            candidates.append(base / f\"buvis-{tool_name}.yaml\")\n    return candidates\n```\nKey: interleave base and tool-specific per location to maintain priority (location > file type). Empty string tool_name treated as falsy.",
            "status": "done",
            "testStrategy": "Test with paths=[Path('/a')], tool_name='payroll'. Verify returns [Path('/a/buvis.yaml'), Path('/a/buvis-payroll.yaml')].",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:12:50.758Z"
          },
          {
            "id": 4,
            "title": "Create test class TestGetCandidateFiles with basic test cases",
            "description": "Add test class in tests/configuration/test_loader.py covering no tool_name and empty paths scenarios.",
            "dependencies": [
              3
            ],
            "details": "Create/update `tests/configuration/test_loader.py`:\n```python\nimport pytest\nfrom pathlib import Path\nfrom buvis.pybase.configuration.loader import ConfigurationLoader\n\nclass TestGetCandidateFiles:\n    def test_empty_paths_returns_empty(self) -> None:\n        result = ConfigurationLoader._get_candidate_files([], None)\n        assert result == []\n\n    def test_single_path_no_tool(self) -> None:\n        result = ConfigurationLoader._get_candidate_files([Path(\"/cfg\")], None)\n        assert result == [Path(\"/cfg/buvis.yaml\")]\n\n    def test_multiple_paths_no_tool(self) -> None:\n        paths = [Path(\"/a\"), Path(\"/b\")]\n        result = ConfigurationLoader._get_candidate_files(paths, None)\n        assert result == [Path(\"/a/buvis.yaml\"), Path(\"/b/buvis.yaml\")]\n```",
            "status": "done",
            "testStrategy": "Run `uv run pytest tests/configuration/test_loader.py::TestGetCandidateFiles -v` - all tests should pass.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:12:51.161Z"
          },
          {
            "id": 5,
            "title": "Add tests for tool_name and verify interleaved ordering",
            "description": "Add test cases verifying tool-specific file generation and correct priority ordering.",
            "dependencies": [
              4
            ],
            "details": "Add to `TestGetCandidateFiles` class:\n```python\n    def test_single_path_with_tool(self) -> None:\n        result = ConfigurationLoader._get_candidate_files([Path(\"/cfg\")], \"payroll\")\n        assert result == [Path(\"/cfg/buvis.yaml\"), Path(\"/cfg/buvis-payroll.yaml\")]\n\n    def test_multiple_paths_with_tool_maintains_interleaved_order(self) -> None:\n        paths = [Path(\"/a\"), Path(\"/b\")]\n        result = ConfigurationLoader._get_candidate_files(paths, \"myapp\")\n        expected = [\n            Path(\"/a/buvis.yaml\"),\n            Path(\"/a/buvis-myapp.yaml\"),\n            Path(\"/b/buvis.yaml\"),\n            Path(\"/b/buvis-myapp.yaml\"),\n        ]\n        assert result == expected\n\n    def test_empty_string_tool_name_treated_as_no_tool(self) -> None:\n        result = ConfigurationLoader._get_candidate_files([Path(\"/cfg\")], \"\")\n        assert result == [Path(\"/cfg/buvis.yaml\")]\n```\nThis verifies the critical interleaved ordering: for each location, base then tool-specific.",
            "status": "done",
            "testStrategy": "Run full test suite for loader. Verify ordering test ensures /a files before /b files (location priority preserved).",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:12:51.568Z"
          }
        ],
        "updatedAt": "2026-01-02T18:12:51.568Z"
      },
      {
        "id": "14",
        "title": "Add symlink security validation",
        "description": "Implement symlink attack prevention by validating resolved paths stay within expected directories.",
        "details": "Create `_is_safe_path(path: Path, allowed_bases: list[Path]) -> bool`:\n```python\n@staticmethod\ndef _is_safe_path(candidate: Path, allowed_bases: list[Path]) -> bool:\n    \"\"\"Reject symlinks pointing outside expected directories.\"\"\"\n    try:\n        resolved = candidate.resolve()\n        # Check resolved path is under one of the allowed bases\n        for base in allowed_bases:\n            try:\n                resolved.relative_to(base.resolve())\n                return True\n            except ValueError:\n                continue\n        return False\n    except (OSError, RuntimeError):\n        return False\n```\nReject any path that resolves outside the search directories.",
        "testStrategy": "Test with normal files (safe), symlinks within allowed dirs (safe), symlinks pointing outside (unsafe), broken symlinks (unsafe).",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add _is_safe_path static method to DirTree class",
            "description": "Implement the core symlink security validation method that checks if a resolved path stays within allowed base directories.",
            "dependencies": [],
            "details": "Add to `src/buvis/pybase/filesystem/dir_tree/dir_tree.py`:\n```python\n@staticmethod\ndef _is_safe_path(candidate: Path, allowed_bases: list[Path]) -> bool:\n    \"\"\"Reject symlinks pointing outside expected directories.\n    \n    Args:\n        candidate: Path to validate (may be symlink)\n        allowed_bases: Directories the resolved path must be under\n    \n    Returns:\n        True if resolved path is under one of allowed_bases\n    \"\"\"\n    try:\n        resolved = candidate.resolve()\n        for base in allowed_bases:\n            try:\n                resolved.relative_to(base.resolve())\n                return True\n            except ValueError:\n                continue\n        return False\n    except (OSError, RuntimeError):\n        return False\n```\nMethod is private (underscore prefix) since it's internal validation logic.",
            "status": "done",
            "testStrategy": "Covered by subtask 2 dedicated tests.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:17:08.026Z"
          },
          {
            "id": 2,
            "title": "Add comprehensive tests for _is_safe_path method",
            "description": "Create test file with cases for normal files, safe symlinks, unsafe symlinks, and broken symlinks using tmp_path fixture.",
            "dependencies": [
              1
            ],
            "details": "Create `tests/filesystem/test_dir_tree_symlink_security.py`:\n```python\nimport pytest\nfrom pathlib import Path\nfrom buvis.pybase.filesystem import DirTree\n\nclass TestIsSafePath:\n    def test_regular_file_is_safe(self, tmp_path: Path) -> None:\n        file = tmp_path / \"file.txt\"\n        file.touch()\n        assert DirTree._is_safe_path(file, [tmp_path]) is True\n    \n    def test_symlink_within_allowed_dir_is_safe(self, tmp_path: Path) -> None:\n        target = tmp_path / \"target.txt\"\n        target.touch()\n        link = tmp_path / \"link.txt\"\n        link.symlink_to(target)\n        assert DirTree._is_safe_path(link, [tmp_path]) is True\n    \n    def test_symlink_outside_allowed_dir_is_unsafe(self, tmp_path: Path) -> None:\n        allowed = tmp_path / \"allowed\"\n        allowed.mkdir()\n        outside = tmp_path / \"outside\" / \"target.txt\"\n        outside.parent.mkdir()\n        outside.touch()\n        link = allowed / \"escape.txt\"\n        link.symlink_to(outside)\n        assert DirTree._is_safe_path(link, [allowed]) is False\n    \n    def test_broken_symlink_is_unsafe(self, tmp_path: Path) -> None:\n        link = tmp_path / \"broken.txt\"\n        link.symlink_to(tmp_path / \"nonexistent\")\n        assert DirTree._is_safe_path(link, [tmp_path]) is False\n    \n    def test_multiple_allowed_bases(self, tmp_path: Path) -> None:\n        dir1 = tmp_path / \"dir1\"\n        dir2 = tmp_path / \"dir2\"\n        dir1.mkdir(); dir2.mkdir()\n        file = dir2 / \"file.txt\"\n        file.touch()\n        assert DirTree._is_safe_path(file, [dir1, dir2]) is True\n```",
            "status": "done",
            "testStrategy": "Run `uv run pytest tests/filesystem/test_dir_tree_symlink_security.py -v` to verify all edge cases pass.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:17:08.072Z"
          },
          {
            "id": 3,
            "title": "Create _safe_rglob helper method filtering unsafe paths",
            "description": "Add internal generator method that wraps rglob and filters out paths that fail symlink security validation.",
            "dependencies": [
              1
            ],
            "details": "Add to DirTree class after `_is_safe_path`:\n```python\n@staticmethod\ndef _safe_rglob(directory: Path, pattern: str = \"*\") -> Iterator[Path]:\n    \"\"\"Recursively glob, skipping paths resolving outside directory.\n    \n    Args:\n        directory: Base directory for traversal\n        pattern: Glob pattern (default \"*\")\n    \n    Yields:\n        Paths that resolve within directory\n    \"\"\"\n    allowed = [directory.resolve()]\n    for path in directory.rglob(pattern):\n        if DirTree._is_safe_path(path, allowed):\n            yield path\n```\nAdd `from typing import Iterator` to imports. This centralizes the filtering logic so individual methods don't duplicate it.",
            "status": "done",
            "testStrategy": "Add tests in same test file verifying _safe_rglob skips unsafe symlinks while yielding safe paths.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:17:08.135Z"
          },
          {
            "id": 4,
            "title": "Integrate _safe_rglob into all traversal functions",
            "description": "Replace direct rglob calls with _safe_rglob in count_files, get_max_depth, and all module functions using directory traversal.",
            "dependencies": [
              3
            ],
            "details": "Update these files to use `DirTree._safe_rglob(directory)` instead of `directory.rglob(\"*\")`:\n\n1. `dir_tree.py` - count_files, get_max_depth methods\n2. `delete_by_extension.py` - line 18\n3. `lowercase_file_extensions.py` - line 13  \n4. `merge_mac_metadata.py` - line 23 (pattern: `._*`)\n5. `remove_empty_directories.py` - line 13\n6. `rename_equivalent_extensions.py` - line 27\n\nFor functions in separate modules, import DirTree:\n```python\nfrom buvis.pybase.filesystem.dir_tree.dir_tree import DirTree\n\nfor file_path in DirTree._safe_rglob(directory):\n```\nFor merge_mac_metadata, use `DirTree._safe_rglob(directory, \"._*\")` to preserve pattern.",
            "status": "done",
            "testStrategy": "Run existing tests + new integration tests to verify no regressions.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:17:08.385Z"
          },
          {
            "id": 5,
            "title": "Add integration tests for symlink filtering in DirTree methods",
            "description": "Test that public DirTree methods correctly skip files accessed via malicious symlinks during directory operations.",
            "dependencies": [
              4
            ],
            "details": "Add to `tests/filesystem/test_dir_tree_symlink_security.py`:\n```python\nclass TestDirTreeSymlinkIntegration:\n    def test_count_files_ignores_symlink_escape(self, tmp_path: Path) -> None:\n        allowed = tmp_path / \"allowed\"\n        allowed.mkdir()\n        (allowed / \"real.txt\").touch()\n        outside = tmp_path / \"outside\"\n        outside.mkdir()\n        (outside / \"secret.txt\").touch()\n        (allowed / \"escape\").symlink_to(outside)\n        \n        assert DirTree.count_files(allowed) == 1  # only real.txt\n    \n    def test_delete_by_extension_skips_symlink_escape(self, tmp_path: Path) -> None:\n        allowed = tmp_path / \"allowed\"\n        allowed.mkdir()\n        outside = tmp_path / \"outside\"\n        outside.mkdir()\n        target = outside / \"keep.txt\"\n        target.touch()\n        (allowed / \"escape\").symlink_to(outside)\n        \n        DirTree.delete_by_extension(allowed, [\".txt\"])\n        assert target.exists()  # outside file not deleted\n```\nSimilar tests for other public methods that traverse directories.",
            "status": "done",
            "testStrategy": "Run full test suite: `uv run pytest tests/filesystem/ -v`. Verify symlink escapes are blocked for all public methods.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:17:08.799Z"
          }
        ],
        "updatedAt": "2026-01-02T18:17:08.799Z"
      },
      {
        "id": "15",
        "title": "Add world-writable file detection",
        "description": "Implement warning/rejection for world-writable config files as security measure.",
        "details": "Create `_is_world_writable(path: Path) -> bool`:\n```python\nimport stat\n\n@staticmethod\ndef _is_world_writable(path: Path) -> bool:\n    \"\"\"Check if file has world-writable permissions.\"\"\"\n    try:\n        mode = path.stat().st_mode\n        return bool(mode & stat.S_IWOTH)\n    except OSError:\n        return False\n```\nAdd logging import, emit warning when world-writable file found. Consider adding strict mode parameter to reject vs warn.",
        "testStrategy": "Create temp files with various permissions (0o644, 0o666, 0o777). Verify correct detection. Test with non-existent files.",
        "priority": "medium",
        "dependencies": [
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement _is_world_writable static method",
            "description": "Create the core detection function that checks file permissions using stat module.",
            "dependencies": [],
            "details": "Add `_is_world_writable(path: Path) -> bool` static method to ConfigurationLoader class. Use `stat.S_IWOTH` bitmask to check world-writable permission. Return False on OSError (handles non-existent files, permission denied). Import `stat` module. Method signature: `@staticmethod def _is_world_writable(path: Path) -> bool`.",
            "status": "pending",
            "testStrategy": "Create temp files with chmod 0o644 (not writable), 0o646 (world-writable), 0o777 (all writable). Verify correct detection. Test with non-existent path returns False.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add module-level logger for ConfigurationLoader",
            "description": "Add logging infrastructure following the codebase's established pattern from shell.py.",
            "dependencies": [
              1
            ],
            "details": "Add `import logging` and create module-level logger: `logger = logging.getLogger(__name__)`. Place after other imports, before class definition. This follows the pattern used in `src/buvis/pybase/adapters/shell/shell.py:11`.",
            "status": "pending",
            "testStrategy": "Verify logger is accessible from module. Test that logging calls don't raise exceptions when logger not configured.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate world-writable check with warning emission",
            "description": "Add world-writable detection to find_config_files with warning log when detected.",
            "dependencies": [
              1,
              2
            ],
            "details": "In find_config_files loop, after `candidate.is_file()` check, add: `if ConfigurationLoader._is_world_writable(candidate): logger.warning(\"Config file %s is world-writable\", candidate)`. Continue processing the file (warn-only behavior). This integrates with Task 16's find_config_files implementation.",
            "status": "pending",
            "testStrategy": "Mock logger.warning, create world-writable temp file, call find_config_files, verify warning logged with correct path. Verify file still included in results.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add strict_permissions parameter for reject behavior",
            "description": "Add optional parameter to reject world-writable files instead of just warning.",
            "dependencies": [
              3
            ],
            "details": "Add `strict_permissions: bool = False` parameter to find_config_files. When True and world-writable detected: log error (`logger.error`) and skip file. When False: log warning and include file. Update signature: `def find_config_files(tool_name: str | None = None, *, strict_permissions: bool = False) -> list[Path]`.",
            "status": "pending",
            "testStrategy": "Test strict_permissions=False logs warning and includes file. Test strict_permissions=True logs error and excludes file. Test normal files unaffected by parameter.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Write comprehensive test suite for world-writable detection",
            "description": "Create test file with full coverage of permission detection and strict mode behavior.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create `tests/configuration/test_configuration_loader_permissions.py`. Test classes: TestIsWorldWritable (0o644, 0o666, 0o777, non-existent, OSError scenarios), TestWorldWritableWarning (mock logging, verify messages), TestStrictPermissions (file exclusion, error logging). Use pytest fixtures for temp files with controlled permissions. Use `@pytest.mark.skipif` for platform-specific tests if needed.",
            "status": "pending",
            "testStrategy": "Run pytest, verify all tests pass. Check coverage includes _is_world_writable and strict_permissions branches. Test on both strict and non-strict modes.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:10:25.905Z"
      },
      {
        "id": "16",
        "title": "Implement find_config_files main logic",
        "description": "Complete the find_config_files method integrating path building, candidate generation, and security checks.",
        "details": "Complete implementation:\n```python\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@staticmethod\ndef find_config_files(tool_name: str | None = None) -> list[Path]:\n    paths = ConfigurationLoader._get_search_paths()\n    candidates = ConfigurationLoader._get_candidate_files(paths, tool_name)\n    result: list[Path] = []\n    \n    for candidate in candidates:\n        if not candidate.is_file():\n            continue\n        if not ConfigurationLoader._is_safe_path(candidate, paths):\n            logger.warning(\"Skipping unsafe config path: %s\", candidate)\n            continue\n        if ConfigurationLoader._is_world_writable(candidate):\n            logger.warning(\"Config file is world-writable: %s\", candidate)\n        result.append(candidate.resolve())\n    \n    return result\n```\nHandle PermissionError by skipping file and continuing.",
        "testStrategy": "Integration test with temp directory structure. Test: no files exist, single file, multiple files, permission denied scenario.",
        "priority": "high",
        "dependencies": [
          "12",
          "13",
          "14",
          "15"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create loader.py module with find_config_files signature",
            "description": "Create the configuration loader module with imports and the find_config_files method signature.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/loader.py` with:\n- `from __future__ import annotations`\n- `import logging` and `from pathlib import Path`\n- `logger = logging.getLogger(__name__)`\n- Class `ConfigurationLoader` with `@staticmethod def find_config_files(tool_name: str | None = None) -> list[Path]:`\n- Add docstring following Google format\n- Export in `configuration/__init__.py`",
            "status": "pending",
            "testStrategy": "Import ConfigurationLoader from buvis.pybase.configuration. Verify method signature accepts optional tool_name and returns list[Path].",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement main iteration loop with file existence check",
            "description": "Add the core loop that calls helper methods and filters candidates by file existence.",
            "dependencies": [
              1
            ],
            "details": "In find_config_files:\n```python\npaths = ConfigurationLoader._get_search_paths()\ncandidates = ConfigurationLoader._get_candidate_files(paths, tool_name)\nresult: list[Path] = []\n\nfor candidate in candidates:\n    if not candidate.is_file():\n        continue\n    result.append(candidate.resolve())\n\nreturn result\n```\nThis assumes _get_search_paths and _get_candidate_files exist from tasks 12-13.",
            "status": "pending",
            "testStrategy": "Create temp dir with some buvis.yaml files. Mock _get_search_paths to return temp paths. Verify only existing files returned in correct order.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate _is_safe_path security validation",
            "description": "Add symlink security check that skips unsafe paths and logs warning.",
            "dependencies": [
              2
            ],
            "details": "Before appending to result, add:\n```python\nif not ConfigurationLoader._is_safe_path(candidate, paths):\n    logger.warning(\"Skipping unsafe config path: %s\", candidate)\n    continue\n```\nThis rejects symlinks pointing outside expected directories per PRD-00002 security constraints. The paths list defines allowed parent directories.",
            "status": "pending",
            "testStrategy": "Create symlink pointing outside allowed dirs. Verify file skipped with warning logged. Test normal files pass through.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate _is_world_writable detection with warning",
            "description": "Add world-writable file detection that logs warning but still includes file.",
            "dependencies": [
              3
            ],
            "details": "After is_safe_path check, before appending:\n```python\nif ConfigurationLoader._is_world_writable(candidate):\n    logger.warning(\"Config file is world-writable: %s\", candidate)\n```\nNote: PRD says warn but don't reject. File still gets added to result. This differs from is_safe_path which rejects.",
            "status": "pending",
            "testStrategy": "Create temp file with 0o666 perms. Verify warning logged but file still in result. Test 0o644 file produces no warning.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add PermissionError handling and integration tests",
            "description": "Wrap file checks in try/except PermissionError to skip inaccessible files gracefully.",
            "dependencies": [
              4
            ],
            "details": "Wrap the loop body in try/except:\n```python\nfor candidate in candidates:\n    try:\n        if not candidate.is_file():\n            continue\n        # ... existing checks ...\n        result.append(candidate.resolve())\n    except PermissionError:\n        logger.debug(\"Permission denied: %s\", candidate)\n        continue\n```\nCreate integration test in tests/configuration/test_loader.py covering: no files, single file, multiple files, permission denied.",
            "status": "pending",
            "testStrategy": "Mock Path.is_file to raise PermissionError. Verify file skipped without crashing. Integration test with temp dir structure covering all edge cases from PRD-00002.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:13:29.306Z"
      },
      {
        "id": "17",
        "title": "Export ConfigurationLoader in __init__.py",
        "description": "Add ConfigurationLoader to configuration module exports.",
        "details": "Update src/buvis/pybase/configuration/__init__.py:\n```python\nfrom .configuration import Configuration, ConfigurationKeyNotFoundError, cfg\nfrom .loader import ConfigurationLoader\n\n__all__ = [\"Configuration\", \"ConfigurationKeyNotFoundError\", \"ConfigurationLoader\", \"cfg\"]\n```",
        "testStrategy": "Verify import works: `from buvis.pybase.configuration import ConfigurationLoader`",
        "priority": "medium",
        "dependencies": [
          "16"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify loader.py module exists with ConfigurationLoader class",
            "description": "Confirm task 16 dependency is complete and loader.py has ConfigurationLoader class defined.",
            "dependencies": [],
            "details": "Check that `src/buvis/pybase/configuration/loader.py` exists and contains the `ConfigurationLoader` class. This is the prerequisite from task 16. The class should have `find_config_files` method. If missing, task 16 must complete first.",
            "status": "pending",
            "testStrategy": "Run `uv run python -c \"from buvis.pybase.configuration.loader import ConfigurationLoader\"` to verify class exists",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add ConfigurationLoader import to __init__.py",
            "description": "Add import statement for ConfigurationLoader from the loader module.",
            "dependencies": [
              1
            ],
            "details": "Edit `src/buvis/pybase/configuration/__init__.py` to add:\n```python\nfrom .loader import ConfigurationLoader\n```\nPlace after existing `.configuration` import. Follow alphabetical ordering pattern used in adapters/__init__.py.",
            "status": "pending",
            "testStrategy": "Verify file parses without syntax errors: `uv run python -m py_compile src/buvis/pybase/configuration/__init__.py`",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add ConfigurationLoader to __all__ list",
            "description": "Update __all__ list to include ConfigurationLoader for public API exposure.",
            "dependencies": [
              2
            ],
            "details": "Edit `src/buvis/pybase/configuration/__init__.py` to update __all__:\n```python\n__all__ = [\"Configuration\", \"ConfigurationKeyNotFoundError\", \"ConfigurationLoader\", \"cfg\"]\n```\nMaintain alphabetical order. ConfigurationLoader goes after ConfigurationKeyNotFoundError.",
            "status": "pending",
            "testStrategy": "Verify __all__ contains 'ConfigurationLoader': `uv run python -c \"from buvis.pybase.configuration import __all__; assert 'ConfigurationLoader' in __all__\"`",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Verify public import works",
            "description": "Test that ConfigurationLoader can be imported from the configuration module's public API.",
            "dependencies": [
              3
            ],
            "details": "Run verification command:\n```bash\nuv run python -c \"from buvis.pybase.configuration import ConfigurationLoader; print(ConfigurationLoader)\"\n```\nShould print class reference without ImportError. This confirms the export chain works from loader.py through __init__.py.",
            "status": "pending",
            "testStrategy": "Import succeeds and prints class reference: `<class 'buvis.pybase.configuration.loader.ConfigurationLoader'>`",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run configuration module tests",
            "description": "Execute pytest on configuration tests to ensure no regressions from the export change.",
            "dependencies": [
              4
            ],
            "details": "Run:\n```bash\nuv run pytest tests/configuration/ -v\n```\nAll existing tests should pass. The new export shouldn't break any existing imports. If tests fail, investigate import ordering or circular dependency issues.",
            "status": "pending",
            "testStrategy": "All tests pass with exit code 0. No import errors or test failures related to configuration module.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:13:55.491Z"
      },
      {
        "id": "18",
        "title": "Create test file structure for loader tests",
        "description": "Create tests/configuration/test_configuration_loader.py with fixtures for testing.",
        "details": "Create test file following existing patterns:\n```python\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom buvis.pybase.configuration.loader import ConfigurationLoader\n\n\n@pytest.fixture\ndef temp_config_dir(tmp_path: Path) -> Path:\n    \"\"\"Create temp directory structure for config testing.\"\"\"\n    return tmp_path\n\n\nclass TestConfigurationLoaderSearchPaths:\n    \"\"\"Test search path building.\"\"\"\n    ...\n\nclass TestConfigurationLoaderFindFiles:\n    \"\"\"Test file discovery.\"\"\"\n    ...\n\nclass TestConfigurationLoaderSecurity:\n    \"\"\"Test security validations.\"\"\"\n    ...\n```\nMirror src structure in tests/.",
        "testStrategy": "N/A - this task creates test infrastructure.",
        "priority": "medium",
        "dependencies": [
          "17"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create tests/configuration directory structure",
            "description": "Create the tests/configuration/ directory with __init__.py to mirror src structure.",
            "dependencies": [],
            "details": "Run mkdir -p tests/configuration && touch tests/configuration/__init__.py to create directory structure matching src/buvis/pybase/configuration/. Empty __init__.py enables pytest discovery.",
            "status": "pending",
            "testStrategy": "Verify directory exists and pytest can discover it with `pytest tests/configuration/ --collect-only`.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create test file with imports and temp_config_dir fixture",
            "description": "Create tests/configuration/test_configuration_loader.py with imports and base fixture.",
            "dependencies": [
              1
            ],
            "details": "Create file with: `from __future__ import annotations`, os/Path/patch imports, pytest, ConfigurationLoader import, and temp_config_dir fixture using tmp_path. Follow pattern from test_shell_adapter.py with proper type hints.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_configuration_loader.py --collect-only` to verify file imports correctly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add TestConfigurationLoaderSearchPaths class scaffold",
            "description": "Create test class scaffold for search path building with method stubs.",
            "dependencies": [
              2
            ],
            "details": "Add class with docstring 'Test search path building.' and stub methods: test_xdg_config_home_used, test_buvis_config_dir_overrides, test_legacy_home_path_included, test_cwd_included. Each stub has `pass` body and docstring describing test purpose.",
            "status": "pending",
            "testStrategy": "Run pytest --collect-only and verify 4 test methods are discovered under TestConfigurationLoaderSearchPaths.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add TestConfigurationLoaderFindFiles class scaffold",
            "description": "Create test class scaffold for file discovery with method stubs.",
            "dependencies": [
              2
            ],
            "details": "Add class with docstring 'Test file discovery.' and stub methods: test_no_files_returns_empty_list, test_single_file_found, test_multiple_files_in_priority_order, test_tool_specific_files_included, test_permission_denied_skipped. Follow existing test pattern.",
            "status": "pending",
            "testStrategy": "Run pytest --collect-only and verify 5 test methods are discovered under TestConfigurationLoaderFindFiles.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add TestConfigurationLoaderSecurity class scaffold",
            "description": "Create test class scaffold for security validations with method stubs.",
            "dependencies": [
              2
            ],
            "details": "Add class with docstring 'Test security validations.' and stub methods: test_symlink_outside_dir_rejected, test_world_writable_warning, test_paths_resolved_before_read. These map to security constraints in PRD-00002.",
            "status": "pending",
            "testStrategy": "Run pytest --collect-only and verify 3 test methods are discovered under TestConfigurationLoaderSecurity.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:14:12.034Z"
      },
      {
        "id": "19",
        "title": "Implement loader unit tests",
        "description": "Write comprehensive unit tests for ConfigurationLoader covering all PRD test cases.",
        "details": "Implement tests from PRD:\n```python\nclass TestConfigurationLoaderFindFiles:\n    def test_xdg_config_home_set_file_exists(self, tmp_path):\n        xdg = tmp_path / \"xdg\"\n        xdg.mkdir()\n        (xdg / \"buvis\").mkdir()\n        (xdg / \"buvis\" / \"buvis.yaml\").write_text(\"key: value\")\n        with patch.dict(os.environ, {\"XDG_CONFIG_HOME\": str(xdg)}, clear=False):\n            with patch.object(Path, \"cwd\", return_value=tmp_path):\n                files = ConfigurationLoader.find_config_files()\n        assert len(files) >= 1\n        assert any(\"buvis.yaml\" in str(f) for f in files)\n    \n    def test_no_files_anywhere_returns_empty(self, tmp_path):\n        with patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": str(tmp_path)}, clear=False):\n            files = ConfigurationLoader.find_config_files()\n        # May return empty if no standard locations have files\n```\nTest all 5 PRD test cases plus edge cases.",
        "testStrategy": "Run pytest, verify all tests pass. Check coverage of edge cases.",
        "priority": "medium",
        "dependencies": [
          "18"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement XDG_CONFIG_HOME and BUVIS_CONFIG_DIR environment variable tests",
            "description": "Write tests verifying config file discovery when XDG_CONFIG_HOME and BUVIS_CONFIG_DIR environment variables are set.",
            "dependencies": [],
            "details": "Create TestConfigurationLoaderEnvVars class in tests/configuration/test_configuration_loader.py with:\n- test_xdg_config_home_set_file_exists: use tmp_path to create xdg/buvis/buvis.yaml, patch XDG_CONFIG_HOME, verify file returned in results\n- test_buvis_config_dir_overrides_xdg: set both vars with files, verify BUVIS_CONFIG_DIR file appears first (higher priority)\n- test_empty_env_var_treated_as_unset: set BUVIS_CONFIG_DIR='', verify falls through to XDG location\n- test_xdg_empty_string_uses_default: set XDG_CONFIG_HOME='', verify ~/.config used as fallback\nUse patch.dict(os.environ, {...}, clear=False) and tmp_path fixture. Follow pattern from test_shell_adapter.py:100-116.",
            "status": "pending",
            "testStrategy": "Run pytest with -v flag, verify each test passes. Check patch.dict correctly isolates env var changes between tests.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement no-files and empty-results edge case tests",
            "description": "Write tests verifying behavior when no config files exist anywhere in the search paths.",
            "dependencies": [
              1
            ],
            "details": "Add TestConfigurationLoaderNoFiles class with:\n- test_no_files_anywhere_returns_empty: create empty tmp_path, patch all env vars to point there, verify empty list returned\n- test_directory_exists_but_no_yaml_files: create buvis directory without yaml files, verify empty list\n- test_wrong_filename_not_matched: create buvis/config.yaml (wrong name), verify not included in results\n- test_cwd_empty_no_env_vars: patch Path.cwd() to empty dir with no env vars set, verify defaults used and empty result if no files\nUse tmp_path fixture to create isolated test environments. Each test should patch BUVIS_CONFIG_DIR to control search scope.",
            "status": "pending",
            "testStrategy": "Verify each test returns empty list when no valid config files exist. Confirm no exceptions raised.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement multiple files priority order tests",
            "description": "Write tests verifying config files are returned in correct priority order when multiple exist.",
            "dependencies": [
              1
            ],
            "details": "Add TestConfigurationLoaderPriorityOrder class with:\n- test_multiple_files_returned_in_priority_order: create files in all 4 locations (BUVIS_CONFIG_DIR, XDG, ~/.buvis, cwd), verify returned order matches priority spec\n- test_buvis_config_dir_highest_priority: verify BUVIS_CONFIG_DIR file listed before XDG file\n- test_xdg_before_legacy_home: verify XDG location before ~/.buvis\n- test_legacy_home_before_cwd: verify ~/.buvis before ./buvis.yaml\n- test_all_existing_files_returned: create files in all locations, verify len(result) >= 4\nPriority order per PRD: BUVIS_CONFIG_DIR > XDG_CONFIG_HOME/buvis > ~/.buvis > ./cwd. Use tmp_path with nested structure simulating all locations.",
            "status": "pending",
            "testStrategy": "Assert result list order matches expected priority. Verify all existing files included, none skipped.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement tool-specific file discovery tests",
            "description": "Write tests verifying tool-specific buvis-{tool}.yaml files are discovered alongside base config files.",
            "dependencies": [
              1,
              3
            ],
            "details": "Add TestConfigurationLoaderToolSpecific class with:\n- test_tool_name_finds_tool_specific_file: create buvis-payroll.yaml, call find_config_files(tool_name='payroll'), verify included\n- test_tool_name_none_excludes_tool_files: create both buvis.yaml and buvis-payroll.yaml, call with tool_name=None, verify only buvis.yaml returned\n- test_tool_files_interleaved_per_location: per PRD, each location should have buvis.yaml then buvis-{tool}.yaml, verify ordering\n- test_nonexistent_tool_returns_base_only: call with tool_name='nonexistent', verify only buvis.yaml files returned\n- test_multiple_tool_configs_across_locations: create tool files in multiple locations, verify all returned with correct priority\nTool files are searched in parallel with base files per location, interleaved in result list.",
            "status": "pending",
            "testStrategy": "Verify tool-specific files included/excluded correctly based on tool_name parameter. Check interleaving order.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement security constraint and permission edge case tests",
            "description": "Write tests verifying symlink validation, permission denied handling, and path safety checks.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add TestConfigurationLoaderSecurity class with:\n- test_symlink_outside_expected_dir_rejected: create symlink pointing outside search paths, verify file skipped (per PRD security constraint)\n- test_resolved_path_used: verify .resolve() called before file operations (mock or check result uses absolute paths)\n- test_permission_denied_skips_file: use mock to raise PermissionError on is_file(), verify file skipped, search continues, no exception raised\n- test_world_writable_file_handled: create file with 0o777 perms, verify warning logged or file skipped per implementation\n- test_relative_symlink_within_allowed_resolved: symlink within allowed dir should work\nPer PRD: reject symlinks outside expected dirs, no world-writable, resolve before read. Use unittest.mock.patch for permission scenarios.",
            "status": "pending",
            "testStrategy": "Verify security violations are detected and handled gracefully. No exceptions propagated to caller. Confirm _is_safe_path integration.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:14:52.111Z"
      },
      {
        "id": "20",
        "title": "Integrate loader with Configuration class",
        "description": "Update Configuration._determine_config_path to optionally use ConfigurationLoader for discovery.",
        "details": "Modify Configuration class to support automatic discovery:\n```python\nfrom buvis.pybase.configuration.loader import ConfigurationLoader\n\ndef _determine_config_path(self, file_path: Path | None) -> Path | None:\n    if file_path is not None:\n        # ... existing explicit path handling ...\n    \n    # Try auto-discovery first\n    discovered = ConfigurationLoader.find_config_files()\n    if discovered:\n        return discovered[0]  # Highest priority file\n    \n    # Fallback to legacy behavior\n    alternative_file_path = Path(\n        os.getenv(\"BUVIS_CONFIG_FILE\", Path.home() / \".config/buvis/config.yaml\"),\n    )\n    ...\n```\nThis maintains backward compatibility while enabling new discovery. Consider deprecation warning for BUVIS_CONFIG_FILE.",
        "testStrategy": "Test Configuration() with: no config (returns None), discovered config, explicit path. Verify backward compat with BUVIS_CONFIG_FILE.",
        "priority": "low",
        "dependencies": [
          "16"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Import ConfigurationLoader in Configuration module",
            "description": "Add import for ConfigurationLoader from the loader module to make it available for use in _determine_config_path",
            "dependencies": [],
            "details": "Add import at top of configuration.py:\n```python\nfrom buvis.pybase.configuration.loader import ConfigurationLoader\n```\nPlace after existing imports (line 9). Also add 'import warnings' for the deprecation warning in later subtasks. The ConfigurationLoader must exist (Task 16 dependency) before this can be implemented.",
            "status": "pending",
            "testStrategy": "Verify import works: `from buvis.pybase.configuration.configuration import Configuration` should not raise ImportError. Run existing tests to confirm no regressions.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add auto-discovery via ConfigurationLoader.find_config_files()",
            "description": "Modify _determine_config_path to try ConfigurationLoader discovery when no explicit path is provided",
            "dependencies": [
              1
            ],
            "details": "In _determine_config_path (line 47-83), after the explicit path check (line 69-74), add discovery logic:\n```python\n# Try auto-discovery first\ndiscovered = ConfigurationLoader.find_config_files()\nif discovered:\n    return discovered[0]  # Highest priority file\n```\nThis should be inserted before the legacy BUVIS_CONFIG_FILE fallback (line 76-81). Keep existing docstring but update to mention auto-discovery.",
            "status": "pending",
            "testStrategy": "Test Configuration() with mocked ConfigurationLoader.find_config_files() returning [Path('/found/config.yaml')]. Verify returned path matches discovered file.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add deprecation warning for BUVIS_CONFIG_FILE env var",
            "description": "Emit deprecation warning when BUVIS_CONFIG_FILE is used as fallback after auto-discovery fails",
            "dependencies": [
              2
            ],
            "details": "When the code falls through to BUVIS_CONFIG_FILE (line 76-81), and the env var is actually set, emit a DeprecationWarning:\n```python\nenv_config = os.getenv(\"BUVIS_CONFIG_FILE\")\nif env_config is not None:\n    warnings.warn(\n        \"BUVIS_CONFIG_FILE is deprecated. Place config.yaml in standard locations.\",\n        DeprecationWarning,\n        stacklevel=3,\n    )\n    alternative_file_path = Path(env_config)\nelse:\n    alternative_file_path = Path.home() / \".config/buvis/config.yaml\"\n```\nThis maintains backward compat while signaling the env var will be removed.",
            "status": "pending",
            "testStrategy": "Test with BUVIS_CONFIG_FILE set: verify DeprecationWarning raised using pytest.warns(). Test without env var: no warning emitted. Use @patch.dict(os.environ, ...) for env manipulation.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update docstring for _determine_config_path",
            "description": "Update method docstring to document new discovery behavior and deprecation",
            "dependencies": [
              2,
              3
            ],
            "details": "Replace docstring (lines 52-67) to reflect new priority order:\n1. Explicit file_path (raises FileNotFoundError if missing)\n2. Auto-discovery via ConfigurationLoader.find_config_files()\n3. BUVIS_CONFIG_FILE env var (deprecated)\n4. ~/.config/buvis/config.yaml default\nKeep Google docstring format. Mention deprecation of BUVIS_CONFIG_FILE.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add comprehensive tests for integration",
            "description": "Create test_configuration.py with tests covering all discovery paths and backward compatibility",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create tests/configuration/test_configuration.py:\n- Test explicit path: Configuration(Path('explicit.yaml')) uses that path\n- Test explicit path missing: raises FileNotFoundError\n- Test discovery: mock find_config_files() returns path, verify used\n- Test discovery empty + BUVIS_CONFIG_FILE: uses env var, warns\n- Test discovery empty + no env + default exists: uses default\n- Test discovery empty + no env + no default: returns None\n- Test backward compat: existing cfg singleton behavior unchanged\nUse fixtures and mocking patterns from test_shell_adapter.py.",
            "status": "pending",
            "testStrategy": "Run pytest tests/configuration/ - all tests should pass. Verify coverage of _determine_config_path is 100%.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "21",
        "title": "Create ConfigurationLoader module structure",
        "description": "Create the loader.py file in configuration/ with basic class skeleton and imports",
        "details": "Create `src/buvis/pybase/configuration/loader.py` with:\n\n```python\nfrom __future__ import annotations\n\nimport os\nimport re\nfrom pathlib import Path\nfrom typing import Any\n\nimport yaml\n\n_ENV_PATTERN = re.compile(r'\\$\\{([^}:]+)(?::-([^}]*))?\\}')\n\nclass ConfigurationLoader:\n    \"\"\"Load YAML configs with env var substitution.\"\"\"\n    pass\n```\n\nFollow existing code style: `from __future__ import annotations`, modern type hints (`dict[str, Any]` not `Dict`), Google docstrings.",
        "testStrategy": "Verify file created and imports work: `from buvis.pybase.configuration.loader import ConfigurationLoader`",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create loader.py with imports and env pattern regex",
            "description": "Create src/buvis/pybase/configuration/loader.py with required imports and _ENV_PATTERN regex constant",
            "dependencies": [],
            "details": "Create the loader.py file with:\n- `from __future__ import annotations` (first line, per codebase convention)\n- Standard lib imports: `import os`, `import re`, `from pathlib import Path`\n- Type imports: `from typing import Any`\n- Third party: `import yaml`\n- Define `_ENV_PATTERN = re.compile(r'\\$\\{([^}:]+)(?::-([^}]*))?\\}')` for env var substitution with default value support",
            "status": "done",
            "testStrategy": "Run `python -c \"from buvis.pybase.configuration.loader import _ENV_PATTERN; print(_ENV_PATTERN.pattern)\"` to verify regex loads",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:43:42.967Z"
          },
          {
            "id": 2,
            "title": "Add ConfigurationLoader class skeleton",
            "description": "Add the ConfigurationLoader class with Google-style docstring following existing Configuration class pattern",
            "dependencies": [
              1
            ],
            "details": "Add to loader.py:\n```python\nclass ConfigurationLoader:\n    \"\"\"Load YAML configs with env var substitution.\n    \n    Provides static methods for loading configuration files with support\n    for environment variable interpolation using ${VAR} or ${VAR:-default} syntax.\n    \"\"\"\n    pass\n```\nFollow the existing class style from configuration.py - Google docstrings, modern type hints",
            "status": "done",
            "testStrategy": "Verify class exists: `from buvis.pybase.configuration.loader import ConfigurationLoader`",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:43:43.016Z"
          },
          {
            "id": 3,
            "title": "Export ConfigurationLoader from __init__.py",
            "description": "Add ConfigurationLoader to configuration/__init__.py exports alongside existing Configuration class",
            "dependencies": [
              2
            ],
            "details": "Update src/buvis/pybase/configuration/__init__.py to include:\n- Add import: `from .loader import ConfigurationLoader`\n- Add to `__all__`: append `\"ConfigurationLoader\"` to the list\nFollow existing pattern: `from .configuration import Configuration, ConfigurationKeyNotFoundError, cfg`",
            "status": "done",
            "testStrategy": "Verify export: `from buvis.pybase.configuration import ConfigurationLoader`",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:43:43.064Z"
          },
          {
            "id": 4,
            "title": "Create tests/configuration directory and test file skeleton",
            "description": "Create tests/configuration/test_loader.py with basic test structure following existing test patterns",
            "dependencies": [
              3
            ],
            "details": "Create tests/configuration/test_loader.py with:\n- Import pytest and the ConfigurationLoader\n- Create `class TestConfigurationLoaderImports:` with test_can_import_class method\n- Create `class TestEnvPattern:` with basic regex tests\nFollow test_shell_adapter.py patterns: class-based organization, fixtures where needed, descriptive docstrings",
            "status": "done",
            "testStrategy": "Run `uv run pytest tests/configuration/test_loader.py -v` to verify test file loads and basic tests pass",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:43:43.219Z"
          },
          {
            "id": 5,
            "title": "Verify complete module integration",
            "description": "Run full test suite and verify ConfigurationLoader integrates with existing configuration module",
            "dependencies": [
              4
            ],
            "details": "Execute verification steps:\n1. Run `uv run pytest tests/configuration/ -v` to ensure all configuration tests pass\n2. Run `uv run pre-commit run --all-files` to verify code style compliance\n3. Test import chain: `from buvis.pybase.configuration import ConfigurationLoader, Configuration` both work\n4. Verify _ENV_PATTERN matches expected patterns: `${VAR}`, `${VAR:-default}`",
            "status": "done",
            "testStrategy": "Full integration: run pre-commit and pytest to confirm module is properly integrated and styled",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:43:43.610Z"
          }
        ],
        "updatedAt": "2026-01-02T17:43:43.610Z"
      },
      {
        "id": "22",
        "title": "Implement escape syntax for literal ${VAR}",
        "description": "Add pre-processing to convert $${VAR} to a placeholder, then restore after substitution",
        "details": "Before env substitution, escape `$${` sequences:\n\n```python\n_ESCAPE_PLACEHOLDER = '\\x00ESCAPED_DOLLAR\\x00'\n\ndef _escape_literals(content: str) -> str:\n    return content.replace('$${', _ESCAPE_PLACEHOLDER)\n\ndef _restore_literals(content: str) -> str:\n    return content.replace(_ESCAPE_PLACEHOLDER, '${')\n```\n\nUse null byte placeholder to avoid collision with real content. Apply escape before substitution, restore after.",
        "testStrategy": "Test: `$${VAR}` in input -> `${VAR}` in output (literal). Verify no substitution occurs for escaped vars.",
        "priority": "high",
        "dependencies": [
          "21"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add _ESCAPE_PLACEHOLDER constant to loader.py",
            "description": "Define the module-level constant using null byte placeholder to avoid collision with real config content",
            "dependencies": [],
            "details": "Add after imports in src/buvis/pybase/configuration/loader.py:\n\n```python\n_ESCAPE_PLACEHOLDER = '\\x00ESCAPED_DOLLAR\\x00'\n```\n\nNull byte chosen because it cannot appear in valid YAML text content, ensuring zero collision risk with user data.",
            "status": "pending",
            "testStrategy": "Verify constant exists and contains null bytes: `assert '\\x00' in _ESCAPE_PLACEHOLDER`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement _escape_literals() static method",
            "description": "Create method to convert $${VAR} sequences to placeholder before env substitution runs",
            "dependencies": [
              1
            ],
            "details": "Add to ConfigurationLoader class:\n\n```python\n@staticmethod\ndef _escape_literals(content: str) -> str:\n    \"\"\"Convert $${VAR} escape sequences to placeholder.\"\"\"\n    return content.replace('$${', _ESCAPE_PLACEHOLDER)\n```\n\nStatic method since no instance state needed. Simple str.replace is sufficient - no regex overhead required.",
            "status": "pending",
            "testStrategy": "Test `$${VAR}` -> placeholder, multiple escapes, mixed escaped/unescaped, empty string",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement _restore_literals() static method",
            "description": "Create method to convert placeholders back to literal ${VAR} after substitution completes",
            "dependencies": [
              1
            ],
            "details": "Add to ConfigurationLoader class:\n\n```python\n@staticmethod\ndef _restore_literals(content: str) -> str:\n    \"\"\"Restore escaped sequences to literal ${VAR} syntax.\"\"\"\n    return content.replace(_ESCAPE_PLACEHOLDER, '${')\n```\n\nNote: restores to `${` not `$${` - the escape prefix is consumed, user gets literal `${VAR}` in output.",
            "status": "pending",
            "testStrategy": "Test placeholder -> `${`, verify `$${VAR}` input produces `${VAR}` output after escape/restore cycle",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create test_loader_escape.py with escape/restore tests",
            "description": "Add comprehensive unit tests for escape syntax following project test conventions",
            "dependencies": [
              2,
              3
            ],
            "details": "Create tests/configuration/test_loader_escape.py:\n\n```python\nfrom buvis.pybase.configuration.loader import ConfigurationLoader, _ESCAPE_PLACEHOLDER\n\nclass TestEscapeLiterals:\n    def test_escape_single(self) -> None:\n        result = ConfigurationLoader._escape_literals('$${VAR}')\n        assert result == f'{_ESCAPE_PLACEHOLDER}VAR}}'\n    \n    def test_escape_preserves_unescaped(self) -> None:\n        result = ConfigurationLoader._escape_literals('${VAR}')\n        assert result == '${VAR}'\n\nclass TestRestoreLiterals:\n    def test_restore_produces_literal(self) -> None:\n        escaped = ConfigurationLoader._escape_literals('$${VAR}')\n        result = ConfigurationLoader._restore_literals(escaped)\n        assert result == '${VAR}'\n```\n\nFollow class-based test organization per test_shell_adapter.py patterns.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_loader_escape.py -v` - all tests pass",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add edge case tests and docstring examples",
            "description": "Test edge cases: nested escapes, empty strings, no escapes present, consecutive escapes",
            "dependencies": [
              4
            ],
            "details": "Extend test_loader_escape.py with edge cases:\n\n```python\nclass TestEscapeEdgeCases:\n    def test_empty_string(self) -> None:\n        assert ConfigurationLoader._escape_literals('') == ''\n    \n    def test_consecutive_escapes(self) -> None:\n        # $$$${VAR} should become $$${VAR} (one escape consumed)\n        result = ConfigurationLoader._escape_literals('$$$${VAR}')\n        restored = ConfigurationLoader._restore_literals(result)\n        assert restored == '$${VAR}'\n    \n    def test_no_escapes_passthrough(self) -> None:\n        text = 'regular ${VAR} text'\n        assert ConfigurationLoader._escape_literals(text) == text\n```\n\nAdd docstring usage example showing workflow: escape -> substitute -> restore.",
            "status": "pending",
            "testStrategy": "All edge case tests pass. Docstrings render correctly in `python -c \"from buvis.pybase.configuration.loader import ConfigurationLoader; help(ConfigurationLoader._escape_literals)\"`",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:20:59.614Z"
      },
      {
        "id": "23",
        "title": "Implement env var substitution logic",
        "description": "Create _substitute method that replaces ${VAR} with env values and tracks missing required vars",
        "details": "Implement substitution with the regex from PRD:\n\n```python\ndef _substitute(content: str) -> tuple[str, list[str]]:\n    \"\"\"Substitute env vars, return (result, missing_vars).\"\"\"\n    missing: list[str] = []\n    \n    def replace(match: re.Match) -> str:\n        var_name, default = match.group(1), match.group(2)\n        value = os.environ.get(var_name)\n        if value is None:\n            if default is not None:\n                return default\n            missing.append(var_name)\n            return match.group(0)  # Keep for error msg\n        return value\n    \n    result = _ENV_PATTERN.sub(replace, content)\n    return result, missing\n```\n\nNo recursive substitution - single pass only (security). Values from env vars are NOT re-processed.",
        "testStrategy": "Test cases: (1) ${VAR} set -> substituted, (2) ${VAR} unset -> tracked in missing, (3) ${VAR:-default} unset -> uses default, (4) Nested ${} in env value NOT expanded",
        "priority": "high",
        "dependencies": [
          "21",
          "22"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add _substitute function signature with type hints and docstring",
            "description": "Create the _substitute function in loader.py with proper type annotations and Google-style docstring",
            "dependencies": [],
            "details": "Add to src/buvis/pybase/configuration/loader.py after the _ESCAPE_PLACEHOLDER constants:\n\n```python\ndef _substitute(content: str) -> tuple[str, list[str]]:\n    \"\"\"Substitute env vars in content string.\n    \n    Replaces ${VAR} patterns with environment values. Supports\n    ${VAR:-default} syntax for fallback values.\n    \n    Args:\n        content: String with potential ${VAR} patterns.\n        \n    Returns:\n        Tuple of (substituted_content, missing_vars) where missing_vars\n        contains names of required env vars that weren't set.\n        \n    Note:\n        Single-pass only - values from env are NOT re-processed.\n    \"\"\"\n```\n\nFollow existing codebase pattern: `from __future__ import annotations` at top, use `tuple[str, list[str]]` not `Tuple`.",
            "status": "pending",
            "testStrategy": "Verify function exists with `from buvis.pybase.configuration.loader import _substitute` and inspect signature matches spec",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement replace inner function and match group handling",
            "description": "Create the nested replace callback that extracts var_name and default from regex match groups",
            "dependencies": [
              1
            ],
            "details": "Inside _substitute, add the replace callback:\n\n```python\ndef _substitute(content: str) -> tuple[str, list[str]]:\n    # ... docstring ...\n    missing: list[str] = []\n    \n    def replace(match: re.Match) -> str:\n        var_name = match.group(1)  # The variable name (e.g., 'DB_HOST')\n        default = match.group(2)   # The default value or None\n        value = os.environ.get(var_name)\n        \n        if value is not None:\n            return value\n        if default is not None:\n            return default\n        missing.append(var_name)\n        return match.group(0)  # Keep original for error message\n    \n    # ... substitution call ...\n```\n\nKey: `match.group(2)` is None when no `:-default` specified, not empty string.",
            "status": "pending",
            "testStrategy": "Unit test replace callback isolation is not needed - tested via _substitute integration tests",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Complete substitution with _ENV_PATTERN.sub and return",
            "description": "Wire up regex substitution using _ENV_PATTERN.sub and return the result tuple",
            "dependencies": [
              2
            ],
            "details": "Complete the _substitute function body:\n\n```python\ndef _substitute(content: str) -> tuple[str, list[str]]:\n    \"\"\"...\"\"\"\n    missing: list[str] = []\n    \n    def replace(match: re.Match) -> str:\n        var_name, default = match.group(1), match.group(2)\n        value = os.environ.get(var_name)\n        if value is not None:\n            return value\n        if default is not None:\n            return default\n        missing.append(var_name)\n        return match.group(0)\n    \n    result = _ENV_PATTERN.sub(replace, content)\n    return result, missing\n```\n\nSecurity note: Single pass - the `result` is NOT re-processed through _ENV_PATTERN. This prevents injection if env var contains `${...}`.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_loader.py -v` to verify integration",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create test file with fixtures for env var substitution",
            "description": "Set up tests/configuration/test_loader.py with pytest fixtures for isolated env var testing",
            "dependencies": [
              3
            ],
            "details": "Create tests/configuration/test_loader.py:\n\n```python\nfrom __future__ import annotations\n\nimport os\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom buvis.pybase.configuration.loader import _substitute\n\n\nclass TestSubstitute:\n    \"\"\"Test _substitute env var replacement.\"\"\"\n    \n    def test_var_set_substituted(self) -> None:\n        \"\"\"${VAR} with VAR set -> value substituted.\"\"\"\n        with patch.dict(os.environ, {\"DB_HOST\": \"localhost\"}):\n            result, missing = _substitute(\"host: ${DB_HOST}\")\n        assert result == \"host: localhost\"\n        assert missing == []\n```\n\nUse `patch.dict(os.environ, ...)` for isolated env manipulation. Follow existing test patterns from test_shell_adapter.py.",
            "status": "pending",
            "testStrategy": "Verify test file created and basic test passes with `uv run pytest tests/configuration/test_loader.py::TestSubstitute::test_var_set_substituted -v`",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement all test cases from test strategy",
            "description": "Add remaining test cases: unset var tracking, default fallback, and no recursive substitution",
            "dependencies": [
              4
            ],
            "details": "Add to TestSubstitute class:\n\n```python\ndef test_var_unset_tracked_in_missing(self) -> None:\n    \"\"\"${VAR} with VAR unset -> tracked in missing list.\"\"\"\n    with patch.dict(os.environ, {}, clear=True):\n        os.environ.pop(\"UNSET_VAR\", None)\n        result, missing = _substitute(\"key: ${UNSET_VAR}\")\n    assert result == \"key: ${UNSET_VAR}\"  # Kept for error msg\n    assert missing == [\"UNSET_VAR\"]\n\ndef test_var_unset_uses_default(self) -> None:\n    \"\"\"${VAR:-default} with VAR unset -> uses default.\"\"\"\n    with patch.dict(os.environ, {}, clear=True):\n        os.environ.pop(\"DB_PORT\", None)\n        result, missing = _substitute(\"port: ${DB_PORT:-5432}\")\n    assert result == \"port: 5432\"\n    assert missing == []\n\ndef test_nested_not_expanded(self) -> None:\n    \"\"\"Env value containing ${} is NOT re-processed.\"\"\"\n    with patch.dict(os.environ, {\"VAR\": \"${NESTED}\"}):\n        result, missing = _substitute(\"val: ${VAR}\")\n    assert result == \"val: ${NESTED}\"  # Literal, not expanded\n    assert missing == []\n```\n\nRun full test suite: `uv run pytest tests/configuration/test_loader.py -v`",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_loader.py -v` - all 4 test cases must pass",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:57:38.179Z"
      },
      {
        "id": "24",
        "title": "Implement load_yaml static method",
        "description": "Main entry point: read file, escape literals, substitute, restore literals, parse YAML",
        "details": "```python\n@staticmethod\ndef load_yaml(file_path: Path) -> dict[str, Any]:\n    \"\"\"Load YAML with env substitution. Raises on missing required vars.\"\"\"\n    content = file_path.read_text(encoding=\"utf-8\")\n    \n    # Escape $${VAR} -> placeholder\n    content = _escape_literals(content)\n    \n    # Substitute ${VAR} and ${VAR:-default}\n    content, missing = _substitute(content)\n    \n    # Restore placeholders -> ${VAR}\n    content = _restore_literals(content)\n    \n    if missing:\n        raise ValueError(f\"Missing required env vars: {', '.join(missing)}\")\n    \n    return yaml.safe_load(content) or {}\n```\n\nUse `safe_load` ONLY - never yaml.load(). Return `{}` for empty files (safe_load returns None).",
        "testStrategy": "Test: valid YAML loads, empty file returns {}, missing var raises ValueError with var name in message",
        "priority": "high",
        "dependencies": [
          "22",
          "23"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add load_yaml static method signature with type hints",
            "description": "Create the load_yaml static method skeleton in ConfigurationLoader class with proper type annotations and Google-style docstring.",
            "dependencies": [],
            "details": "Add to src/buvis/pybase/configuration/loader.py:\n\n```python\nfrom pathlib import Path\nfrom typing import Any\n\n@staticmethod\ndef load_yaml(file_path: Path) -> dict[str, Any]:\n    \"\"\"Load YAML file with environment variable substitution.\n    \n    Supports ${VAR} for required vars (raises on missing) and\n    ${VAR:-default} for optional vars with defaults. Use $${VAR}\n    to escape and get literal ${VAR} in output.\n    \n    Args:\n        file_path: Path to YAML file to load.\n        \n    Returns:\n        Parsed YAML content as dict. Empty files return {}.\n        \n    Raises:\n        ValueError: If required environment variables are missing.\n        FileNotFoundError: If file doesn't exist.\n    \"\"\"\n    pass  # Implementation follows\n```\n\nFollows existing codebase pattern for static methods (no instance state needed).",
            "status": "pending",
            "testStrategy": "Verify method exists: `from buvis.pybase.configuration.loader import ConfigurationLoader; ConfigurationLoader.load_yaml`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement file reading with UTF-8 encoding",
            "description": "Read file content as string using Path.read_text() with explicit UTF-8 encoding.",
            "dependencies": [
              1
            ],
            "details": "Replace pass statement with file reading:\n\n```python\ncontent = file_path.read_text(encoding=\"utf-8\")\n```\n\nUsing `read_text()` instead of `open()` context manager follows modern Python idioms and is more concise. Explicit encoding=\"utf-8\" ensures consistent behavior across platforms. FileNotFoundError naturally propagates if file doesn't exist - no need to wrap.",
            "status": "pending",
            "testStrategy": "Test FileNotFoundError raised for missing file. Test UTF-8 content with special chars loads correctly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate escape/substitute/restore processing pipeline",
            "description": "Call _escape_literals, _substitute, and _restore_literals in correct order on file content.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add after file reading:\n\n```python\n# Escape $${VAR} -> placeholder (preserves literal syntax)\ncontent = _escape_literals(content)\n\n# Substitute ${VAR} and ${VAR:-default} with env values\ncontent, missing = _substitute(content)\n\n# Restore placeholders -> ${VAR} (literal output)\ncontent = _restore_literals(content)\n```\n\nOrder is critical: escape first to protect literals, substitute env vars, then restore. The _substitute function returns tuple (processed_content, missing_vars) where missing_vars is a set of required vars that weren't found in env.",
            "status": "pending",
            "testStrategy": "Integration test: $${VAR} stays literal, ${SET_VAR} substituted, ${UNSET:-default} uses default. Verify pipeline order.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add ValueError handling for missing required env vars",
            "description": "Check for missing required variables and raise ValueError with descriptive message listing the var names.",
            "dependencies": [
              3
            ],
            "details": "Add after restore_literals call:\n\n```python\nif missing:\n    raise ValueError(f\"Missing required env vars: {', '.join(sorted(missing))}\")\n```\n\nSort the missing var names for deterministic error messages (important for testing). Use f-string with join for readable output. ValueError is appropriate since it's a configuration value problem, not a type/file error.",
            "status": "pending",
            "testStrategy": "Test ValueError raised with var name in message when ${UNSET_VAR} used. Test multiple missing vars all listed.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Parse content with yaml.safe_load and handle empty files",
            "description": "Parse processed content with yaml.safe_load, returning empty dict for empty/null files.",
            "dependencies": [
              4
            ],
            "details": "Add at end of method:\n\n```python\nreturn yaml.safe_load(content) or {}\n```\n\nCRITICAL: Use safe_load ONLY - never yaml.load() which allows arbitrary code execution. The `or {}` handles the case where safe_load returns None for empty files or files containing only comments/whitespace. This matches existing pattern in configuration.py line 90.",
            "status": "pending",
            "testStrategy": "Test valid YAML parses correctly. Test empty file returns {}. Test file with only comments returns {}. Verify safe_load used (not yaml.load).",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:58:53.960Z"
      },
      {
        "id": "25",
        "title": "Implement deep merge functionality",
        "description": "Create merge_configs static method and _deep_merge helper for nested dict merging",
        "details": "```python\n@staticmethod\ndef merge_configs(*configs: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Deep merge dicts. Later values override earlier.\"\"\"\n    result: dict[str, Any] = {}\n    for cfg in configs:\n        _deep_merge(result, cfg)\n    return result\n\ndef _deep_merge(target: dict, source: dict) -> None:\n    \"\"\"Recursively merge source into target.\"\"\"\n    for k, v in source.items():\n        if k in target and isinstance(target[k], dict) and isinstance(v, dict):\n            _deep_merge(target[k], v)\n        else:\n            target[k] = v\n```\n\nLater configs override earlier. Nested dicts merge recursively; non-dict values replace.",
        "testStrategy": "Test: (1) simple merge, (2) nested overlap merges, (3) non-dict override, (4) empty dict handling",
        "priority": "medium",
        "dependencies": [
          "21"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create _deep_merge module-level helper function",
            "description": "Implement the recursive _deep_merge helper function as a module-level private function in loader.py",
            "dependencies": [],
            "details": "Add to src/buvis/pybase/configuration/loader.py (created by Task 21):\n\n```python\ndef _deep_merge(target: dict, source: dict) -> None:\n    \"\"\"Recursively merge source into target.\"\"\"\n    for k, v in source.items():\n        if k in target and isinstance(target[k], dict) and isinstance(v, dict):\n            _deep_merge(target[k], v)\n        else:\n            target[k] = v\n```\n\nPlace above ConfigurationLoader class. Mutates target in-place for efficiency.",
            "status": "pending",
            "testStrategy": "Tested indirectly via merge_configs tests",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add merge_configs static method to ConfigurationLoader",
            "description": "Implement the merge_configs static method that accepts variadic dict args and returns merged result",
            "dependencies": [
              1
            ],
            "details": "Add to ConfigurationLoader class in loader.py:\n\n```python\nfrom typing import Any\n\n@staticmethod\ndef merge_configs(*configs: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Deep merge dicts. Later values override earlier.\"\"\"\n    result: dict[str, Any] = {}\n    for cfg in configs:\n        _deep_merge(result, cfg)\n    return result\n```\n\nEnsure `Any` import from typing exists. Creates new result dict to avoid mutating inputs.",
            "status": "pending",
            "testStrategy": "Direct unit tests for all merge scenarios",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Write tests for simple and empty dict merging",
            "description": "Create test file and implement tests for basic merge scenarios including empty dicts",
            "dependencies": [
              2
            ],
            "details": "Create tests/configuration/test_loader.py:\n\n```python\nimport pytest\nfrom buvis.pybase.configuration.loader import ConfigurationLoader\n\nclass TestMergeConfigs:\n    def test_merge_single_dict(self):\n        result = ConfigurationLoader.merge_configs({\"a\": 1})\n        assert result == {\"a\": 1}\n\n    def test_merge_two_simple_dicts(self):\n        result = ConfigurationLoader.merge_configs({\"a\": 1}, {\"b\": 2})\n        assert result == {\"a\": 1, \"b\": 2}\n\n    def test_merge_empty_dict(self):\n        result = ConfigurationLoader.merge_configs({}, {\"a\": 1})\n        assert result == {\"a\": 1}\n\n    def test_merge_no_args(self):\n        result = ConfigurationLoader.merge_configs()\n        assert result == {}\n```",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Write tests for nested dict merging",
            "description": "Add tests verifying recursive merge behavior for nested dictionaries",
            "dependencies": [
              3
            ],
            "details": "Add to TestMergeConfigs class:\n\n```python\n    def test_nested_merge(self):\n        base = {\"db\": {\"host\": \"localhost\", \"port\": 5432}}\n        override = {\"db\": {\"port\": 3306}}\n        result = ConfigurationLoader.merge_configs(base, override)\n        assert result == {\"db\": {\"host\": \"localhost\", \"port\": 3306}}\n\n    def test_deeply_nested_merge(self):\n        base = {\"a\": {\"b\": {\"c\": 1, \"d\": 2}}}\n        override = {\"a\": {\"b\": {\"c\": 99}}}\n        result = ConfigurationLoader.merge_configs(base, override)\n        assert result == {\"a\": {\"b\": {\"c\": 99, \"d\": 2}}}\n\n    def test_three_way_nested_merge(self):\n        a = {\"x\": {\"y\": 1}}\n        b = {\"x\": {\"z\": 2}}\n        c = {\"x\": {\"y\": 3}}\n        result = ConfigurationLoader.merge_configs(a, b, c)\n        assert result == {\"x\": {\"y\": 3, \"z\": 2}}\n```",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Write tests for non-dict override behavior",
            "description": "Add tests verifying that non-dict values replace rather than merge",
            "dependencies": [
              3
            ],
            "details": "Add to TestMergeConfigs class:\n\n```python\n    def test_non_dict_replaces_dict(self):\n        base = {\"key\": {\"nested\": \"value\"}}\n        override = {\"key\": \"string\"}\n        result = ConfigurationLoader.merge_configs(base, override)\n        assert result == {\"key\": \"string\"}\n\n    def test_dict_replaces_non_dict(self):\n        base = {\"key\": \"string\"}\n        override = {\"key\": {\"nested\": \"value\"}}\n        result = ConfigurationLoader.merge_configs(base, override)\n        assert result == {\"key\": {\"nested\": \"value\"}}\n\n    def test_list_replaces_list(self):\n        base = {\"items\": [1, 2]}\n        override = {\"items\": [3, 4, 5]}\n        result = ConfigurationLoader.merge_configs(base, override)\n        assert result == {\"items\": [3, 4, 5]}\n\n    def test_none_replaces_value(self):\n        base = {\"key\": \"value\"}\n        override = {\"key\": None}\n        result = ConfigurationLoader.merge_configs(base, override)\n        assert result == {\"key\": None}\n```",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:16:39.055Z"
      },
      {
        "id": "26",
        "title": "Add custom exception for missing env vars",
        "description": "Create MissingEnvVarError in exceptions.py for clearer error handling",
        "details": "Add to `src/buvis/pybase/configuration/exceptions.py`:\n\n```python\nclass MissingEnvVarError(Exception):\n    \"\"\"Required env var not set.\"\"\"\n\n    def __init__(self, var_names: list[str]) -> None:\n        self.var_names = var_names\n        msg = f\"Missing required env vars: {', '.join(var_names)}\"\n        super().__init__(msg)\n```\n\nUpdate load_yaml to raise this instead of ValueError. Export from `__init__.py`.",
        "testStrategy": "Test: exception contains var names, message formatted correctly, can catch by type",
        "priority": "medium",
        "dependencies": [
          "21"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add MissingEnvVarError class to exceptions.py",
            "description": "Create the MissingEnvVarError exception class in the existing exceptions.py module following the established pattern",
            "dependencies": [],
            "details": "Add to `src/buvis/pybase/configuration/exceptions.py` after the existing `ConfigurationKeyNotFoundError`:\n\n```python\nclass MissingEnvVarError(Exception):\n    \"\"\"Required env var not set.\"\"\"\n\n    def __init__(self, var_names: list[str]) -> None:\n        self.var_names = var_names\n        msg = f\"Missing required env vars: {', '.join(var_names)}\"\n        super().__init__(msg)\n```\n\nNote: Use modern type hint style `list[str]` not `List[str]`, consistent with codebase conventions. The class stores var_names as instance attribute for programmatic access.",
            "status": "pending",
            "testStrategy": "Run `python -c \"from buvis.pybase.configuration.exceptions import MissingEnvVarError; e = MissingEnvVarError(['FOO']); print(e.var_names, str(e))\"`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Export MissingEnvVarError from configuration __init__.py",
            "description": "Update configuration module's __init__.py to export the new exception class",
            "dependencies": [
              1
            ],
            "details": "Modify `src/buvis/pybase/configuration/__init__.py`:\n\n1. Update the import line to include the new exception:\n```python\nfrom .configuration import Configuration, ConfigurationKeyNotFoundError, cfg\nfrom .exceptions import MissingEnvVarError\n```\n\n2. Add to `__all__`:\n```python\n__all__ = [\"Configuration\", \"ConfigurationKeyNotFoundError\", \"MissingEnvVarError\", \"cfg\"]\n```\n\nAlternatively, keep single import from configuration.py if it re-exports, or import directly from exceptions.py as shown.",
            "status": "pending",
            "testStrategy": "Verify export: `from buvis.pybase.configuration import MissingEnvVarError`",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create tests/configuration directory structure",
            "description": "Create the test directory and __init__.py for configuration module tests",
            "dependencies": [],
            "details": "Create directory structure:\n- `tests/configuration/` directory\n- `tests/configuration/__init__.py` (empty file)\n\nThis mirrors the `tests/adapters/` pattern already in the codebase. The empty __init__.py ensures pytest can discover tests in this directory.",
            "status": "pending",
            "testStrategy": "Verify directory exists and pytest discovers it: `uv run pytest tests/configuration/ --collect-only`",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add unit tests for MissingEnvVarError exception",
            "description": "Create comprehensive tests for MissingEnvVarError covering all specified test cases",
            "dependencies": [
              1,
              3
            ],
            "details": "Create `tests/configuration/test_exceptions.py`:\n\n```python\nimport pytest\n\nfrom buvis.pybase.configuration.exceptions import MissingEnvVarError\n\n\nclass TestMissingEnvVarError:\n    \"\"\"Test MissingEnvVarError exception.\"\"\"\n\n    def test_stores_var_names(self) -> None:\n        \"\"\"Exception stores var_names attribute.\"\"\"\n        err = MissingEnvVarError([\"FOO\", \"BAR\"])\n        assert err.var_names == [\"FOO\", \"BAR\"]\n\n    def test_message_format_single(self) -> None:\n        \"\"\"Message formatted correctly for single var.\"\"\"\n        err = MissingEnvVarError([\"DB_PASSWORD\"])\n        assert str(err) == \"Missing required env vars: DB_PASSWORD\"\n\n    def test_message_format_multiple(self) -> None:\n        \"\"\"Message formatted correctly for multiple vars.\"\"\"\n        err = MissingEnvVarError([\"FOO\", \"BAR\", \"BAZ\"])\n        assert str(err) == \"Missing required env vars: FOO, BAR, BAZ\"\n\n    def test_catchable_by_type(self) -> None:\n        \"\"\"Exception can be caught by type.\"\"\"\n        with pytest.raises(MissingEnvVarError) as exc_info:\n            raise MissingEnvVarError([\"SECRET\"])\n        assert exc_info.value.var_names == [\"SECRET\"]\n\n    def test_is_exception_subclass(self) -> None:\n        \"\"\"MissingEnvVarError is Exception subclass.\"\"\"\n        assert issubclass(MissingEnvVarError, Exception)\n```\n\nFollows existing test patterns: class-based organization, type hints on methods, docstrings.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_exceptions.py -v` and verify all 5 tests pass",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify exception integration point for ConfigurationLoader",
            "description": "Verify exception works correctly and document integration pattern for future load_yaml usage",
            "dependencies": [
              2,
              4
            ],
            "details": "Final verification steps:\n\n1. Run full test suite to ensure no regressions: `uv run pytest`\n\n2. Verify exception is importable from all expected paths:\n   - `from buvis.pybase.configuration import MissingEnvVarError`\n   - `from buvis.pybase.configuration.exceptions import MissingEnvVarError`\n\n3. Run pre-commit hooks: `uv run pre-commit run --all-files`\n\nNote: The exception is ready for use by ConfigurationLoader.load_yaml (Task 21+22). When load_yaml is implemented, it should replace:\n```python\n# Before: raise ValueError(f\"Missing required env vars: {', '.join(missing)}\")\n# After:  raise MissingEnvVarError(missing)\n```\n\nThis enables callers to catch specific exception type and access var_names programmatically.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest && uv run pre-commit run --all-files` - all checks pass",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:19:06.852Z"
      },
      {
        "id": "27",
        "title": "Handle YAML parse errors with line numbers",
        "description": "Ensure yaml.YAMLError propagates with line info for debugging",
        "details": "PyYAML's safe_load already raises `yaml.YAMLError` with line/column info. Ensure this propagates:\n\n```python\n# In load_yaml, after substitution:\ntry:\n    return yaml.safe_load(content) or {}\nexcept yaml.YAMLError:\n    # Re-raise as-is; contains line number info\n    raise\n```\n\nNo wrapping needed - just ensure we don't catch and hide it. The YAMLError.problem_mark attribute has line/column.",
        "testStrategy": "Test: invalid YAML raises yaml.YAMLError, verify problem_mark contains line number",
        "priority": "medium",
        "dependencies": [
          "24"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add explicit try/except for yaml.safe_load in load_yaml",
            "description": "Wrap yaml.safe_load call with try/except that re-raises yaml.YAMLError unchanged to ensure line info propagates",
            "dependencies": [],
            "details": "In ConfigurationLoader.load_yaml (created by task 24), wrap the yaml.safe_load call:\n\n```python\ntry:\n    return yaml.safe_load(content) or {}\nexcept yaml.YAMLError:\n    # Re-raise as-is; contains line number info in problem_mark\n    raise\n```\n\nThis explicit pattern documents intent and prevents future refactoring from accidentally catching/wrapping the error.",
            "status": "pending",
            "testStrategy": "Verify yaml.YAMLError raised for malformed YAML passes through unchanged",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add yaml import and YAMLError type hint to loader module",
            "description": "Ensure yaml module is imported and YAMLError is available for type hints and exception handling",
            "dependencies": [
              1
            ],
            "details": "Verify loader.py has:\n\n```python\nimport yaml\n```\n\nIf documenting raised exceptions in docstring, reference yaml.YAMLError. The exception is already defined in PyYAML, no custom exception needed.",
            "status": "pending",
            "testStrategy": "Import check: `from yaml import YAMLError` works in module",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update load_yaml docstring with YAMLError documentation",
            "description": "Document that load_yaml raises yaml.YAMLError on parse failure, with problem_mark containing line/column info",
            "dependencies": [
              1
            ],
            "details": "Add to load_yaml docstring in Raises section:\n\n```python\n\"\"\"Load YAML with env substitution.\n\nArgs:\n    file_path: Path to YAML file\n\nReturns:\n    dict[str, Any]: Parsed config, empty dict for empty file\n\nRaises:\n    ValueError: Missing required env vars\n    yaml.YAMLError: Invalid YAML syntax. Check error.problem_mark for line/column info.\n\"\"\"\n```",
            "status": "pending",
            "testStrategy": "Docstring includes yaml.YAMLError in Raises section",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create test for invalid YAML raising YAMLError",
            "description": "Add pytest test that verifies malformed YAML raises yaml.YAMLError exception",
            "dependencies": [
              1
            ],
            "details": "In tests/configuration/test_loader.py:\n\n```python\nimport yaml\nimport pytest\n\nclass TestLoadYamlErrors:\n    def test_invalid_yaml_raises_yamlerror(self, tmp_path):\n        invalid_yaml = tmp_path / \"invalid.yaml\"\n        invalid_yaml.write_text(\"key: [unclosed\\n  - list\")\n        \n        with pytest.raises(yaml.YAMLError):\n            ConfigurationLoader.load_yaml(invalid_yaml)\n```",
            "status": "pending",
            "testStrategy": "Run pytest, verify test passes",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create test verifying problem_mark contains line number",
            "description": "Add test that catches yaml.YAMLError and asserts problem_mark.line is set correctly",
            "dependencies": [
              4
            ],
            "details": "Extend test to verify line info:\n\n```python\ndef test_yamlerror_contains_line_number(self, tmp_path):\n    bad_yaml = tmp_path / \"bad.yaml\"\n    bad_yaml.write_text(\"good: value\\nbad: [unclosed\")\n    \n    with pytest.raises(yaml.YAMLError) as exc_info:\n        ConfigurationLoader.load_yaml(bad_yaml)\n    \n    # problem_mark contains line/column of error\n    assert exc_info.value.problem_mark is not None\n    assert exc_info.value.problem_mark.line == 1  # 0-indexed, line 2 in file\n```",
            "status": "pending",
            "testStrategy": "Test verifies problem_mark.line matches expected error location",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:20:17.231Z"
      },
      {
        "id": "28",
        "title": "Update configuration module exports",
        "description": "Export ConfigurationLoader and MissingEnvVarError from configuration/__init__.py",
        "details": "Update `src/buvis/pybase/configuration/__init__.py`:\n\n```python\nfrom .configuration import Configuration, cfg\nfrom .exceptions import ConfigurationKeyNotFoundError, MissingEnvVarError\nfrom .loader import ConfigurationLoader\n\n__all__ = [\n    \"Configuration\",\n    \"ConfigurationKeyNotFoundError\",\n    \"ConfigurationLoader\",\n    \"MissingEnvVarError\",\n    \"cfg\",\n]\n```\n\nFollow existing pattern of explicit `__all__`.",
        "testStrategy": "Test: `from buvis.pybase.configuration import ConfigurationLoader, MissingEnvVarError` works",
        "priority": "medium",
        "dependencies": [
          "24",
          "25",
          "26"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update exception imports to use .exceptions module directly",
            "description": "Change ConfigurationKeyNotFoundError import from .configuration to .exceptions module",
            "dependencies": [],
            "details": "Modify the import statement in `src/buvis/pybase/configuration/__init__.py` to import `ConfigurationKeyNotFoundError` directly from `.exceptions` instead of from `.configuration`. This separates exception imports from class imports and prepares for adding `MissingEnvVarError`.",
            "status": "pending",
            "testStrategy": "Run `python -c \"from buvis.pybase.configuration import ConfigurationKeyNotFoundError\"` to verify import still works",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add MissingEnvVarError to exceptions import",
            "description": "Import MissingEnvVarError from .exceptions module alongside ConfigurationKeyNotFoundError",
            "dependencies": [
              1
            ],
            "details": "Extend the exceptions import line to include `MissingEnvVarError`: `from .exceptions import ConfigurationKeyNotFoundError, MissingEnvVarError`. This requires task 25 to have created the exception class first.",
            "status": "pending",
            "testStrategy": "Run `python -c \"from buvis.pybase.configuration import MissingEnvVarError\"` to verify new import works",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add ConfigurationLoader import from .loader module",
            "description": "Add import statement for ConfigurationLoader from the new .loader module",
            "dependencies": [
              1
            ],
            "details": "Add new import line: `from .loader import ConfigurationLoader`. This requires task 24 to have created the loader module first. Place import after the exceptions import for consistency.",
            "status": "pending",
            "testStrategy": "Run `python -c \"from buvis.pybase.configuration import ConfigurationLoader\"` to verify new import works",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update __all__ list with new exports",
            "description": "Extend __all__ to include ConfigurationLoader and MissingEnvVarError in alphabetical order",
            "dependencies": [
              2,
              3
            ],
            "details": "Update `__all__` to: `[\"Configuration\", \"ConfigurationKeyNotFoundError\", \"ConfigurationLoader\", \"MissingEnvVarError\", \"cfg\"]`. Keep alphabetical order per project convention seen in adapters/__init__.py.",
            "status": "pending",
            "testStrategy": "Check `from buvis.pybase.configuration import *` exports all 5 symbols. Verify `__all__` has exactly 5 items.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify all configuration module exports work correctly",
            "description": "Run comprehensive import test and pre-commit checks to validate module exports",
            "dependencies": [
              4
            ],
            "details": "Run `python -c \"from buvis.pybase.configuration import Configuration, ConfigurationKeyNotFoundError, ConfigurationLoader, MissingEnvVarError, cfg; print('All imports OK')\"`. Then run `uv run pytest` and `uv run pre-commit run --all-files` to ensure no regressions.",
            "status": "pending",
            "testStrategy": "All import statements succeed. pytest passes. pre-commit (ruff check/format) passes.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "29",
        "title": "Write comprehensive unit tests",
        "description": "Create test_loader.py with full coverage of substitution, merge, and edge cases",
        "details": "Create `tests/configuration/test_loader.py` following existing test patterns:\n\n```python\nimport os\nfrom pathlib import Path\nfrom unittest.mock import patch\n\nimport pytest\nimport yaml\n\nfrom buvis.pybase.configuration import ConfigurationLoader, MissingEnvVarError\n\n\n@pytest.fixture\ndef tmp_yaml(tmp_path):\n    def _create(content: str) -> Path:\n        p = tmp_path / \"config.yaml\"\n        p.write_text(content)\n        return p\n    return _create\n\n\nclass TestLoadYamlSubstitution:\n    def test_var_set_substituted(self, tmp_yaml): ...\n    def test_var_unset_raises(self, tmp_yaml): ...\n    def test_var_with_default(self, tmp_yaml): ...\n    def test_escaped_literal(self, tmp_yaml): ...\n    def test_no_recursive_substitution(self, tmp_yaml): ...\n\nclass TestLoadYamlEdgeCases:\n    def test_empty_file(self, tmp_yaml): ...\n    def test_invalid_yaml(self, tmp_yaml): ...\n\nclass TestMergeConfigs:\n    def test_simple_merge(self): ...\n    def test_nested_overlap(self): ...\n    def test_override_non_dict(self): ...\n```",
        "testStrategy": "Run `uv run pytest tests/configuration/test_loader.py -v`. Verify all PRD test cases pass.",
        "priority": "high",
        "dependencies": [
          "24",
          "25",
          "26",
          "27"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test_loader.py with fixtures and imports",
            "description": "Set up tests/configuration/test_loader.py with proper imports, fixtures for temp YAML files, and class scaffolds",
            "dependencies": [],
            "details": "Create `tests/configuration/test_loader.py` with:\n- Standard imports: `os`, `Path`, `patch` from unittest.mock, `pytest`, `yaml`\n- Import from buvis.pybase.configuration: `ConfigurationLoader`, `MissingEnvVarError`\n- `tmp_yaml` fixture using `tmp_path` that returns a factory function for creating temp YAML files\n- Empty class scaffolds: `TestLoadYamlSubstitution`, `TestLoadYamlEdgeCases`, `TestMergeConfigs`\nFollow patterns from test_shell_adapter.py: class-based organization, type hints on fixtures.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_loader.py --collect-only` and verify 3 test classes discovered",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement TestLoadYamlSubstitution test methods",
            "description": "Add test methods for env var substitution: var set, unset raises, default syntax, escaped literals, no recursion",
            "dependencies": [
              1
            ],
            "details": "Add to TestLoadYamlSubstitution class:\n- `test_var_set_substituted`: patch env with TEST_VAR=value, load yaml containing ${TEST_VAR}, assert value substituted\n- `test_var_unset_raises`: load yaml with ${UNSET_VAR}, assert raises MissingEnvVarError, check var_names contains 'UNSET_VAR'\n- `test_var_with_default`: load yaml with ${VAR:-default}, assert default used when VAR unset\n- `test_escaped_literal`: load yaml with $${ESCAPED}, assert output contains literal ${ESCAPED}\n- `test_no_recursive_substitution`: set VAR1=${VAR2}, VAR2=value; load ${VAR1}; assert result is '${VAR2}' not 'value'",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_loader.py::TestLoadYamlSubstitution -v` and verify all 5 tests pass",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement TestLoadYamlEdgeCases test methods",
            "description": "Add test methods for edge cases: empty file returns empty dict, invalid YAML raises yaml.YAMLError with line info",
            "dependencies": [
              1
            ],
            "details": "Add to TestLoadYamlEdgeCases class:\n- `test_empty_file`: create empty yaml file, call load_yaml, assert returns {} (empty dict)\n- `test_invalid_yaml`: create file with malformed YAML (e.g. 'key: [unclosed'), call load_yaml, assert raises yaml.YAMLError, verify problem_mark attribute exists with line number\nVerify error propagation preserves line numbers for debugging per PRD requirements.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_loader.py::TestLoadYamlEdgeCases -v` and verify both tests pass",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement TestMergeConfigs test methods",
            "description": "Add test methods for deep merge: simple merge, nested overlap, non-dict override",
            "dependencies": [
              1
            ],
            "details": "Add to TestMergeConfigs class:\n- `test_simple_merge`: merge {a:1} and {b:2}, assert result is {a:1, b:2}\n- `test_nested_overlap`: merge {x:{a:1}} and {x:{b:2}}, assert result is {x:{a:1, b:2}} (deep merge)\n- `test_override_non_dict`: merge {x:{a:1}} and {x:5}, assert result is {x:5} (later value wins when types differ)\nNo fixtures needed - test pure function behavior with dict literals.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_loader.py::TestMergeConfigs -v` and verify all 3 tests pass",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run full test suite and verify coverage",
            "description": "Execute all tests in test_loader.py, verify passing status, run pre-commit checks",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Execute verification:\n1. Run `uv run pytest tests/configuration/test_loader.py -v` - all 10 tests must pass\n2. Run `uv run pre-commit run --all-files` - verify code style compliance\n3. Verify test file imports work correctly from buvis.pybase.configuration\n4. Confirm MissingEnvVarError exception tests properly check var_names attribute\n5. Verify yaml.YAMLError tests confirm problem_mark contains line info",
            "status": "pending",
            "testStrategy": "All 10 tests pass. pre-commit passes. Test file follows project conventions from test_shell_adapter.py",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:21:38.522Z"
      },
      {
        "id": "30",
        "title": "Integrate loader with existing Configuration class",
        "description": "Optionally use ConfigurationLoader in Configuration._load_configuration for env var support",
        "details": "Update `Configuration._load_configuration` to use the new loader:\n\n```python\ndef _load_configuration(self) -> None:\n    \"\"\"Load config from YAML file with env substitution.\"\"\"\n    self._config_dict = ConfigurationLoader.load_yaml(self.path_config_file)\n```\n\nThis enables env var substitution in the existing singleton `cfg`. Consider: this may be a breaking change if users have literal `${` in configs. Could add opt-in flag if needed.\n\nAlternative: keep Configuration unchanged, offer ConfigurationLoader as separate utility. Document both approaches.",
        "testStrategy": "Test: existing Configuration tests still pass. New test: cfg loads YAML with ${VAR} substituted when env set.",
        "priority": "low",
        "dependencies": [
          "24",
          "28",
          "29"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add enable_env_substitution parameter to Configuration.__init__",
            "description": "Add opt-in boolean parameter to Configuration constructor to enable env var substitution, defaulting to False for backward compatibility",
            "dependencies": [],
            "details": "Modify `Configuration.__init__` signature to accept `enable_env_substitution: bool = False`. Store as instance attribute `self._enable_env_substitution`. This ensures existing users don't experience breaking changes if they have literal `${` in configs. Update docstring to document the new parameter and its effect.",
            "status": "pending",
            "testStrategy": "Test Configuration() with default (False) and explicit True/False values. Verify attribute stored correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update _load_configuration to conditionally use ConfigurationLoader",
            "description": "Modify _load_configuration method to use ConfigurationLoader.load_yaml when env substitution is enabled",
            "dependencies": [
              1
            ],
            "details": "Update `_load_configuration` at line 85-90 to check `self._enable_env_substitution`. When True: `self._config_dict = ConfigurationLoader.load_yaml(self.path_config_file)`. When False: keep existing `yaml.safe_load()` behavior. Add import for ConfigurationLoader at top of file. Maintain hostname override after load.",
            "status": "pending",
            "testStrategy": "Test with enable_env_substitution=True: verify ${VAR} in YAML gets substituted when env var set. Test with False: verify ${VAR} remains literal.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Preserve hostname in _config_dict after loading",
            "description": "Ensure hostname set in __init__ is preserved or restored after _load_configuration runs",
            "dependencies": [
              2
            ],
            "details": "Currently hostname is set before _load_configuration (line 30), but _load_configuration overwrites entire _config_dict. Move hostname assignment after _load_configuration call, or merge instead of replace. Use `self._config_dict['hostname'] = platform.node()` after load. This bug exists in current code but becomes more visible with integration.",
            "status": "pending",
            "testStrategy": "Test that cfg._config_dict['hostname'] equals platform.node() after loading config file with and without hostname key.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Export ConfigurationLoader from configuration __init__.py",
            "description": "Update configuration package exports to include ConfigurationLoader for direct access",
            "dependencies": [
              2
            ],
            "details": "Add `from .loader import ConfigurationLoader` to `src/buvis/pybase/configuration/__init__.py`. Append 'ConfigurationLoader' to `__all__` list. This allows users to do `from buvis.pybase.configuration import ConfigurationLoader` for standalone use without the Configuration class.",
            "status": "pending",
            "testStrategy": "Verify `from buvis.pybase.configuration import ConfigurationLoader` works. Test ConfigurationLoader in __all__.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add integration tests for Configuration with env substitution",
            "description": "Create comprehensive tests verifying env var substitution works through Configuration class",
            "dependencies": [
              3,
              4
            ],
            "details": "Create `tests/configuration/test_configuration.py`. Test cases: (1) default behavior unchanged - ${VAR} remains literal, (2) enable_env_substitution=True substitutes ${VAR}, (3) ${VAR:-default} uses default when VAR unset, (4) existing cfg singleton tests still pass, (5) copy() method works with substituted values. Use tmp_path fixture for test YAML files, monkeypatch for env vars.",
            "status": "pending",
            "testStrategy": "Run full test suite. Verify both old behavior (literal ${) and new behavior (substitution) work correctly based on flag.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "31",
        "title": "Create BuvisSettings base class",
        "description": "Create BuvisSettings BaseSettings class that enforces BUVIS_ prefix and case-insensitive env var loading.",
        "details": "Create `src/buvis/pybase/configuration/buvis_settings.py`:\n\n```python\nfrom __future__ import annotations\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass BuvisSettings(BaseSettings):\n    \"\"\"Base class for all BUVIS tool settings.\n    \n    Enforces naming convention:\n    - BUVIS_ prefix for all env vars\n    - Case insensitive (accepts BUVIS_DEBUG and buvis_debug)\n    - Immutable after creation\n    \"\"\"\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_\",\n        case_sensitive=False,\n        frozen=True,\n        extra=\"forbid\",\n    )\n```\n\nThis base class provides the shared config for global settings. Tool-specific settings will inherit and override env_prefix (e.g., BUVIS_PAYROLL_).",
        "testStrategy": "Test: BuvisSettings loads BUVIS_DEBUG=true. Test: buvis_debug=true (lowercase) also works. Test: DEBUG=true (no prefix) is ignored.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add pydantic-settings dependency to pyproject.toml",
            "description": "Add pydantic-settings package as a project dependency in pyproject.toml. This provides the BaseSettings and SettingsConfigDict classes needed for env var loading.",
            "dependencies": [],
            "details": "Add `pydantic-settings>=2.0.0,<3` to the dependencies list in pyproject.toml. Run `uv sync --all-groups` to install. Verify import works with `uv run python -c 'from pydantic_settings import BaseSettings'`.",
            "status": "done",
            "testStrategy": "Run `uv sync --all-groups` and verify `uv run python -c 'from pydantic_settings import BaseSettings, SettingsConfigDict'` succeeds without error.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:45:01.198Z"
          },
          {
            "id": 2,
            "title": "Create buvis_settings.py with BuvisSettings base class",
            "description": "Create src/buvis/pybase/configuration/buvis_settings.py with the BuvisSettings class that extends BaseSettings with BUVIS_ prefix config.",
            "dependencies": [
              1
            ],
            "details": "Create file with: `from __future__ import annotations`, import BaseSettings/SettingsConfigDict from pydantic_settings, define BuvisSettings class with model_config = SettingsConfigDict(env_prefix='BUVIS_', case_sensitive=False, frozen=True, extra='forbid'). Include Google-style docstring explaining the naming convention.",
            "status": "done",
            "testStrategy": "Verify file exists and class can be imported: `uv run python -c 'from buvis.pybase.configuration.buvis_settings import BuvisSettings'`.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:47:18.800Z"
          },
          {
            "id": 3,
            "title": "Add debug and log_level fields with Literal validation",
            "description": "Add debug: bool = False and log_level: Literal field with valid log levels to BuvisSettings class per PRD requirements.",
            "dependencies": [
              2
            ],
            "details": "Import Literal from typing. Add fields: `debug: bool = False` and `log_level: Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'] = 'INFO'`. These map to BUVIS_DEBUG and BUVIS_LOG_LEVEL env vars. Add field descriptions in docstring.",
            "status": "done",
            "testStrategy": "Test: BuvisSettings().debug == False. Test: BuvisSettings().log_level == 'INFO'. Test with env: BUVIS_DEBUG=true loads as True.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:47:18.843Z"
          },
          {
            "id": 4,
            "title": "Export BuvisSettings from configuration __init__.py",
            "description": "Add BuvisSettings to the configuration module's public API by updating __init__.py exports.",
            "dependencies": [
              2
            ],
            "details": "Edit src/buvis/pybase/configuration/__init__.py: add `from .buvis_settings import BuvisSettings` and append 'BuvisSettings' to __all__ list. Follow existing export pattern used for Configuration class.",
            "status": "done",
            "testStrategy": "Verify import works: `uv run python -c 'from buvis.pybase.configuration import BuvisSettings'`.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:47:18.885Z"
          },
          {
            "id": 5,
            "title": "Create tests/configuration/test_buvis_settings.py with core tests",
            "description": "Create test file with tests for BUVIS_ prefix loading, case-insensitivity, immutability, and extra field rejection.",
            "dependencies": [
              3
            ],
            "details": "Create tests/configuration/ directory and test_buvis_settings.py. Tests: 1) TestBuvisSettingsDefaults - debug=False, log_level='INFO'. 2) TestBuvisSettingsEnvLoading - BUVIS_DEBUG=true loads correctly, buvis_debug=true (lowercase) works, DEBUG=true (no prefix) ignored. 3) TestBuvisSettingsImmutability - assignment raises ValidationError. 4) TestBuvisSettingsExtraForbid - unknown field raises error. Use @patch.dict(os.environ) for env var tests.",
            "status": "done",
            "testStrategy": "Run `uv run pytest tests/configuration/test_buvis_settings.py -v`. All tests pass covering: defaults, env loading, case-insensitivity, immutability, extra forbid.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:47:18.934Z"
          }
        ],
        "updatedAt": "2026-01-02T17:47:18.934Z"
      },
      {
        "id": "32",
        "title": "Create ToolBuvisSettings factory",
        "description": "Create factory function or base class to generate tool-specific settings with correct BUVIS_{TOOL}_ prefix.",
        "details": "Add to buvis_settings.py:\n\n```python\ndef create_tool_settings_class(\n    tool_name: str,\n    **field_definitions,\n) -> type[BaseSettings]:\n    \"\"\"Factory for tool-specific settings classes.\n    \n    Creates a BaseSettings subclass with:\n    - env_prefix = BUVIS_{TOOL}_\n    - case_sensitive = False\n    - All passed field definitions\n    \n    Example:\n        PayrollSettings = create_tool_settings_class(\n            \"PAYROLL\",\n            batch_size=(int, 1000),\n            database_url=(str, \"\"),\n        )\n    \"\"\"\n    # Validate tool_name: uppercase, no hyphens\n    if not tool_name.isupper() or \"-\" in tool_name:\n        raise ValueError(\n            f\"Tool name must be SCREAMING_SNAKE_CASE, got: {tool_name}\"\n        )\n    \n    config = SettingsConfigDict(\n        env_prefix=f\"BUVIS_{tool_name}_\",\n        case_sensitive=False,\n        frozen=True,\n        extra=\"forbid\",\n    )\n    \n    return type(\n        f\"{tool_name.title().replace('_', '')}Settings\",\n        (BaseSettings,),\n        {\"model_config\": config, **field_definitions},\n    )\n```\n\nAlternatively, provide a simpler pattern in docs showing manual subclassing.",
        "testStrategy": "Test: create_tool_settings_class('PAYROLL', batch_size=(int, 1000)) creates class loading BUVIS_PAYROLL_BATCH_SIZE. Test: tool_name with hyphen raises ValueError.",
        "priority": "high",
        "dependencies": [
          "31"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add validate_tool_name helper function",
            "description": "Create a validation function that checks tool_name is SCREAMING_SNAKE_CASE format (uppercase, underscores allowed, no hyphens).",
            "dependencies": [],
            "details": "Add to buvis_settings.py:\n\n```python\ndef validate_tool_name(tool_name: str) -> None:\n    \"\"\"Validate tool name is SCREAMING_SNAKE_CASE.\n    \n    Raises:\n        ValueError: If tool_name contains hyphens or is not uppercase.\n    \"\"\"\n    if not tool_name.isupper() or \"-\" in tool_name:\n        raise ValueError(\n            f\"Tool name must be SCREAMING_SNAKE_CASE, got: {tool_name}\"\n        )\n```\n\nThis is extracted as a separate helper for reusability and testability.",
            "status": "pending",
            "testStrategy": "Test: validate_tool_name('PAYROLL') passes. Test: validate_tool_name('pay-roll') raises ValueError. Test: validate_tool_name('payroll') raises ValueError.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create create_tool_settings_class function signature",
            "description": "Define the factory function with proper type hints accepting tool_name and **field_definitions kwargs.",
            "dependencies": [
              1
            ],
            "details": "Add function skeleton to buvis_settings.py:\n\n```python\ndef create_tool_settings_class(\n    tool_name: str,\n    **field_definitions: tuple[type, Any],\n) -> type[BaseSettings]:\n    \"\"\"Factory for tool-specific settings classes.\n    \n    Creates a BaseSettings subclass with:\n    - env_prefix = BUVIS_{TOOL}_\n    - case_sensitive = False\n    - All passed field definitions\n    \n    Args:\n        tool_name: Tool identifier in SCREAMING_SNAKE_CASE.\n        **field_definitions: Field name to (type, default) tuples.\n    \n    Returns:\n        A new BaseSettings subclass.\n    \n    Example:\n        PayrollSettings = create_tool_settings_class(\n            \"PAYROLL\",\n            batch_size=(int, 1000),\n        )\n    \"\"\"\n    validate_tool_name(tool_name)\n```\n\nImport `Any` from typing if not present.",
            "status": "pending",
            "testStrategy": "Verify function exists and can be imported: `from buvis.pybase.configuration.buvis_settings import create_tool_settings_class`.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement SettingsConfigDict with BUVIS_{TOOL}_ prefix",
            "description": "Create the model_config SettingsConfigDict with dynamic env_prefix based on tool_name.",
            "dependencies": [
              2
            ],
            "details": "Inside the function, create the config:\n\n```python\n    config = SettingsConfigDict(\n        env_prefix=f\"BUVIS_{tool_name}_\",\n        case_sensitive=False,\n        frozen=True,\n        extra=\"forbid\",\n    )\n```\n\nThis ensures tool-specific env vars like BUVIS_PAYROLL_BATCH_SIZE are loaded correctly.",
            "status": "pending",
            "testStrategy": "Test: Created class has env_prefix='BUVIS_PAYROLL_' when tool_name='PAYROLL'.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement dynamic class creation with type()",
            "description": "Use type() to dynamically create the BaseSettings subclass with model_config and field annotations.",
            "dependencies": [
              3
            ],
            "details": "Complete the function with dynamic class creation:\n\n```python\n    # Build class name: PAYROLL -> PayrollSettings, USER_AUTH -> UserauthSettings\n    class_name = f\"{tool_name.title().replace('_', '')}Settings\"\n    \n    # Convert field_definitions to class attributes\n    # (type, default) -> Field with annotation\n    namespace = {\"model_config\": config}\n    annotations = {}\n    \n    for name, (field_type, default) in field_definitions.items():\n        namespace[name] = default\n        annotations[name] = field_type\n    \n    namespace[\"__annotations__\"] = annotations\n    \n    return type(class_name, (BaseSettings,), namespace)\n```\n\nExport from __init__.py: add create_tool_settings_class to __all__.",
            "status": "pending",
            "testStrategy": "Test: create_tool_settings_class('PAYROLL', batch_size=(int, 1000)) creates class with batch_size field defaulting to 1000.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add comprehensive tests for factory function",
            "description": "Create test class in tests/configuration/test_buvis_settings.py testing factory function with env var loading and validation.",
            "dependencies": [
              4
            ],
            "details": "Add to test file:\n\n```python\nclass TestCreateToolSettingsClass:\n    def test_creates_class_with_correct_prefix(self):\n        Settings = create_tool_settings_class(\"PAYROLL\", batch_size=(int, 1000))\n        assert Settings.model_config[\"env_prefix\"] == \"BUVIS_PAYROLL_\"\n    \n    def test_loads_env_var_with_prefix(self, monkeypatch):\n        monkeypatch.setenv(\"BUVIS_PAYROLL_BATCH_SIZE\", \"500\")\n        Settings = create_tool_settings_class(\"PAYROLL\", batch_size=(int, 1000))\n        settings = Settings()\n        assert settings.batch_size == 500\n    \n    def test_hyphen_in_tool_name_raises(self):\n        with pytest.raises(ValueError, match=\"SCREAMING_SNAKE_CASE\"):\n            create_tool_settings_class(\"PAY-ROLL\", batch_size=(int, 1000))\n    \n    def test_lowercase_tool_name_raises(self):\n        with pytest.raises(ValueError):\n            create_tool_settings_class(\"payroll\", batch_size=(int, 1000))\n    \n    def test_class_name_formatting(self):\n        Settings = create_tool_settings_class(\"USER_AUTH\")\n        assert Settings.__name__ == \"UserauthSettings\"\n```",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_buvis_settings.py -v -k TestCreateToolSettingsClass`. All 5 tests pass.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:24:07.938Z"
      },
      {
        "id": "33",
        "title": "Implement env var name validator",
        "description": "Create utility to validate env var names follow BUVIS naming convention.",
        "details": "Add to buvis_settings.py:\n\n```python\nimport re\n\n_VALID_ENV_PATTERN = re.compile(r'^BUVIS_[A-Z][A-Z0-9_]*$')\n\n\ndef validate_env_var_name(name: str) -> bool:\n    \"\"\"Check if env var name follows BUVIS convention.\n    \n    Rules:\n    - Must start with BUVIS_\n    - SCREAMING_SNAKE_CASE only\n    - No hyphens (env vars don't support them anyway)\n    - At least one char after prefix\n    \n    Returns:\n        True if valid, False otherwise\n    \"\"\"\n    return bool(_VALID_ENV_PATTERN.match(name))\n\n\ndef assert_valid_env_var_name(name: str) -> None:\n    \"\"\"Validate and raise if invalid.\"\"\"\n    if not validate_env_var_name(name):\n        raise ValueError(\n            f\"Invalid env var name '{name}'. \"\n            \"Must match BUVIS_{{TOOL}}_{{FIELD}} in SCREAMING_SNAKE_CASE\"\n        )\n```\n\nUsed for runtime validation and tooling.",
        "testStrategy": "Test valid: BUVIS_DEBUG, BUVIS_PAYROLL_BATCH_SIZE, BUVIS_HCM_API_URL. Test invalid: DEBUG (no prefix), buvis_debug (lowercase), BUVIS-DEBUG (hyphen), BUVIS_ (empty field).",
        "priority": "medium",
        "dependencies": [
          "31"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create buvis_settings.py with regex pattern constant",
            "description": "Create new module file with compiled regex pattern for BUVIS env var naming convention.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/buvis_settings.py` with:\n```python\nfrom __future__ import annotations\n\nimport re\n\n_VALID_ENV_PATTERN = re.compile(r'^BUVIS_[A-Z][A-Z0-9_]*$')\n```\nThe pattern enforces: BUVIS_ prefix, SCREAMING_SNAKE_CASE, at least one char after prefix.",
            "status": "pending",
            "testStrategy": "Pattern is tested indirectly via validate_env_var_name tests",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement validate_env_var_name function",
            "description": "Add boolean validation function that checks if env var name matches BUVIS convention.",
            "dependencies": [
              1
            ],
            "details": "Add to buvis_settings.py:\n```python\ndef validate_env_var_name(name: str) -> bool:\n    \"\"\"Check if env var name follows BUVIS convention.\n    \n    Rules:\n    - Must start with BUVIS_\n    - SCREAMING_SNAKE_CASE only\n    - No hyphens\n    - At least one char after prefix\n    \"\"\"\n    return bool(_VALID_ENV_PATTERN.match(name))\n```",
            "status": "pending",
            "testStrategy": "Test valid: BUVIS_DEBUG, BUVIS_PAYROLL_BATCH_SIZE, BUVIS_HCM_API_URL. Test invalid: DEBUG, buvis_debug, BUVIS-DEBUG, BUVIS_.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement assert_valid_env_var_name function",
            "description": "Add assertion function that raises ValueError for invalid env var names.",
            "dependencies": [
              2
            ],
            "details": "Add to buvis_settings.py:\n```python\ndef assert_valid_env_var_name(name: str) -> None:\n    \"\"\"Validate and raise if invalid.\"\"\"\n    if not validate_env_var_name(name):\n        raise ValueError(\n            f\"Invalid env var name '{name}'. \"\n            \"Must match BUVIS_{{TOOL}}_{{FIELD}} in SCREAMING_SNAKE_CASE\"\n        )\n```",
            "status": "pending",
            "testStrategy": "Test raises ValueError with descriptive message for invalid names. Test no exception for valid names.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Export validator functions in configuration __init__.py",
            "description": "Update configuration package exports to include new validator functions.",
            "dependencies": [
              3
            ],
            "details": "Add to `src/buvis/pybase/configuration/__init__.py`:\n```python\nfrom .buvis_settings import assert_valid_env_var_name, validate_env_var_name\n\n__all__ = [..., \"validate_env_var_name\", \"assert_valid_env_var_name\"]\n```",
            "status": "pending",
            "testStrategy": "Verify imports work: `from buvis.pybase.configuration import validate_env_var_name`",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create test suite for env var validators",
            "description": "Add comprehensive tests covering valid names, invalid names, and edge cases.",
            "dependencies": [
              4
            ],
            "details": "Create `tests/configuration/test_buvis_settings.py`:\n```python\nimport pytest\nfrom buvis.pybase.configuration import validate_env_var_name, assert_valid_env_var_name\n\nclass TestValidateEnvVarName:\n    @pytest.mark.parametrize(\"name\", [\"BUVIS_DEBUG\", \"BUVIS_PAYROLL_BATCH_SIZE\", \"BUVIS_HCM_API_URL\", \"BUVIS_A\"])\n    def test_valid_names(self, name): ...\n    \n    @pytest.mark.parametrize(\"name\", [\"DEBUG\", \"buvis_debug\", \"BUVIS-DEBUG\", \"BUVIS_\", \"\", \"BUVIS_123\"])\n    def test_invalid_names(self, name): ...\n\nclass TestAssertValidEnvVarName:\n    def test_valid_name_no_exception(self): ...\n    def test_invalid_name_raises_valueerror(self): ...\n```",
            "status": "pending",
            "testStrategy": "Run pytest. Verify parametrized tests cover all edge cases from task spec.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:23:27.156Z"
      },
      {
        "id": "34",
        "title": "Add global debug setting",
        "description": "Add debug: bool field to BuvisSettings with BUVIS_DEBUG env var mapping.",
        "details": "Update BuvisSettings:\n\n```python\nclass BuvisSettings(BaseSettings):\n    \"\"\"Global BUVIS settings.\"\"\"\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_\",\n        case_sensitive=False,\n        frozen=True,\n        extra=\"forbid\",\n    )\n    \n    debug: bool = False\n```\n\nWith `env_prefix=\"BUVIS_\"`, the `debug` field maps to `BUVIS_DEBUG` env var. Pydantic handles bool coercion (true/false/1/0/yes/no).",
        "testStrategy": "Test: BUVIS_DEBUG=true -> settings.debug == True. Test: BUVIS_DEBUG=1 -> True. Test: buvis_debug=true (lowercase) -> True. Test: default is False.",
        "priority": "high",
        "dependencies": [
          "31"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add pydantic-settings dependency to pyproject.toml",
            "description": "Add pydantic-settings package as a project dependency to enable BaseSettings functionality for env var-based configuration.",
            "dependencies": [],
            "details": "Update pyproject.toml dependencies array to include 'pydantic-settings>=2.0.0,<3'. Run `uv sync` to install. This provides BaseSettings and SettingsConfigDict needed for BuvisSettings class.",
            "status": "pending",
            "testStrategy": "Verify with `uv run python -c \"from pydantic_settings import BaseSettings\"`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create BuvisSettings class with debug field in settings.py",
            "description": "Create new settings.py file in configuration module with BuvisSettings class containing debug: bool = False field.",
            "dependencies": [
              1
            ],
            "details": "Create `src/buvis/pybase/configuration/settings.py` with:\n```python\nfrom __future__ import annotations\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\nclass BuvisSettings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_\",\n        case_sensitive=False,\n        frozen=True,\n        extra=\"forbid\",\n    )\n    debug: bool = False\n```\nThe env_prefix maps debug to BUVIS_DEBUG. Pydantic handles bool coercion (true/false/1/0/yes/no).",
            "status": "pending",
            "testStrategy": "Manual verification: instantiate BuvisSettings() and check debug defaults to False",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Export BuvisSettings from configuration module __init__.py",
            "description": "Update configuration/__init__.py to import and export BuvisSettings class and create settings singleton.",
            "dependencies": [
              2
            ],
            "details": "Modify `src/buvis/pybase/configuration/__init__.py`:\n- Add import: `from .settings import BuvisSettings`\n- Create singleton: `settings = BuvisSettings()`\n- Update __all__: append \"BuvisSettings\" and \"settings\"\nThis follows the existing pattern with `cfg = Configuration()`.",
            "status": "pending",
            "testStrategy": "Verify with `uv run python -c \"from buvis.pybase.configuration import BuvisSettings, settings\"`",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create tests/configuration directory and test file structure",
            "description": "Set up test directory structure for configuration module tests including __init__.py and test_settings.py.",
            "dependencies": [
              3
            ],
            "details": "Create directory `tests/configuration/` with empty `__init__.py`. Create `tests/configuration/test_settings.py` with basic imports and TestBuvisSettings class structure. Follow project test patterns: class-based organization, pytest fixtures where needed.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/ --collect-only` to verify test discovery",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Write unit tests for debug field env var mapping and bool coercion",
            "description": "Implement comprehensive tests for BuvisSettings.debug field including BUVIS_DEBUG env var mapping and bool coercion cases.",
            "dependencies": [
              4
            ],
            "details": "In `tests/configuration/test_settings.py`, add tests:\n- test_debug_default_is_false: BuvisSettings().debug == False\n- test_debug_from_env_true: monkeypatch BUVIS_DEBUG=true -> settings.debug == True\n- test_debug_from_env_1: monkeypatch BUVIS_DEBUG=1 -> True\n- test_debug_from_env_lowercase: monkeypatch buvis_debug=true (case insensitive)\n- test_debug_from_env_false: BUVIS_DEBUG=false -> False\nUse pytest monkeypatch fixture for env vars.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py -v` - all 5+ tests should pass",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:24:41.652Z"
      },
      {
        "id": "35",
        "title": "Add global log_level setting",
        "description": "Add log_level field with BUVIS_LOG_LEVEL mapping and Literal type validation.",
        "details": "Update BuvisSettings:\n\n```python\nfrom typing import Literal\n\nclass BuvisSettings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_\",\n        case_sensitive=False,\n        frozen=True,\n        extra=\"forbid\",\n    )\n    \n    debug: bool = False\n    log_level: Literal[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"] = \"INFO\"\n```\n\nLiteral ensures only valid log levels accepted. Invalid values raise ValidationError at instantiation.",
        "testStrategy": "Test: BUVIS_LOG_LEVEL=DEBUG -> settings.log_level == 'DEBUG'. Test: BUVIS_LOG_LEVEL=TRACE raises ValidationError. Test: default is 'INFO'.",
        "priority": "medium",
        "dependencies": [
          "34"
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Import Literal type and define LogLevel type alias",
            "description": "Add Literal import from typing and create a LogLevel type alias for the valid log level strings in settings.py.",
            "dependencies": [],
            "details": "In `src/buvis/pybase/configuration/settings.py`, add `from typing import Literal` and define `LogLevel = Literal[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]` as a module-level type alias for reuse and clarity.",
            "status": "pending",
            "testStrategy": "Verify import works and type alias is accessible from the module.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add log_level field to BuvisSettings class",
            "description": "Add log_level field with LogLevel type annotation and default value of 'INFO' to BuvisSettings.",
            "dependencies": [
              1
            ],
            "details": "In BuvisSettings class, add `log_level: LogLevel = \"INFO\"` field. With `env_prefix=\"BUVIS_\"`, this maps to BUVIS_LOG_LEVEL env var. Pydantic-settings handles the string validation via Literal type.",
            "status": "pending",
            "testStrategy": "Instantiate BuvisSettings() and verify settings.log_level == 'INFO'.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Test default log_level value",
            "description": "Add test verifying log_level defaults to 'INFO' when no env var is set.",
            "dependencies": [
              2
            ],
            "details": "In `tests/configuration/test_settings.py`, add test method `test_log_level_default` that creates BuvisSettings with no env vars and asserts `settings.log_level == \"INFO\"`.",
            "status": "pending",
            "testStrategy": "Run pytest on test_settings.py, verify test passes.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Test valid log_level values from environment",
            "description": "Add tests for each valid log level loaded from BUVIS_LOG_LEVEL env var.",
            "dependencies": [
              2
            ],
            "details": "Add parameterized test `test_log_level_valid_values` testing DEBUG, INFO, WARNING, ERROR, CRITICAL. Use monkeypatch to set BUVIS_LOG_LEVEL env var, instantiate BuvisSettings, verify value matches. Also test case-insensitivity if configured.",
            "status": "pending",
            "testStrategy": "Run pytest with parameterized cases for all 5 valid log levels.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test invalid log_level raises ValidationError",
            "description": "Add test verifying invalid log levels like 'TRACE' or 'VERBOSE' raise pydantic ValidationError.",
            "dependencies": [
              2
            ],
            "details": "Add test `test_log_level_invalid_raises_error` using monkeypatch to set BUVIS_LOG_LEVEL=TRACE, then assert `pytest.raises(ValidationError)` when instantiating BuvisSettings. Import ValidationError from pydantic.",
            "status": "pending",
            "testStrategy": "Run pytest, verify ValidationError raised for invalid values like 'TRACE', 'VERBOSE', 'trace', empty string.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:24:08.545Z"
      },
      {
        "id": "36",
        "title": "Create example PayrollSettings class",
        "description": "Create example tool-specific settings showing BUVIS_PAYROLL_ prefix pattern.",
        "details": "Add example in tests or docs showing the pattern:\n\n```python\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass PayrollSettings(BaseSettings):\n    \"\"\"Payroll tool settings.\n    \n    Env vars:\n    - BUVIS_PAYROLL_BATCH_SIZE\n    - BUVIS_PAYROLL_DATABASE_URL\n    \"\"\"\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_PAYROLL_\",\n        case_sensitive=False,\n        frozen=True,\n        extra=\"forbid\",\n    )\n    \n    batch_size: int = 1000\n    database_url: str = \"\"\n```\n\nThis demonstrates the PRD pattern: each tool gets its own BaseSettings subclass with tool-specific prefix. Simpler than nested models.",
        "testStrategy": "Test: BUVIS_PAYROLL_BATCH_SIZE=500 -> settings.batch_size == 500. Test: BUVIS_PAYROLL_DATABASE_URL=postgres://... loads correctly.",
        "priority": "medium",
        "dependencies": [
          "31"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create tests/configuration directory and PayrollSettings example file",
            "description": "Create tests/configuration/ directory and add example_payroll_settings.py with the PayrollSettings class demonstrating BUVIS_PAYROLL_ prefix pattern.",
            "dependencies": [],
            "details": "Create tests/configuration/example_payroll_settings.py containing the PayrollSettings class from task description:\n```python\nfrom __future__ import annotations\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass PayrollSettings(BaseSettings):\n    \"\"\"Payroll tool settings.\n    \n    Env vars:\n    - BUVIS_PAYROLL_BATCH_SIZE\n    - BUVIS_PAYROLL_DATABASE_URL\n    \"\"\"\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_PAYROLL_\",\n        case_sensitive=False,\n        frozen=True,\n        extra=\"forbid\",\n    )\n    \n    batch_size: int = 1000\n    database_url: str = \"\"\n```\nFollow project conventions: `from __future__ import annotations`, type hints, Google docstrings.",
            "status": "pending",
            "testStrategy": "Import PayrollSettings class without error; verify model_config has correct env_prefix.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Write test for BUVIS_PAYROLL_BATCH_SIZE env var loading",
            "description": "Create tests/configuration/test_example_payroll_settings.py with test verifying batch_size loads from BUVIS_PAYROLL_BATCH_SIZE environment variable.",
            "dependencies": [
              1
            ],
            "details": "Create test file following project patterns (class-based, fixtures, unittest.mock.patch):\n```python\nimport os\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom tests.configuration.example_payroll_settings import PayrollSettings\n\n\nclass TestPayrollSettingsEnvVars:\n    def test_batch_size_from_env(self) -> None:\n        with patch.dict(os.environ, {\"BUVIS_PAYROLL_BATCH_SIZE\": \"500\"}):\n            settings = PayrollSettings()\n            assert settings.batch_size == 500\n\n    def test_batch_size_default(self) -> None:\n        settings = PayrollSettings()\n        assert settings.batch_size == 1000\n```",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_example_payroll_settings.py -v -k batch_size`. Both tests pass.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Write test for BUVIS_PAYROLL_DATABASE_URL env var loading",
            "description": "Add tests verifying database_url loads correctly from BUVIS_PAYROLL_DATABASE_URL environment variable.",
            "dependencies": [
              2
            ],
            "details": "Add to TestPayrollSettingsEnvVars class:\n```python\n    def test_database_url_from_env(self) -> None:\n        with patch.dict(os.environ, {\"BUVIS_PAYROLL_DATABASE_URL\": \"postgres://localhost/payroll\"}):\n            settings = PayrollSettings()\n            assert settings.database_url == \"postgres://localhost/payroll\"\n\n    def test_database_url_default(self) -> None:\n        settings = PayrollSettings()\n        assert settings.database_url == \"\"\n```\nThis validates the PRD test case for database URL loading.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_example_payroll_settings.py -v -k database_url`. Both tests pass.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Write tests for SettingsConfigDict behaviors (frozen, extra)",
            "description": "Add tests verifying the SettingsConfigDict settings: frozen=True prevents mutation, extra=\"forbid\" rejects unknown fields.",
            "dependencies": [
              3
            ],
            "details": "Add new test class:\n```python\nfrom pydantic import ValidationError\n\n\nclass TestPayrollSettingsConfig:\n    def test_immutable_frozen(self) -> None:\n        settings = PayrollSettings()\n        with pytest.raises(ValidationError):\n            settings.batch_size = 999\n\n    def test_extra_forbid_rejects_unknown(self) -> None:\n        with pytest.raises(ValidationError):\n            PayrollSettings(unknown_field=\"value\")\n\n    def test_case_insensitive_env(self) -> None:\n        with patch.dict(os.environ, {\"buvis_payroll_batch_size\": \"250\"}):\n            settings = PayrollSettings()\n            assert settings.batch_size == 250\n```",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_example_payroll_settings.py -v`. All config tests pass.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add docstring example and ensure tests pass with pre-commit",
            "description": "Enhance PayrollSettings docstring with usage example, run full test suite with pre-commit to verify integration.",
            "dependencies": [
              4
            ],
            "details": "Update PayrollSettings docstring:\n```python\nclass PayrollSettings(BaseSettings):\n    \"\"\"Payroll tool settings demonstrating tool-specific prefix pattern.\n    \n    Each tool gets its own BaseSettings subclass with BUVIS_{TOOL}_ prefix.\n    \n    Example:\n        >>> import os\n        >>> os.environ[\"BUVIS_PAYROLL_BATCH_SIZE\"] = \"500\"\n        >>> settings = PayrollSettings()\n        >>> settings.batch_size\n        500\n    \n    Env vars:\n    - BUVIS_PAYROLL_BATCH_SIZE: Processing batch size (default: 1000)\n    - BUVIS_PAYROLL_DATABASE_URL: Database connection string\n    \"\"\"\n```\nRun `uv run pytest tests/configuration/ -v` and `uv run pre-commit run --all-files`.",
            "status": "pending",
            "testStrategy": "Run full test suite: `uv run pytest tests/configuration/ -v`. Verify pre-commit passes: `uv run pre-commit run --all-files`.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "37",
        "title": "Test case-insensitive env loading",
        "description": "Verify lowercase env vars work: buvis_debug=true should set settings.debug=True.",
        "details": "Create test in `tests/configuration/test_buvis_settings.py`:\n\n```python\nimport os\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom buvis.pybase.configuration.buvis_settings import BuvisSettings\n\n\nclass TestCaseInsensitivity:\n    @patch.dict(os.environ, {\"BUVIS_DEBUG\": \"true\"})\n    def test_uppercase_works(self):\n        settings = BuvisSettings()\n        assert settings.debug is True\n\n    @patch.dict(os.environ, {\"buvis_debug\": \"true\"})\n    def test_lowercase_works(self):\n        settings = BuvisSettings()\n        assert settings.debug is True\n\n    @patch.dict(os.environ, {\"Buvis_Debug\": \"true\"})\n    def test_mixed_case_works(self):\n        settings = BuvisSettings()\n        assert settings.debug is True\n```\n\nPydantic-settings handles case insensitivity via `case_sensitive=False`.",
        "testStrategy": "All three case variants pass and set debug=True.",
        "priority": "high",
        "dependencies": [
          "34"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create tests/configuration directory and test file structure",
            "description": "Set up the test directory structure for configuration tests, creating tests/configuration/test_buvis_settings.py with necessary imports.",
            "dependencies": [],
            "details": "Create tests/configuration/__init__.py (empty) and tests/configuration/test_buvis_settings.py with imports: os, unittest.mock.patch, pytest, and BuvisSettings from buvis.pybase.configuration.buvis_settings. Follow existing test file patterns from tests/adapters/.",
            "status": "pending",
            "testStrategy": "Verify file exists and imports resolve correctly when BuvisSettings is implemented.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement test_uppercase_works for BUVIS_DEBUG=true",
            "description": "Create test verifying uppercase environment variable BUVIS_DEBUG=true correctly sets settings.debug=True.",
            "dependencies": [
              1
            ],
            "details": "Add TestCaseInsensitivity class with test_uppercase_works method using @patch.dict(os.environ, {\"BUVIS_DEBUG\": \"true\"}). Instantiate BuvisSettings() and assert settings.debug is True. This is the baseline test confirming standard env var behavior.",
            "status": "pending",
            "testStrategy": "Run pytest tests/configuration/test_buvis_settings.py::TestCaseInsensitivity::test_uppercase_works, expect pass.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement test_lowercase_works for buvis_debug=true",
            "description": "Create test verifying lowercase environment variable buvis_debug=true correctly sets settings.debug=True.",
            "dependencies": [
              1
            ],
            "details": "Add test_lowercase_works method to TestCaseInsensitivity class using @patch.dict(os.environ, {\"buvis_debug\": \"true\"}). Instantiate BuvisSettings() and assert settings.debug is True. This validates pydantic-settings case_sensitive=False behavior.",
            "status": "pending",
            "testStrategy": "Run pytest tests/configuration/test_buvis_settings.py::TestCaseInsensitivity::test_lowercase_works, expect pass.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement test_mixed_case_works for Buvis_Debug=true",
            "description": "Create test verifying mixed-case environment variable Buvis_Debug=true correctly sets settings.debug=True.",
            "dependencies": [
              1
            ],
            "details": "Add test_mixed_case_works method to TestCaseInsensitivity class using @patch.dict(os.environ, {\"Buvis_Debug\": \"true\"}). Instantiate BuvisSettings() and assert settings.debug is True. This tests edge case of arbitrary capitalization.",
            "status": "pending",
            "testStrategy": "Run pytest tests/configuration/test_buvis_settings.py::TestCaseInsensitivity::test_mixed_case_works, expect pass.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run full test suite and verify all case variants pass",
            "description": "Execute pytest on the complete TestCaseInsensitivity class to confirm all three case variants work correctly.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Run uv run pytest tests/configuration/test_buvis_settings.py -v to execute all tests. Verify all three tests (uppercase, lowercase, mixed) pass with settings.debug=True. If failures occur, debug by checking case_sensitive=False is set in BuvisSettings model_config.",
            "status": "pending",
            "testStrategy": "All three case variant tests pass. Output shows 3 passed in test summary.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:25:44.462Z"
      },
      {
        "id": "38",
        "title": "Test unprefixed env vars ignored",
        "description": "Verify DEBUG=true (without BUVIS_ prefix) is ignored per security constraint.",
        "details": "Add test:\n\n```python\nclass TestPrefixRequired:\n    @patch.dict(os.environ, {\"DEBUG\": \"true\"}, clear=True)\n    def test_unprefixed_ignored(self):\n        \"\"\"Vars without BUVIS_ prefix must not affect settings.\"\"\"\n        settings = BuvisSettings()\n        assert settings.debug is False  # Uses default, ignores DEBUG\n\n    @patch.dict(os.environ, {\"PAYROLL_BATCH_SIZE\": \"500\"}, clear=True)\n    def test_tool_without_buvis_prefix_ignored(self):\n        settings = PayrollSettings()\n        assert settings.batch_size == 1000  # Uses default\n```\n\nThis enforces the security constraint: only BUVIS_ prefixed vars are loaded.",
        "testStrategy": "Both tests pass confirming unprefixed env vars have no effect on settings.",
        "priority": "high",
        "dependencies": [
          "34",
          "36"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test file for prefix security tests",
            "description": "Create tests/configuration/test_prefix_required.py with imports and TestPrefixRequired class structure following project test conventions.",
            "dependencies": [],
            "details": "Create `tests/configuration/test_prefix_required.py` with:\n- `from __future__ import annotations`\n- `import os`\n- `from unittest.mock import patch`\n- `import pytest`\n- Import BuvisSettings from buvis.pybase.configuration.settings\n- Import PayrollSettings from appropriate location (tests/configuration/example_payroll_settings or src path)\n- Empty TestPrefixRequired class docstring: \"Tests ensuring env vars without BUVIS_ prefix are ignored per security constraint.\"",
            "status": "pending",
            "testStrategy": "File parses without syntax errors; imports resolve after dependencies (tasks 34, 36) are complete.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add test_unprefixed_debug_ignored for BuvisSettings",
            "description": "Add test verifying DEBUG=true without BUVIS_ prefix does not affect settings.debug which should remain False (default).",
            "dependencies": [
              1
            ],
            "details": "Add to TestPrefixRequired class:\n```python\n@patch.dict(os.environ, {\"DEBUG\": \"true\"}, clear=True)\ndef test_unprefixed_debug_ignored(self) -> None:\n    \"\"\"Vars without BUVIS_ prefix must not affect settings.\"\"\"\n    settings = BuvisSettings()\n    assert settings.debug is False  # Uses default, ignores DEBUG\n```\nThe `clear=True` ensures isolated env. Test validates PRD security constraint: only BUVIS_ prefixed vars load.",
            "status": "pending",
            "testStrategy": "Test passes: settings.debug == False despite DEBUG=true in environment.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add test_tool_without_buvis_prefix_ignored for PayrollSettings",
            "description": "Add test verifying PAYROLL_BATCH_SIZE=500 without BUVIS_PAYROLL_ prefix does not affect settings.batch_size which should remain 1000 (default).",
            "dependencies": [
              1
            ],
            "details": "Add to TestPrefixRequired class:\n```python\n@patch.dict(os.environ, {\"PAYROLL_BATCH_SIZE\": \"500\"}, clear=True)\ndef test_tool_without_buvis_prefix_ignored(self) -> None:\n    \"\"\"Tool-specific vars without BUVIS_TOOL_ prefix must be ignored.\"\"\"\n    settings = PayrollSettings()\n    assert settings.batch_size == 1000  # Uses default\n```\nThis validates PRD constraint for tool-specific settings (BUVIS_PAYROLL_ prefix required).",
            "status": "pending",
            "testStrategy": "Test passes: settings.batch_size == 1000 despite PAYROLL_BATCH_SIZE=500 in environment.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add contrast tests confirming prefixed vars work",
            "description": "Add tests confirming that BUVIS_DEBUG=true and BUVIS_PAYROLL_BATCH_SIZE=500 DO work, contrasting with unprefixed tests.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add TestPrefixedVarsWork class with contrast tests:\n```python\nclass TestPrefixedVarsWork:\n    \"\"\"Contrast: prefixed vars DO load correctly.\"\"\"\n\n    @patch.dict(os.environ, {\"BUVIS_DEBUG\": \"true\"}, clear=True)\n    def test_buvis_debug_loads(self) -> None:\n        settings = BuvisSettings()\n        assert settings.debug is True\n\n    @patch.dict(os.environ, {\"BUVIS_PAYROLL_BATCH_SIZE\": \"500\"}, clear=True)\n    def test_buvis_payroll_batch_size_loads(self) -> None:\n        settings = PayrollSettings()\n        assert settings.batch_size == 500\n```\nThese prove the prefix mechanism works, making the ignore tests meaningful.",
            "status": "pending",
            "testStrategy": "Both tests pass: prefixed vars correctly update settings values.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run pytest and verify all prefix security tests pass",
            "description": "Execute pytest on test_prefix_required.py to verify all 4 tests pass, confirming unprefixed env vars are correctly ignored.",
            "dependencies": [
              4
            ],
            "details": "Run:\n```bash\nuv run pytest tests/configuration/test_prefix_required.py -v\n```\nExpected output: 4 tests pass (2 unprefixed-ignored, 2 prefixed-work). If any fail, debug by checking:\n- env_prefix configuration in BuvisSettings/PayrollSettings\n- clear=True in @patch.dict to isolate env\n- Correct default values in settings classes",
            "status": "pending",
            "testStrategy": "All 4 tests pass: test_unprefixed_debug_ignored, test_tool_without_buvis_prefix_ignored, test_buvis_debug_loads, test_buvis_payroll_batch_size_loads.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "39",
        "title": "Export settings from configuration module",
        "description": "Update configuration/__init__.py to export BuvisSettings and utilities.",
        "details": "Edit `src/buvis/pybase/configuration/__init__.py`:\n\n```python\nfrom .buvis_settings import (\n    BuvisSettings,\n    validate_env_var_name,\n    assert_valid_env_var_name,\n)\nfrom .configuration import Configuration, cfg\nfrom .exceptions import ConfigurationKeyNotFoundError\n\n__all__ = [\n    \"BuvisSettings\",\n    \"Configuration\",\n    \"ConfigurationKeyNotFoundError\",\n    \"assert_valid_env_var_name\",\n    \"cfg\",\n    \"validate_env_var_name\",\n]\n```\n\nAllows consumers to import: `from buvis.pybase.configuration import BuvisSettings`",
        "testStrategy": "Verify imports work: from buvis.pybase.configuration import BuvisSettings, validate_env_var_name",
        "priority": "medium",
        "dependencies": [
          "33",
          "35"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Review current __init__.py structure and planned exports",
            "description": "Examine current configuration/__init__.py exports and verify buvis_settings.py exists with expected symbols.",
            "dependencies": [],
            "details": "Read `src/buvis/pybase/configuration/__init__.py` to understand current import structure. Verify `buvis_settings.py` was created by dependency tasks and exports `BuvisSettings`, `validate_env_var_name`, `assert_valid_env_var_name`. Check symbols are importable from buvis_settings module.",
            "status": "pending",
            "testStrategy": "Run `uv run python -c 'from buvis.pybase.configuration.buvis_settings import BuvisSettings, validate_env_var_name, assert_valid_env_var_name'`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add BuvisSettings import from buvis_settings module",
            "description": "Add import statement to bring BuvisSettings class into configuration package namespace.",
            "dependencies": [
              1
            ],
            "details": "Edit `src/buvis/pybase/configuration/__init__.py` to add:\n```python\nfrom .buvis_settings import BuvisSettings\n```\nThis enables consumers to use `from buvis.pybase.configuration import BuvisSettings`.",
            "status": "pending",
            "testStrategy": "Run `uv run python -c 'from buvis.pybase.configuration import BuvisSettings; print(BuvisSettings)'`",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add validator function imports from buvis_settings module",
            "description": "Add import statements for validate_env_var_name and assert_valid_env_var_name utilities.",
            "dependencies": [
              2
            ],
            "details": "Update the buvis_settings import in `__init__.py` to include validator functions:\n```python\nfrom .buvis_settings import (\n    BuvisSettings,\n    validate_env_var_name,\n    assert_valid_env_var_name,\n)\n```",
            "status": "pending",
            "testStrategy": "Run `uv run python -c 'from buvis.pybase.configuration import validate_env_var_name, assert_valid_env_var_name'`",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Refactor ConfigurationKeyNotFoundError to import from exceptions module",
            "description": "Change ConfigurationKeyNotFoundError import to use exceptions.py directly instead of via configuration.py.",
            "dependencies": [
              3
            ],
            "details": "Update `__init__.py` imports from:\n```python\nfrom .configuration import Configuration, ConfigurationKeyNotFoundError, cfg\n```\nTo:\n```python\nfrom .configuration import Configuration, cfg\nfrom .exceptions import ConfigurationKeyNotFoundError\n```\nThis follows cleaner import pattern matching source location.",
            "status": "pending",
            "testStrategy": "Run `uv run python -c 'from buvis.pybase.configuration import ConfigurationKeyNotFoundError'`",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Update __all__ with new exports in alphabetical order",
            "description": "Add all new exports to __all__ list maintaining alphabetical ordering convention.",
            "dependencies": [
              4
            ],
            "details": "Update `__all__` in `__init__.py` to:\n```python\n__all__ = [\n    \"BuvisSettings\",\n    \"Configuration\",\n    \"ConfigurationKeyNotFoundError\",\n    \"assert_valid_env_var_name\",\n    \"cfg\",\n    \"validate_env_var_name\",\n]\n```\nAlphabetical order: classes first capitalized, then functions/instances lowercase.",
            "status": "pending",
            "testStrategy": "Verify all imports work: `from buvis.pybase.configuration import BuvisSettings, validate_env_var_name, assert_valid_env_var_name, Configuration, cfg, ConfigurationKeyNotFoundError`",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "40",
        "title": "Create comprehensive test suite",
        "description": "Create tests/configuration/test_buvis_settings.py with all PRD test cases.",
        "details": "Create full test file:\n\n```python\nimport os\nfrom unittest.mock import patch\n\nimport pytest\nfrom pydantic import ValidationError\n\nfrom buvis.pybase.configuration.buvis_settings import (\n    BuvisSettings,\n    validate_env_var_name,\n)\n\n\nclass TestBuvisSettingsDefaults:\n    def test_debug_default_false(self):\n        settings = BuvisSettings()\n        assert settings.debug is False\n\n    def test_log_level_default_info(self):\n        settings = BuvisSettings()\n        assert settings.log_level == \"INFO\"\n\n\nclass TestEnvVarLoading:\n    @patch.dict(os.environ, {\"BUVIS_DEBUG\": \"true\"})\n    def test_buvis_debug_true(self):\n        \"\"\"PRD test 1: BUVIS_DEBUG=true -> settings.debug == True\"\"\"\n        settings = BuvisSettings()\n        assert settings.debug is True\n\n    @patch.dict(os.environ, {\"buvis_debug\": \"true\"})\n    def test_lowercase_works(self):\n        \"\"\"PRD test 2: buvis_debug=true (lowercase) works\"\"\"\n        settings = BuvisSettings()\n        assert settings.debug is True\n\n    @patch.dict(os.environ, {\"DEBUG\": \"true\"}, clear=True)\n    def test_no_prefix_ignored(self):\n        \"\"\"PRD test 3: DEBUG=true (no prefix) ignored\"\"\"\n        settings = BuvisSettings()\n        assert settings.debug is False\n\n\nclass TestToolSettings:\n    @patch.dict(os.environ, {\"BUVIS_PAYROLL_BATCH_SIZE\": \"500\"})\n    def test_payroll_batch_size(self):\n        \"\"\"PRD test 4: BUVIS_PAYROLL_BATCH_SIZE=500\"\"\"\n        from pydantic_settings import BaseSettings, SettingsConfigDict\n\n        class PayrollSettings(BaseSettings):\n            model_config = SettingsConfigDict(\n                env_prefix=\"BUVIS_PAYROLL_\",\n                case_sensitive=False,\n            )\n            batch_size: int = 1000\n\n        settings = PayrollSettings()\n        assert settings.batch_size == 500\n\n\nclass TestEnvVarNameValidation:\n    @pytest.mark.parametrize(\"name\", [\n        \"BUVIS_DEBUG\",\n        \"BUVIS_LOG_LEVEL\",\n        \"BUVIS_PAYROLL_BATCH_SIZE\",\n        \"BUVIS_PAYROLL_DATABASE_URL\",\n    ])\n    def test_valid_names(self, name):\n        assert validate_env_var_name(name) is True\n\n    @pytest.mark.parametrize(\"name\", [\n        \"DEBUG\",\n        \"buvis_debug\",\n        \"BUVIS-DEBUG\",\n        \"BUVIS_\",\n    ])\n    def test_invalid_names(self, name):\n        assert validate_env_var_name(name) is False\n```",
        "testStrategy": "Run `uv run pytest tests/configuration/test_buvis_settings.py -v`. All 4 PRD tests plus validation tests pass.",
        "priority": "high",
        "dependencies": [
          "37",
          "38",
          "39"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test file scaffold with imports and structure",
            "description": "Create tests/configuration/test_buvis_settings.py with proper imports and class structure.",
            "dependencies": [],
            "details": "Create tests/configuration/ directory if needed. Add imports: os, unittest.mock.patch, pytest, pydantic.ValidationError, and the buvis_settings module. Set up empty test class scaffolds: TestBuvisSettingsDefaults, TestEnvVarLoading, TestToolSettings, TestEnvVarNameValidation.",
            "status": "pending",
            "testStrategy": "File exists with correct imports and class definitions. No syntax errors.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement TestBuvisSettingsDefaults class",
            "description": "Add tests for default values: debug=False and log_level='INFO'.",
            "dependencies": [
              1
            ],
            "details": "Add test_debug_default_false() and test_log_level_default_info() methods. Each creates BuvisSettings() with no env vars and asserts defaults. Follow existing pattern: def test_*(self) with docstrings.",
            "status": "pending",
            "testStrategy": "Tests pass when BuvisSettings defaults are correct per PRD.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement TestEnvVarLoading class with PRD test cases",
            "description": "Add PRD tests 1-3: BUVIS_DEBUG=true, lowercase buvis_debug=true, DEBUG without prefix.",
            "dependencies": [
              1
            ],
            "details": "Use @patch.dict(os.environ, {...}) for each test. test_buvis_debug_true: BUVIS_DEBUG=true -> debug==True. test_lowercase_works: buvis_debug=true -> debug==True. test_no_prefix_ignored: DEBUG=true (no BUVIS_) -> debug==False. Include PRD reference in docstrings.",
            "status": "pending",
            "testStrategy": "All 3 PRD env var loading tests pass with clear=True where needed.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement TestToolSettings class with PayrollSettings example",
            "description": "Add PRD test 4: BUVIS_PAYROLL_BATCH_SIZE=500 loading for tool-specific settings.",
            "dependencies": [
              1
            ],
            "details": "Create test_payroll_batch_size() that defines inline PayrollSettings(BaseSettings) with env_prefix='BUVIS_PAYROLL_', case_sensitive=False. Use @patch.dict for BUVIS_PAYROLL_BATCH_SIZE=500. Assert batch_size==500.",
            "status": "pending",
            "testStrategy": "Test proves tool-specific prefix pattern works per PRD requirements.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement TestEnvVarNameValidation class with parametrized tests",
            "description": "Add validation tests for validate_env_var_name() function with valid/invalid patterns.",
            "dependencies": [
              1
            ],
            "details": "Use @pytest.mark.parametrize for valid names: BUVIS_DEBUG, BUVIS_LOG_LEVEL, BUVIS_PAYROLL_BATCH_SIZE, BUVIS_PAYROLL_DATABASE_URL (expect True). Invalid names: DEBUG, buvis_debug, BUVIS-DEBUG, BUVIS_ (expect False). Two test methods: test_valid_names and test_invalid_names.",
            "status": "pending",
            "testStrategy": "uv run pytest tests/configuration/test_buvis_settings.py -v passes all parametrized cases.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "41",
        "title": "Create nested model examples for pool settings",
        "description": "Create PoolSettings and DatabaseSettings nested Pydantic models demonstrating the __ delimiter pattern.",
        "details": "Create `src/buvis/pybase/configuration/examples/nested_settings.py`:\n\n```python\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass PoolSettings(BaseModel):\n    \"\"\"Database connection pool settings.\n    \n    Fields accessed via __ delimiter:\n    - BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE\n    - BUVIS_PAYROLL_DATABASE_POOL__MAX_SIZE\n    \"\"\"\n    min_size: int = 5\n    max_size: int = 20\n\n\nclass DatabaseSettings(BaseModel):\n    \"\"\"Database connection settings.\n    \n    Direct fields (no __ needed):\n    - BUVIS_PAYROLL_DATABASE_URL\n    \n    Nested model (__ required):\n    - BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE\n    \"\"\"\n    url: str = \"\"\n    pool: PoolSettings = Field(default_factory=PoolSettings)\n\n\nclass PayrollSettings(BaseSettings):\n    \"\"\"Example tool settings with nested models.\"\"\"\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_PAYROLL_\",\n        env_nested_delimiter=\"__\",\n        case_sensitive=False,\n        frozen=True,\n        extra=\"forbid\",\n    )\n    \n    database: DatabaseSettings = Field(default_factory=DatabaseSettings)\n```\n\nKey: `env_nested_delimiter=\"__\"` enables the double underscore behavior in pydantic-settings.",
        "testStrategy": "Import and instantiate PayrollSettings. Verify database.pool.min_size == 5 by default.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add pydantic-settings dependency to pyproject.toml",
            "description": "Add pydantic-settings package to project dependencies since it's required for BaseSettings and SettingsConfigDict.",
            "dependencies": [],
            "details": "Add `pydantic-settings>=2.0,<3` to the dependencies list in pyproject.toml. This enables BaseSettings, SettingsConfigDict, and env_nested_delimiter features. Run `uv sync` after adding.",
            "status": "done",
            "testStrategy": "Run `uv sync --all-groups` and verify `from pydantic_settings import BaseSettings` imports successfully.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:48:08.172Z"
          },
          {
            "id": 2,
            "title": "Create examples directory with __init__.py",
            "description": "Create the examples subdirectory under configuration module with proper package initialization.",
            "dependencies": [
              1
            ],
            "details": "Create `src/buvis/pybase/configuration/examples/` directory. Add `__init__.py` with `from .nested_settings import PoolSettings, DatabaseSettings, PayrollSettings` and `__all__` export list.",
            "status": "done",
            "testStrategy": "Verify directory exists and __init__.py contains proper exports. Import test: `from buvis.pybase.configuration.examples import PoolSettings`.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:50:58.057Z"
          },
          {
            "id": 3,
            "title": "Create PoolSettings BaseModel",
            "description": "Create the innermost nested model for database connection pool settings with min_size and max_size fields.",
            "dependencies": [
              2
            ],
            "details": "In `nested_settings.py`, create PoolSettings(BaseModel) with: `min_size: int = 5`, `max_size: int = 20`. Include docstring explaining `__` delimiter access pattern: `BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE`.",
            "status": "done",
            "testStrategy": "Instantiate PoolSettings() and verify defaults: min_size==5, max_size==20. Test custom values via constructor.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:50:58.099Z"
          },
          {
            "id": 4,
            "title": "Create DatabaseSettings and PayrollSettings models",
            "description": "Create DatabaseSettings model containing PoolSettings, and PayrollSettings BaseSettings with env_nested_delimiter configured.",
            "dependencies": [
              3
            ],
            "details": "Add DatabaseSettings(BaseModel) with `url: str = \"\"` and `pool: PoolSettings = Field(default_factory=PoolSettings)`. Add PayrollSettings(BaseSettings) with model_config containing env_prefix='BUVIS_PAYROLL_', env_nested_delimiter='__', case_sensitive=False, frozen=True, extra='forbid'.",
            "status": "done",
            "testStrategy": "Instantiate PayrollSettings() and verify database.pool.min_size==5, database.url==''. Test env_nested_delimiter works with BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:50:58.139Z"
          },
          {
            "id": 5,
            "title": "Create test file for nested settings",
            "description": "Create tests/configuration/test_nested_settings.py with tests for defaults and env var loading via __ delimiter.",
            "dependencies": [
              4
            ],
            "details": "Create test class TestNestedSettings with: test_pool_defaults (verify min_size=5, max_size=20), test_database_defaults (url='', pool nested), test_payroll_env_nested_delimiter (use @patch.dict with BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE=10 and verify settings.database.pool.min_size==10), test_payroll_immutable (verify frozen=True raises on assignment).",
            "status": "done",
            "testStrategy": "Run `uv run pytest tests/configuration/test_nested_settings.py -v` and verify all 4 tests pass.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:50:58.180Z"
          }
        ],
        "updatedAt": "2026-01-02T17:50:58.180Z"
      },
      {
        "id": "42",
        "title": "Test nested env var resolution with __",
        "description": "Verify BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE=10 sets settings.database.pool.min_size == 10.",
        "details": "Add test in `tests/configuration/test_nested_env_settings.py`:\n\n```python\nimport os\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom buvis.pybase.configuration.examples.nested_settings import PayrollSettings\n\n\nclass TestNestedEnvResolution:\n    @patch.dict(os.environ, {\"BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE\": \"10\"})\n    def test_nested_pool_min_size(self):\n        \"\"\"PRD test 1: __ correctly descends into nested model.\"\"\"\n        settings = PayrollSettings()\n        assert settings.database.pool.min_size == 10\n\n    @patch.dict(os.environ, {\"BUVIS_PAYROLL_DATABASE_POOL__MAX_SIZE\": \"50\"})\n    def test_nested_pool_max_size(self):\n        settings = PayrollSettings()\n        assert settings.database.pool.max_size == 50\n\n    @patch.dict(os.environ, {\n        \"BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE\": \"10\",\n        \"BUVIS_PAYROLL_DATABASE_POOL__MAX_SIZE\": \"100\",\n    })\n    def test_multiple_nested_fields(self):\n        settings = PayrollSettings()\n        assert settings.database.pool.min_size == 10\n        assert settings.database.pool.max_size == 100\n```\n\nThis directly validates PRD test case 1.",
        "testStrategy": "Run pytest on test_nested_env_settings.py, all nested __ tests pass.",
        "priority": "high",
        "dependencies": [
          "41"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create tests/configuration directory structure",
            "description": "Create the tests/configuration/ directory to house configuration-related tests, following the project's mirrored test structure.",
            "dependencies": [],
            "details": "Create `tests/configuration/` directory. Add empty `__init__.py` if needed for pytest discovery. This directory will contain all configuration module tests including the nested env settings tests.",
            "status": "pending",
            "testStrategy": "Verify directory exists and pytest can discover tests in it.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create test file with imports and fixtures",
            "description": "Create test_nested_env_settings.py with required imports: os, unittest.mock.patch, pytest, and PayrollSettings from the examples module.",
            "dependencies": [
              1
            ],
            "details": "Create `tests/configuration/test_nested_env_settings.py`. Import `os`, `from unittest.mock import patch`, `pytest`, and `from buvis.pybase.configuration.examples.nested_settings import PayrollSettings`. Follow existing test file patterns from test_shell_adapter.py.",
            "status": "pending",
            "testStrategy": "File imports successfully when Task 41's nested_settings.py exists.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement test_nested_pool_min_size test",
            "description": "Add TestNestedEnvResolution class with test for BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE=10 setting database.pool.min_size.",
            "dependencies": [
              2
            ],
            "details": "Create `class TestNestedEnvResolution:` with `@patch.dict(os.environ, {\"BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE\": \"10\"})` decorator. Test instantiates `PayrollSettings()` and asserts `settings.database.pool.min_size == 10`. This validates PRD-00005 test case 1.",
            "status": "pending",
            "testStrategy": "Run pytest on test file; test passes when env var correctly populates nested field.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add test_nested_pool_max_size test method",
            "description": "Add test for BUVIS_PAYROLL_DATABASE_POOL__MAX_SIZE=50 setting database.pool.max_size to verify pattern works for multiple fields.",
            "dependencies": [
              3
            ],
            "details": "Add `test_nested_pool_max_size` method with `@patch.dict(os.environ, {\"BUVIS_PAYROLL_DATABASE_POOL__MAX_SIZE\": \"50\"})`. Assert `settings.database.pool.max_size == 50`. Validates the __ delimiter works consistently across different nested fields.",
            "status": "pending",
            "testStrategy": "Run pytest; max_size test passes with correct value from env var.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add test_multiple_nested_fields test method",
            "description": "Add test for setting multiple nested pool fields simultaneously via env vars to ensure they don't interfere.",
            "dependencies": [
              4
            ],
            "details": "Add `test_multiple_nested_fields` with `@patch.dict(os.environ, {\"BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE\": \"10\", \"BUVIS_PAYROLL_DATABASE_POOL__MAX_SIZE\": \"100\"})`. Assert both `settings.database.pool.min_size == 10` and `settings.database.pool.max_size == 100`. Validates multiple nested env vars resolve correctly together.",
            "status": "pending",
            "testStrategy": "Run pytest on test_nested_env_settings.py; all three nested __ tests pass.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:26:44.049Z"
      },
      {
        "id": "43",
        "title": "Test direct field without __ delimiter",
        "description": "Verify BUVIS_PAYROLL_DATABASE_URL=foo sets settings.database.url without needing __.",
        "details": "Add to `tests/configuration/test_nested_env_settings.py`:\n\n```python\nclass TestDirectFieldResolution:\n    @patch.dict(os.environ, {\"BUVIS_PAYROLL_DATABASE_URL\": \"postgresql://localhost/db\"})\n    def test_direct_scalar_field(self):\n        \"\"\"PRD test 2: url is direct field, no __ needed.\"\"\"\n        settings = PayrollSettings()\n        assert settings.database.url == \"postgresql://localhost/db\"\n\n    @patch.dict(os.environ, {\n        \"BUVIS_PAYROLL_DATABASE_URL\": \"postgres://host/db\",\n        \"BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE\": \"15\",\n    })\n    def test_mixed_direct_and_nested(self):\n        \"\"\"Both direct and nested fields work together.\"\"\"\n        settings = PayrollSettings()\n        assert settings.database.url == \"postgres://host/db\"\n        assert settings.database.pool.min_size == 15\n```\n\nThis validates PRD test case 2 and the visual breakdown example.",
        "testStrategy": "All direct field tests pass without requiring __ delimiter for scalar fields.",
        "priority": "high",
        "dependencies": [
          "41"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify test file and imports exist",
            "description": "Confirm test file from task 41 exists and has required imports for env patching.",
            "dependencies": [],
            "details": "Check that `tests/configuration/test_nested_settings.py` (created by task 41) exists with imports: `os`, `patch.dict` from `unittest.mock`, and `PayrollSettings` from `buvis.pybase.configuration.examples.nested_settings`. If file uses different name (`test_nested_env_settings.py`), use that. Add missing imports if needed.",
            "status": "pending",
            "testStrategy": "File exists and imports resolve without ImportError.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create TestDirectFieldResolution class",
            "description": "Add empty test class with docstring explaining direct field vs nested field distinction.",
            "dependencies": [
              1
            ],
            "details": "Add to test file:\n```python\nclass TestDirectFieldResolution:\n    \"\"\"Tests for direct scalar fields without __ delimiter.\n    \n    PRD-00005: url is a direct field in DatabaseSettings,\n    not a nested model, so no __ delimiter is needed.\n    \"\"\"\n```\nClass groups tests validating that scalar fields work without double underscore.",
            "status": "pending",
            "testStrategy": "Test class imports and is recognized by pytest collection.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement test_direct_scalar_field test",
            "description": "Test that BUVIS_PAYROLL_DATABASE_URL sets database.url without __ delimiter.",
            "dependencies": [
              2
            ],
            "details": "Add test method:\n```python\n@patch.dict(os.environ, {\"BUVIS_PAYROLL_DATABASE_URL\": \"postgresql://localhost/db\"})\ndef test_direct_scalar_field(self):\n    \"\"\"PRD test 2: url is direct field, no __ needed.\"\"\"\n    settings = PayrollSettings()\n    assert settings.database.url == \"postgresql://localhost/db\"\n```\nThis validates the key pydantic-settings behavior from PRD-00005 examples table.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest -v -k test_direct_scalar_field` - test passes.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement test_mixed_direct_and_nested test",
            "description": "Test that direct fields and nested __ fields work together in same settings instance.",
            "dependencies": [
              3
            ],
            "details": "Add test method:\n```python\n@patch.dict(os.environ, {\n    \"BUVIS_PAYROLL_DATABASE_URL\": \"postgres://host/db\",\n    \"BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE\": \"15\",\n})\ndef test_mixed_direct_and_nested(self):\n    \"\"\"Both direct and nested fields work together.\"\"\"\n    settings = PayrollSettings()\n    assert settings.database.url == \"postgres://host/db\"\n    assert settings.database.pool.min_size == 15\n```\nEnsures no interference between the two resolution strategies.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest -v -k test_mixed_direct_and_nested` - test passes with both assertions.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run full test suite and verify no regressions",
            "description": "Execute all nested settings tests and confirm direct field tests pass alongside existing tests.",
            "dependencies": [
              4
            ],
            "details": "Run `uv run pytest tests/configuration/test_nested_settings.py -v` to execute all tests in file. Verify:\n- TestDirectFieldResolution::test_direct_scalar_field passes\n- TestDirectFieldResolution::test_mixed_direct_and_nested passes\n- All pre-existing tests from task 41 still pass\n- No validation errors or import issues",
            "status": "pending",
            "testStrategy": "All tests in test_nested_settings.py pass. Exit code 0.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:29:37.801Z"
      },
      {
        "id": "44",
        "title": "Test incorrect __ usage is ignored",
        "description": "Verify BUVIS_PAYROLL_DATABASE__URL=foo is ignored (url is not a nested model).",
        "details": "Add to `tests/configuration/test_nested_env_settings.py`:\n\n```python\nclass TestIncorrectNestedDelimiter:\n    @patch.dict(os.environ, {\"BUVIS_PAYROLL_DATABASE__URL\": \"wrong\"}, clear=True)\n    def test_wrong_nesting_ignored(self):\n        \"\"\"PRD test 3: __ before scalar field is ignored.\n        \n        DATABASE__URL implies 'url' is a nested model, but it's a str.\n        Pydantic-settings ignores this malformed env var.\n        \"\"\"\n        settings = PayrollSettings()\n        assert settings.database.url == \"\"  # Uses default, env var ignored\n\n    @patch.dict(os.environ, {\n        \"BUVIS_PAYROLL_DATABASE__URL\": \"wrong\",\n        \"BUVIS_PAYROLL_DATABASE_URL\": \"correct\",\n    })\n    def test_correct_format_wins(self):\n        \"\"\"Correct format works even if wrong format also present.\"\"\"\n        settings = PayrollSettings()\n        assert settings.database.url == \"correct\"\n```\n\nThis validates PRD test case 3 and the \"When NOT to use __\" section.",
        "testStrategy": "Wrong __ usage has no effect, settings use defaults or correct format.",
        "priority": "high",
        "dependencies": [
          "41"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify test file structure exists from Task 42",
            "description": "Confirm tests/configuration/test_nested_env_settings.py exists with required imports (os, patch, pytest, PayrollSettings) as created in Task 42.",
            "dependencies": [],
            "details": "Check that tests/configuration/ directory exists and test_nested_env_settings.py has been created by Task 42 (dependency). If the file exists, verify it has imports for: os, unittest.mock.patch, pytest, and PayrollSettings from buvis.pybase.configuration.examples.nested_settings. This subtask is a prerequisite check - Task 42 should have already established this structure.",
            "status": "pending",
            "testStrategy": "Run `uv run python -c \"import tests.configuration.test_nested_env_settings\"` to verify file exists and imports resolve.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add TestIncorrectNestedDelimiter class scaffold",
            "description": "Create the TestIncorrectNestedDelimiter class structure in test_nested_env_settings.py with proper docstring explaining PRD test case 3.",
            "dependencies": [
              1
            ],
            "details": "Add to test_nested_env_settings.py:\n\n```python\nclass TestIncorrectNestedDelimiter:\n    \"\"\"Tests for PRD test case 3: __ before scalar field is ignored.\n    \n    DATABASE__URL implies 'url' is a nested model, but url is a str.\n    Pydantic-settings ignores malformed env vars that don't match model structure.\n    \"\"\"\n```\n\nThis class will contain tests validating the 'When NOT to use __' section of PRD-00005.",
            "status": "pending",
            "testStrategy": "File parses without syntax errors; class is discoverable by pytest --collect-only.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement test_wrong_nesting_ignored test method",
            "description": "Add test verifying BUVIS_PAYROLL_DATABASE__URL=wrong is ignored and settings use default empty string value.",
            "dependencies": [
              2
            ],
            "details": "Add test method with @patch.dict decorator using clear=True to ensure clean env:\n\n```python\n@patch.dict(os.environ, {\"BUVIS_PAYROLL_DATABASE__URL\": \"wrong\"}, clear=True)\ndef test_wrong_nesting_ignored(self):\n    \"\"\"PRD test 3: __ before scalar field is ignored.\n    \n    DATABASE__URL implies 'url' is a nested model, but it's a str.\n    Pydantic-settings ignores this malformed env var.\n    \"\"\"\n    settings = PayrollSettings()\n    assert settings.database.url == \"\"  # Uses default, env var ignored\n```\n\nThe clear=True ensures no other env vars interfere. The assertion verifies url remains empty (default) since __URL is invalid nesting.",
            "status": "pending",
            "testStrategy": "Run pytest on this specific test; passes when DATABASE__URL is ignored and url=='' (default).",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement test_correct_format_wins test method",
            "description": "Add test verifying correct DATABASE_URL format takes precedence when both wrong (__URL) and correct (_URL) formats are present.",
            "dependencies": [
              2
            ],
            "details": "Add test method with both env var formats set:\n\n```python\n@patch.dict(os.environ, {\n    \"BUVIS_PAYROLL_DATABASE__URL\": \"wrong\",\n    \"BUVIS_PAYROLL_DATABASE_URL\": \"correct\",\n})\ndef test_correct_format_wins(self):\n    \"\"\"Correct format works even if wrong format also present.\"\"\"\n    settings = PayrollSettings()\n    assert settings.database.url == \"correct\"\n```\n\nThis validates that pydantic-settings correctly ignores the malformed __URL and uses the properly-formatted _URL env var.",
            "status": "pending",
            "testStrategy": "Run pytest; test passes when settings.database.url == 'correct' despite wrong format also being set.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run tests and verify PRD-00005 test case 3 compliance",
            "description": "Execute all TestIncorrectNestedDelimiter tests and verify they pass, confirming PRD-00005 test case 3 (incorrect __ usage) is properly handled.",
            "dependencies": [
              3,
              4
            ],
            "details": "Run the full test suite for the new test class:\n\n```bash\nuv run pytest tests/configuration/test_nested_env_settings.py::TestIncorrectNestedDelimiter -v\n```\n\nVerify both tests pass:\n- test_wrong_nesting_ignored: confirms BUVIS_PAYROLL_DATABASE__URL is ignored\n- test_correct_format_wins: confirms correct format (DATABASE_URL) works alongside wrong format\n\nAlso run pre-commit to ensure code quality:\n```bash\nuv run pre-commit run --files tests/configuration/test_nested_env_settings.py\n```",
            "status": "pending",
            "testStrategy": "All tests pass: `uv run pytest tests/configuration/test_nested_env_settings.py::TestIncorrectNestedDelimiter -v` exits 0. Pre-commit passes.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:33:14.615Z"
      },
      {
        "id": "45",
        "title": "Test mixed underscore and double underscore parsing",
        "description": "Verify POOL__IDLE_TIMEOUT correctly parses both nesting and word separation.",
        "details": "Extend PoolSettings and add test:\n\n```python\n# In nested_settings.py, update PoolSettings:\nclass PoolSettings(BaseModel):\n    min_size: int = 5\n    max_size: int = 20\n    idle_timeout: int = 300  # seconds\n\n# In test file:\nclass TestMixedUnderscoreDelimiters:\n    @patch.dict(os.environ, {\"BUVIS_PAYROLL_DATABASE_POOL__IDLE_TIMEOUT\": \"600\"})\n    def test_underscore_word_sep_with_nesting(self):\n        \"\"\"PRD test 4: _ separates words, __ descends into model.\n        \n        POOL__IDLE_TIMEOUT:\n        - POOL__ -> descend into pool model\n        - IDLE_TIMEOUT -> field name with underscore word separator\n        \"\"\"\n        settings = PayrollSettings()\n        assert settings.database.pool.idle_timeout == 600\n```\n\nThis validates PRD test case 4 showing both `_` and `__` work together correctly.",
        "testStrategy": "idle_timeout field with underscore in name loads correctly via POOL__IDLE_TIMEOUT.",
        "priority": "high",
        "dependencies": [
          "41"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add idle_timeout field to PoolSettings model",
            "description": "Extend the PoolSettings class in nested_settings.py to include the idle_timeout field with default value of 300 seconds.",
            "dependencies": [],
            "details": "Edit `src/buvis/pybase/configuration/examples/nested_settings.py` and add to PoolSettings:\n\n```python\nclass PoolSettings(BaseModel):\n    min_size: int = 5\n    max_size: int = 20\n    idle_timeout: int = 300  # seconds\n```\n\nThe field uses underscore word separation (`idle_timeout`) which will be matched by env var `IDLE_TIMEOUT` after pydantic's automatic case normalization.",
            "status": "pending",
            "testStrategy": "Import PoolSettings and verify `PoolSettings().idle_timeout == 300`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create tests/configuration directory with test file",
            "description": "Create the test directory structure and test_nested_env_settings.py file for configuration tests.",
            "dependencies": [
              1
            ],
            "details": "Create `tests/configuration/` directory and `tests/configuration/test_nested_env_settings.py`:\n\n```python\nfrom __future__ import annotations\n\nimport os\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom buvis.pybase.configuration.examples.nested_settings import PayrollSettings\n```\n\nFollow existing test pattern from test_shell_adapter.py (class-based organization, pytest fixtures, Google-style docstrings).",
            "status": "pending",
            "testStrategy": "Run `pytest tests/configuration/ -v` - file should be discovered with no import errors",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add TestMixedUnderscoreDelimiters test class",
            "description": "Create the test class for validating mixed underscore and double underscore delimiter behavior.",
            "dependencies": [
              2
            ],
            "details": "Add to test_nested_env_settings.py:\n\n```python\nclass TestMixedUnderscoreDelimiters:\n    \"\"\"Tests for PRD test case 4: mixed _ and __ delimiters.\n    \n    Validates that:\n    - __ descends into nested models\n    - _ separates words within field names\n    - Both work correctly together in POOL__IDLE_TIMEOUT\n    \"\"\"\n```\n\nClass documents the PRD requirement being tested. Will contain multiple test methods for the mixed delimiter pattern.",
            "status": "pending",
            "testStrategy": "Class should be recognized by pytest as test class (starts with Test prefix)",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement test_underscore_word_sep_with_nesting test",
            "description": "Add the main test case that validates POOL__IDLE_TIMEOUT correctly parses both nesting (POOL__) and word separation (IDLE_TIMEOUT).",
            "dependencies": [
              3
            ],
            "details": "Add test method to TestMixedUnderscoreDelimiters:\n\n```python\n@patch.dict(os.environ, {\"BUVIS_PAYROLL_DATABASE_POOL__IDLE_TIMEOUT\": \"600\"})\ndef test_underscore_word_sep_with_nesting(self):\n    \"\"\"PRD test 4: _ separates words, __ descends into model.\n    \n    POOL__IDLE_TIMEOUT breakdown:\n    - POOL__ -> descend into pool model\n    - IDLE_TIMEOUT -> field name (pydantic normalizes to idle_timeout)\n    \"\"\"\n    settings = PayrollSettings()\n    assert settings.database.pool.idle_timeout == 600\n```\n\nThis validates the core requirement: env var override works with mixed delimiters.",
            "status": "pending",
            "testStrategy": "Run pytest on this specific test, verify it passes with env var setting idle_timeout to 600",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add default value verification test",
            "description": "Add a test that verifies the idle_timeout field defaults to 300 when no env var is set, confirming the model extension works.",
            "dependencies": [
              3
            ],
            "details": "Add test method to verify baseline behavior:\n\n```python\ndef test_idle_timeout_default_value(self):\n    \"\"\"Verify idle_timeout defaults to 300 seconds.\"\"\"\n    settings = PayrollSettings()\n    assert settings.database.pool.idle_timeout == 300\n```\n\nThis confirms the PoolSettings extension (subtask 1) is correct and provides a baseline to compare against the env var override test.",
            "status": "pending",
            "testStrategy": "Run test without env vars set, verify idle_timeout equals default 300",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:34:14.405Z"
      },
      {
        "id": "46",
        "title": "Implement nesting depth validator",
        "description": "Create validator that rejects settings models with nesting depth >5 levels.",
        "details": "Add to `src/buvis/pybase/configuration/validators.py`:\n\n```python\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom pydantic import BaseModel\n\nMAX_NESTING_DEPTH = 5\n\n\ndef get_model_depth(model_class: type[BaseModel], current_depth: int = 0) -> int:\n    \"\"\"Calculate max nesting depth of a Pydantic model.\"\"\"\n    if current_depth > MAX_NESTING_DEPTH:\n        return current_depth  # Short-circuit\n    \n    max_depth = current_depth\n    for field_info in model_class.model_fields.values():\n        annotation = field_info.annotation\n        # Check if field is a BaseModel subclass\n        if isinstance(annotation, type) and issubclass(annotation, BaseModel):\n            child_depth = get_model_depth(annotation, current_depth + 1)\n            max_depth = max(max_depth, child_depth)\n    \n    return max_depth\n\n\ndef validate_nesting_depth(model_class: type[BaseModel]) -> None:\n    \"\"\"Raise ValueError if model exceeds max nesting depth.\"\"\"\n    depth = get_model_depth(model_class)\n    if depth > MAX_NESTING_DEPTH:\n        raise ValueError(\n            f\"Model {model_class.__name__} has nesting depth {depth}, \"\n            f\"max allowed is {MAX_NESTING_DEPTH}\"\n        )\n```\n\nPer PRD security constraint: \"Validate depth: Reject unreasonably deep nesting (>5 levels)\".",
        "testStrategy": "Create 6-level nested model, verify validate_nesting_depth raises ValueError. 5-level model passes.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add pydantic dependency and create validators.py skeleton",
            "description": "Add pydantic to project dependencies and create the validators.py file with imports and MAX_NESTING_DEPTH constant.",
            "dependencies": [],
            "details": "Add `pydantic>=2.0,<3` to pyproject.toml dependencies. Create `src/buvis/pybase/configuration/validators.py` with:\n```python\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel\n\nMAX_NESTING_DEPTH = 5\n```\nRun `uv sync` to install the new dependency.",
            "status": "done",
            "testStrategy": "Verify pydantic imports successfully and MAX_NESTING_DEPTH constant equals 5.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:51:36.216Z"
          },
          {
            "id": 2,
            "title": "Implement get_model_depth recursive function",
            "description": "Create the get_model_depth function that calculates maximum nesting depth of a Pydantic model by recursing through BaseModel fields.",
            "dependencies": [
              1
            ],
            "details": "Add to validators.py:\n```python\ndef get_model_depth(model_class: type[BaseModel], current_depth: int = 0) -> int:\n    \"\"\"Calculate max nesting depth of a Pydantic model.\"\"\"\n    if current_depth > MAX_NESTING_DEPTH:\n        return current_depth  # Short-circuit\n    \n    max_depth = current_depth\n    for field_info in model_class.model_fields.values():\n        annotation = field_info.annotation\n        if isinstance(annotation, type) and issubclass(annotation, BaseModel):\n            child_depth = get_model_depth(annotation, current_depth + 1)\n            max_depth = max(max_depth, child_depth)\n    \n    return max_depth\n```\nShort-circuits at MAX_NESTING_DEPTH+1 for efficiency.",
            "status": "done",
            "testStrategy": "Test with flat model (depth 0), 3-level nested model, and 6-level nested model. Verify correct depth values returned.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:53:58.573Z"
          },
          {
            "id": 3,
            "title": "Implement validate_nesting_depth function",
            "description": "Create the validate_nesting_depth function that raises ValueError when model exceeds MAX_NESTING_DEPTH.",
            "dependencies": [
              2
            ],
            "details": "Add to validators.py:\n```python\ndef validate_nesting_depth(model_class: type[BaseModel]) -> None:\n    \"\"\"Raise ValueError if model exceeds max nesting depth.\"\"\"\n    depth = get_model_depth(model_class)\n    if depth > MAX_NESTING_DEPTH:\n        msg = (\n            f\"Model {model_class.__name__} has nesting depth {depth}, \"\n            f\"max allowed is {MAX_NESTING_DEPTH}\"\n        )\n        raise ValueError(msg)\n```\nError message includes model name, actual depth, and max allowed for debugging.",
            "status": "done",
            "testStrategy": "Verify ValueError raised for 6-level model with correct message. Verify no exception for 5-level model.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:53:58.617Z"
          },
          {
            "id": 4,
            "title": "Create comprehensive test suite for validators",
            "description": "Create tests/configuration/test_validators.py with test models at various nesting depths and test cases for both functions.",
            "dependencies": [
              3
            ],
            "details": "Create `tests/configuration/__init__.py` (empty) and `tests/configuration/test_validators.py`:\n```python\nimport pytest\nfrom pydantic import BaseModel\nfrom buvis.pybase.configuration.validators import (\n    MAX_NESTING_DEPTH, get_model_depth, validate_nesting_depth\n)\n\nclass Level5(BaseModel): value: int\nclass Level4(BaseModel): child: Level5\nclass Level3(BaseModel): child: Level4\nclass Level2(BaseModel): child: Level3\nclass Level1(BaseModel): child: Level2\nclass Level0Valid(BaseModel): child: Level1  # depth=5, valid\nclass Level6Invalid(BaseModel): child: Level0Valid  # depth=6, invalid\n\nclass TestGetModelDepth:\n    def test_flat_model_depth_zero(self): ...\n    def test_nested_model_depth_five(self): ...\n    def test_nested_model_depth_six(self): ...\n\nclass TestValidateNestingDepth:\n    def test_valid_depth_passes(self): ...\n    def test_invalid_depth_raises_valueerror(self): ...\n```",
            "status": "done",
            "testStrategy": "Run `uv run pytest tests/configuration/test_validators.py -v`. All tests must pass.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:53:58.662Z"
          },
          {
            "id": 5,
            "title": "Export validators from configuration __init__.py",
            "description": "Update the configuration module's __init__.py to export the validator functions and constant for public API access.",
            "dependencies": [
              3
            ],
            "details": "Update `src/buvis/pybase/configuration/__init__.py`:\n```python\nfrom .configuration import Configuration, ConfigurationKeyNotFoundError, cfg\nfrom .validators import MAX_NESTING_DEPTH, get_model_depth, validate_nesting_depth\n\n__all__ = [\n    \"Configuration\",\n    \"ConfigurationKeyNotFoundError\",\n    \"cfg\",\n    \"MAX_NESTING_DEPTH\",\n    \"get_model_depth\",\n    \"validate_nesting_depth\",\n]\n```\nThis enables `from buvis.pybase.configuration import validate_nesting_depth`.",
            "status": "done",
            "testStrategy": "Verify imports work: `from buvis.pybase.configuration import validate_nesting_depth, MAX_NESTING_DEPTH`",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:53:58.704Z"
          }
        ],
        "updatedAt": "2026-01-02T17:53:58.704Z"
      },
      {
        "id": "47",
        "title": "Test nesting depth validation",
        "description": "Write tests for depth validator accepting 5 levels and rejecting 6 levels.",
        "details": "Create `tests/configuration/test_validators.py`:\n\n```python\nimport pytest\nfrom pydantic import BaseModel\n\nfrom buvis.pybase.configuration.validators import (\n    MAX_NESTING_DEPTH,\n    get_model_depth,\n    validate_nesting_depth,\n)\n\n\nclass TestNestingDepthValidator:\n    def test_flat_model_depth_zero(self):\n        class Flat(BaseModel):\n            value: int = 0\n        assert get_model_depth(Flat) == 0\n\n    def test_one_level_nesting(self):\n        class Inner(BaseModel):\n            x: int = 0\n        class Outer(BaseModel):\n            inner: Inner = Inner()\n        assert get_model_depth(Outer) == 1\n\n    def test_five_levels_allowed(self):\n        # Create 5-level nesting\n        class L5(BaseModel): v: int = 0\n        class L4(BaseModel): l5: L5 = L5()\n        class L3(BaseModel): l4: L4 = L4()\n        class L2(BaseModel): l3: L3 = L3()\n        class L1(BaseModel): l2: L2 = L2()\n        \n        validate_nesting_depth(L1)  # Should not raise\n\n    def test_six_levels_rejected(self):\n        class L6(BaseModel): v: int = 0\n        class L5(BaseModel): l6: L6 = L6()\n        class L4(BaseModel): l5: L5 = L5()\n        class L3(BaseModel): l4: L4 = L4()\n        class L2(BaseModel): l3: L3 = L3()\n        class L1(BaseModel): l2: L2 = L2()\n        \n        with pytest.raises(ValueError, match=\"nesting depth 6\"):\n            validate_nesting_depth(L1)\n```",
        "testStrategy": "Run pytest, verify 5 levels pass and 6 levels raise ValueError.",
        "priority": "high",
        "dependencies": [
          "46"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test file structure for configuration validators",
            "description": "Create `tests/configuration/test_validators.py` with necessary imports and test class skeleton.",
            "dependencies": [],
            "details": "Create the test file with imports for pytest, BaseModel from pydantic, and the validator functions (get_model_depth, validate_nesting_depth, MAX_NESTING_DEPTH) from buvis.pybase.configuration.validators. Set up TestNestingDepthValidator class following the existing test patterns in test_shell_adapter.py.",
            "status": "pending",
            "testStrategy": "Verify file exists and imports succeed when validators module is available.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Test get_model_depth returns 0 for flat models",
            "description": "Write test verifying a BaseModel with no nested BaseModel fields has depth 0.",
            "dependencies": [
              1
            ],
            "details": "Add test_flat_model_depth_zero method that creates a simple Flat(BaseModel) with primitive fields only (e.g., value: int = 0). Assert get_model_depth(Flat) == 0. This validates the base case of the depth calculation algorithm.",
            "status": "pending",
            "testStrategy": "Run pytest, verify assertion passes for flat model returning depth 0.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Test get_model_depth returns correct depth for nested models",
            "description": "Write test verifying depth calculation for single-level nesting.",
            "dependencies": [
              1
            ],
            "details": "Add test_one_level_nesting method that creates Inner(BaseModel) with x: int = 0, and Outer(BaseModel) with inner: Inner = Inner(). Assert get_model_depth(Outer) == 1. This verifies the recursive depth counting works for simple nesting.",
            "status": "pending",
            "testStrategy": "Run pytest, verify assertion passes for one-level nested model returning depth 1.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Test validate_nesting_depth allows 5-level nesting",
            "description": "Write test verifying 5-level nested model passes validation without raising exception.",
            "dependencies": [
              1
            ],
            "details": "Add test_five_levels_allowed method that creates 5 nested BaseModel classes (L5 -> L4 -> L3 -> L2 -> L1). Call validate_nesting_depth(L1) and verify it completes without raising ValueError. This confirms MAX_NESTING_DEPTH=5 is correctly enforced as the upper bound.",
            "status": "pending",
            "testStrategy": "Run pytest, verify validate_nesting_depth(L1) does not raise for 5-level model.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test validate_nesting_depth rejects 6-level nesting",
            "description": "Write test verifying 6-level nested model raises ValueError with appropriate message.",
            "dependencies": [
              1
            ],
            "details": "Add test_six_levels_rejected method that creates 6 nested BaseModel classes (L6 -> L5 -> L4 -> L3 -> L2 -> L1). Use pytest.raises(ValueError, match='nesting depth 6') to verify validate_nesting_depth(L1) raises with the correct error message indicating the depth violation.",
            "status": "pending",
            "testStrategy": "Run pytest, verify ValueError raised with 'nesting depth 6' in message.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:35:11.687Z"
      },
      {
        "id": "48",
        "title": "Create field name matching documentation",
        "description": "Document that env var field names must exactly match model field names (no injection via nesting).",
        "details": "Per PRD: \"No injection via nesting: Field names from env vars must match model fields exactly.\"\n\nPydantic-settings already enforces this - unknown fields are ignored by default (or rejected with extra='forbid'). Document this behavior:\n\nAdd docstring to PayrollSettings:\n\n```python\nclass PayrollSettings(BaseSettings):\n    \"\"\"Example tool settings with nested models.\n    \n    Field Matching Rules:\n    - Env var field portions must match model field names exactly\n    - Unknown fields are rejected (extra='forbid')\n    - BUVIS_PAYROLL_FAKE_FIELD has no effect (no 'fake_field' in model)\n    \n    Security:\n    - Cannot inject arbitrary fields via env vars\n    - Model schema defines allowed fields, env vars can only set those\n    \"\"\"\n```\n\nAdd test to verify this is enforced.",
        "testStrategy": "Set BUVIS_PAYROLL_FAKE_FIELD=value, verify it has no effect on settings.",
        "priority": "medium",
        "dependencies": [
          "41"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add comprehensive docstring to PayrollSettings class",
            "description": "Update PayrollSettings docstring with field matching rules, security notes, and usage examples.",
            "dependencies": [],
            "details": "In `src/buvis/pybase/configuration/examples/nested_settings.py`, update PayrollSettings docstring to include:\n\n```python\nclass PayrollSettings(BaseSettings):\n    \"\"\"Example tool settings with nested models.\n    \n    Field Matching Rules:\n    - Env var field portions must match model field names exactly\n    - Unknown fields are rejected (extra='forbid')\n    - BUVIS_PAYROLL_FAKE_FIELD has no effect (no 'fake_field' in model)\n    \n    Security:\n    - Cannot inject arbitrary fields via env vars\n    - Model schema defines allowed fields, env vars can only set those\n    \n    Examples:\n        BUVIS_PAYROLL_DATABASE__URL=postgres://... -> settings.database.url\n        BUVIS_PAYROLL_UNKNOWN=value -> ignored/rejected\n    \"\"\"\n```\n\nThis documents pydantic-settings' built-in field matching behavior.",
            "status": "pending",
            "testStrategy": "Run `uv run python -c \"from buvis.pybase.configuration.examples import PayrollSettings; print(PayrollSettings.__doc__)\"` and verify docstring contains field matching rules.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create test file for field name matching validation",
            "description": "Create tests/configuration/examples/test_field_matching.py with test fixtures and structure.",
            "dependencies": [],
            "details": "Create `tests/configuration/examples/test_field_matching.py` with:\n\n```python\nfrom __future__ import annotations\n\nimport os\nfrom unittest.mock import patch\n\nimport pytest\nfrom pydantic import ValidationError\n\nfrom buvis.pybase.configuration.examples import PayrollSettings\n\n\n@pytest.fixture\ndef clean_env():\n    \"\"\"Fixture to ensure clean environment for each test.\"\"\"\n    env_vars = [k for k in os.environ if k.startswith('BUVIS_PAYROLL')]\n    with patch.dict(os.environ, {k: '' for k in env_vars}, clear=False):\n        for k in env_vars:\n            os.environ.pop(k, None)\n        yield\n```\n\nFollow project test patterns: class-based organization, pytest fixtures, Google docstrings.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/examples/test_field_matching.py --collect-only` to verify test file structure is valid.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add test for unknown field rejection",
            "description": "Add test verifying BUVIS_PAYROLL_FAKE_FIELD env var has no effect on settings.",
            "dependencies": [
              2
            ],
            "details": "Add to test_field_matching.py:\n\n```python\nclass TestFieldNameMatching:\n    \"\"\"Tests for field name matching behavior.\"\"\"\n\n    def test_unknown_env_var_ignored(self, clean_env):\n        \"\"\"Unknown field env vars have no effect on settings.\"\"\"\n        with patch.dict(os.environ, {'BUVIS_PAYROLL_FAKE_FIELD': 'injected'}):\n            settings = PayrollSettings()\n            # Verify no 'fake_field' attribute exists\n            assert not hasattr(settings, 'fake_field')\n            # Settings should still work with valid defaults\n            assert settings.database.pool.min_size == 5\n\n    def test_unknown_field_direct_construction_rejected(self):\n        \"\"\"Direct construction with unknown fields raises ValidationError.\"\"\"\n        with pytest.raises(ValidationError) as exc_info:\n            PayrollSettings(fake_field='value')\n        assert 'extra' in str(exc_info.value).lower()\n```\n\nThis confirms pydantic-settings' `extra='forbid'` behavior.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/examples/test_field_matching.py::TestFieldNameMatching::test_unknown_env_var_ignored -v` - should pass.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add test for exact field name matching requirement",
            "description": "Add test verifying that only exact field name matches work, typos are rejected or ignored.",
            "dependencies": [
              2
            ],
            "details": "Add to TestFieldNameMatching class:\n\n```python\n    def test_exact_field_name_required(self, clean_env):\n        \"\"\"Field names must match model fields exactly.\"\"\"\n        # Typo in field name should not work\n        with patch.dict(os.environ, {\n            'BUVIS_PAYROLL_DATABASE__URLX': 'postgres://bad',  # typo\n            'BUVIS_PAYROLL_DATABASE__URL': 'postgres://good',  # correct\n        }):\n            settings = PayrollSettings()\n            assert settings.database.url == 'postgres://good'\n\n    def test_case_insensitive_matching(self, clean_env):\n        \"\"\"Field matching is case-insensitive per model_config.\"\"\"\n        with patch.dict(os.environ, {\n            'buvis_payroll_database__url': 'postgres://lower',\n        }):\n            settings = PayrollSettings()\n            assert settings.database.url == 'postgres://lower'\n```\n\nThese tests verify pydantic-settings handles field matching correctly.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/examples/test_field_matching.py::TestFieldNameMatching -v` - all field matching tests should pass.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add security injection prevention test",
            "description": "Add test explicitly verifying that arbitrary field injection via env vars is not possible.",
            "dependencies": [
              3,
              4
            ],
            "details": "Add TestSecurityConstraints class to test_field_matching.py:\n\n```python\nclass TestSecurityConstraints:\n    \"\"\"Tests verifying security constraints on field injection.\"\"\"\n\n    def test_cannot_inject_internal_fields(self, clean_env):\n        \"\"\"Cannot inject pydantic internal fields via env vars.\"\"\"\n        with patch.dict(os.environ, {\n            'BUVIS_PAYROLL_MODEL_CONFIG': 'injected',\n            'BUVIS_PAYROLL___PRIVATE': 'injected',\n        }):\n            settings = PayrollSettings()\n            # Should not have injected attributes\n            assert not hasattr(settings, '__private')\n            # model_config should remain the class-level config\n            assert settings.model_config is PayrollSettings.model_config\n\n    def test_model_schema_defines_allowed_fields(self):\n        \"\"\"Model schema is the source of truth for allowed fields.\"\"\"\n        allowed_fields = set(PayrollSettings.model_fields.keys())\n        assert 'database' in allowed_fields\n        assert 'fake_field' not in allowed_fields\n```\n\nThis documents the security behavior mentioned in the task.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/examples/test_field_matching.py -v` - all tests including security constraints should pass.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "49",
        "title": "Export validators from configuration module",
        "description": "Update configuration/__init__.py to export depth validation utilities.",
        "details": "Update `src/buvis/pybase/configuration/__init__.py`:\n\n```python\nfrom .configuration import Configuration, cfg\nfrom .exceptions import ConfigurationKeyNotFoundError\nfrom .validators import (\n    MAX_NESTING_DEPTH,\n    get_model_depth,\n    validate_nesting_depth,\n)\n\n__all__ = [\n    \"Configuration\",\n    \"ConfigurationKeyNotFoundError\",\n    \"MAX_NESTING_DEPTH\",\n    \"cfg\",\n    \"get_model_depth\",\n    \"validate_nesting_depth\",\n]\n```\n\nNote: After tasks 1-40 complete, this will also include BuvisSettings, GlobalSettings, etc.",
        "testStrategy": "Verify import works: from buvis.pybase.configuration import validate_nesting_depth",
        "priority": "medium",
        "dependencies": [
          "46"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify validators module exists from task 46",
            "description": "Confirm that validators.py with MAX_NESTING_DEPTH, get_model_depth, and validate_nesting_depth exists before proceeding.",
            "dependencies": [],
            "details": "Check that src/buvis/pybase/configuration/validators.py exists and exports: MAX_NESTING_DEPTH constant, get_model_depth function, validate_nesting_depth function. This is a prerequisite from task 46.",
            "status": "pending",
            "testStrategy": "File exists check and symbol inspection",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Refactor ConfigurationKeyNotFoundError import",
            "description": "Change import of ConfigurationKeyNotFoundError from configuration.py to exceptions.py module.",
            "dependencies": [
              1
            ],
            "details": "Update __init__.py to import ConfigurationKeyNotFoundError from .exceptions instead of .configuration. Change from `from .configuration import Configuration, ConfigurationKeyNotFoundError, cfg` to separate imports.",
            "status": "pending",
            "testStrategy": "Verify import still works: from buvis.pybase.configuration import ConfigurationKeyNotFoundError",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add validators module import statement",
            "description": "Add import for MAX_NESTING_DEPTH, get_model_depth, and validate_nesting_depth from validators module.",
            "dependencies": [
              2
            ],
            "details": "Add import block: `from .validators import (MAX_NESTING_DEPTH, get_model_depth, validate_nesting_depth)`. Follow existing multi-line import style with parentheses.",
            "status": "pending",
            "testStrategy": "Python syntax check passes",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update __all__ with validator exports",
            "description": "Expand __all__ list to include MAX_NESTING_DEPTH, get_model_depth, and validate_nesting_depth.",
            "dependencies": [
              3
            ],
            "details": "Update __all__ to alphabetically sorted list: [\"Configuration\", \"ConfigurationKeyNotFoundError\", \"MAX_NESTING_DEPTH\", \"cfg\", \"get_model_depth\", \"validate_nesting_depth\"]. Keep alphabetical order per codebase convention.",
            "status": "pending",
            "testStrategy": "Verify __all__ contains all 6 exports in alphabetical order",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify all imports work correctly",
            "description": "Test that all exports can be imported from buvis.pybase.configuration.",
            "dependencies": [
              4
            ],
            "details": "Run verification: `from buvis.pybase.configuration import Configuration, ConfigurationKeyNotFoundError, MAX_NESTING_DEPTH, cfg, get_model_depth, validate_nesting_depth`. Ensure no ImportError.",
            "status": "pending",
            "testStrategy": "Run: python -c 'from buvis.pybase.configuration import validate_nesting_depth; print(\"OK\")'",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "50",
        "title": "Run full test suite and verify PRD compliance",
        "description": "Run all tests, verify all 4 PRD test cases pass, run pre-commit hooks.",
        "details": "Execute:\n\n```bash\nuv run pre-commit run --all-files\nuv run pytest tests/configuration/ -v\n```\n\nVerify PRD compliance checklist:\n1.  BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE=10 -> pool.min_size == 10\n2.  BUVIS_PAYROLL_DATABASE_URL=foo -> database.url == \"foo\"\n3.  BUVIS_PAYROLL_DATABASE__URL=foo -> ignored (no such nesting)\n4.  POOL__IDLE_TIMEOUT parses both nesting and underscore word sep\n5.  Depth >5 rejected\n6.  Unknown fields have no effect\n\nFix any failures before marking complete.",
        "testStrategy": "All pre-commit hooks pass, all pytest tests pass, PRD checklist verified.",
        "priority": "high",
        "dependencies": [
          "42",
          "43",
          "44",
          "45",
          "47",
          "48",
          "49"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Run pre-commit hooks on all files",
            "description": "Execute pre-commit hooks (ruff linter/formatter + pytest) across entire codebase to catch any issues.",
            "dependencies": [],
            "details": "Run `uv run pre-commit run --all-files`. This triggers ruff check, ruff format, and pytest hooks defined in .pre-commit-config.yaml. Fix any ruff lint errors or formatting issues before proceeding. Common issues: unused imports, missing type annotations, line length violations.",
            "status": "pending",
            "testStrategy": "All hooks pass with exit code 0. No Passed, no Failed output from ruff. Pytest shows all tests passing.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Run verbose pytest on configuration tests",
            "description": "Execute pytest specifically on tests/configuration/ directory with verbose output to verify all nested env var tests pass.",
            "dependencies": [
              1
            ],
            "details": "Run `uv run pytest tests/configuration/ -v`. This tests: TestNestedEnvResolution, TestDirectFieldResolution, TestInvalidNestingIgnored, TestDepthValidation, TestUnknownFieldsIgnored. Each test class maps to a PRD-00005 requirement. Verbose output shows individual test names and pass/fail status.",
            "status": "pending",
            "testStrategy": "All tests in tests/configuration/ pass. Output shows green checkmarks for each test case. Zero failures, zero errors.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Verify PRD test cases 1-4 compliance",
            "description": "Manually verify test coverage matches PRD-00005 requirements for nested env vars and direct fields.",
            "dependencies": [
              2
            ],
            "details": "Check test file covers: (1) BUVIS_PAYROLL_DATABASE_POOL__MIN_SIZE=10 -> pool.min_size==10, (2) BUVIS_PAYROLL_DATABASE_URL=foo -> database.url=='foo', (3) BUVIS_PAYROLL_DATABASE__URL=foo -> ignored, (4) POOL__IDLE_TIMEOUT parses both nesting and underscore word separation. Each must have a dedicated test method with correct assertions.",
            "status": "pending",
            "testStrategy": "Grep test file for each env var pattern. Each of the 4 PRD test cases has corresponding test method that passed in previous step.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Verify depth and unknown field constraints",
            "description": "Confirm security constraints are tested: depth >5 rejected, unknown fields have no effect.",
            "dependencies": [
              2
            ],
            "details": "Check tests include: (5) Nesting depth >5 raises ValidationError or is rejected, (6) Unknown env vars (e.g., BUVIS_PAYROLL_NONEXISTENT_FIELD) are silently ignored and don't affect settings. These are PRD-00005 security requirements. Verify test assertions match expected behavior.",
            "status": "pending",
            "testStrategy": "Test file contains test_depth_exceeds_limit and test_unknown_fields_ignored methods. Both passed in pytest run.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Fix failures and rerun until green",
            "description": "Address any test failures or pre-commit issues discovered, then rerun full suite to confirm all pass.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "If any failures in steps 1-4: (a) identify root cause from error output, (b) fix code in src/buvis/pybase/configuration/ or tests/configuration/, (c) rerun `uv run pre-commit run --all-files && uv run pytest tests/configuration/ -v`. Repeat until all pass. Document any fixes made. Only mark task 50 complete when everything is green.",
            "status": "pending",
            "testStrategy": "Final run of both commands exits 0. Pre-commit shows 'Passed' for all hooks. Pytest shows 100% pass rate with no failures or errors.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "51",
        "title": "Create PaymentRule example model",
        "description": "Create PaymentRule Pydantic BaseModel demonstrating JSON array parsing from env vars.",
        "details": "Create `src/buvis/pybase/configuration/examples/complex_env_settings.py`:\n\n```python\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass PaymentRule(BaseModel):\n    \"\"\"Individual payment rule parsed from JSON array.\"\"\"\n    rule_id: str\n    enabled: bool\n    bonus_pct: float | None = None\n\n\nclass PayrollSettings(BaseSettings):\n    \"\"\"Payroll settings demonstrating complex env parsing.\n    \n    Env vars:\n    - BUVIS_PAYROLL_PAYMENT_RULES: JSON array of PaymentRule objects\n    - BUVIS_PAYROLL_BATCH_SIZE: plain int\n    \n    Example:\n        export BUVIS_PAYROLL_PAYMENT_RULES='[{\"rule_id\":\"overtime\",\"enabled\":true}]'\n    \"\"\"\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_PAYROLL_\",\n        case_sensitive=False,\n        frozen=True,\n        extra=\"forbid\",\n    )\n    \n    payment_rules: list[PaymentRule] = Field(default_factory=list)\n    batch_size: int = 1000\n```\n\nPydantic auto-parses JSON for `list[PaymentRule]` typed fields.",
        "testStrategy": "Import PayrollSettings, set BUVIS_PAYROLL_PAYMENT_RULES='[{\"rule_id\":\"a\",\"enabled\":true}]', verify payment_rules is list of PaymentRule objects.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add pydantic and pydantic-settings dependencies",
            "description": "Add pydantic and pydantic-settings to project dependencies in pyproject.toml.",
            "dependencies": [],
            "details": "Add `pydantic>=2.0,<3` and `pydantic-settings>=2.0,<3` to the dependencies list in pyproject.toml. Run `uv sync` to install. These are required for BaseModel and BaseSettings with SettingsConfigDict support.",
            "status": "done",
            "testStrategy": "Run `uv run python -c \"from pydantic import BaseModel; from pydantic_settings import BaseSettings\"` to verify imports work.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:54:29.722Z"
          },
          {
            "id": 2,
            "title": "Create examples subpackage in configuration",
            "description": "Create the examples/ directory with __init__.py under src/buvis/pybase/configuration/.",
            "dependencies": [
              1
            ],
            "details": "Create `src/buvis/pybase/configuration/examples/__init__.py` with empty `__all__` list. This subpackage will contain example settings classes demonstrating various env var patterns.",
            "status": "done",
            "testStrategy": "Verify `from buvis.pybase.configuration.examples import *` works without error.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:54:29.763Z"
          },
          {
            "id": 3,
            "title": "Create PaymentRule BaseModel class",
            "description": "Create PaymentRule Pydantic BaseModel with rule_id, enabled, and optional bonus_pct fields.",
            "dependencies": [
              2
            ],
            "details": "In `src/buvis/pybase/configuration/examples/complex_env_settings.py`, create PaymentRule(BaseModel) with: rule_id: str, enabled: bool, bonus_pct: float | None = None. Use `from __future__ import annotations` and Google docstring format per project conventions.",
            "status": "done",
            "testStrategy": "Test PaymentRule(rule_id='test', enabled=True) instantiates correctly and bonus_pct defaults to None.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:57:49.903Z"
          },
          {
            "id": 4,
            "title": "Create PayrollSettings BaseSettings class",
            "description": "Create PayrollSettings class with BUVIS_PAYROLL_ prefix demonstrating list[PaymentRule] JSON parsing.",
            "dependencies": [
              3
            ],
            "details": "Add PayrollSettings(BaseSettings) with: model_config using env_prefix='BUVIS_PAYROLL_', case_sensitive=False, frozen=True, extra='forbid'. Fields: payment_rules: list[PaymentRule] = Field(default_factory=list), batch_size: int = 1000. Export both classes in examples/__init__.py.",
            "status": "done",
            "testStrategy": "Set BUVIS_PAYROLL_PAYMENT_RULES='[{\"rule_id\":\"a\",\"enabled\":true}]' and verify PayrollSettings().payment_rules is list of PaymentRule.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:57:49.943Z"
          },
          {
            "id": 5,
            "title": "Create test suite for complex_env_settings",
            "description": "Create tests/configuration/test_complex_env_settings.py with comprehensive tests for PaymentRule and PayrollSettings.",
            "dependencies": [
              4
            ],
            "details": "Create test file following project patterns (class-based, fixtures). Test classes: TestPaymentRule (defaults, validation), TestPayrollSettings (defaults, env parsing, JSON list parsing, immutability, batch_size override). Use @patch.dict(os.environ, {...}) for env var mocking. Ensure tests cover the JSON array parsing feature specifically.",
            "status": "done",
            "testStrategy": "Run `uv run pytest tests/configuration/test_complex_env_settings.py -v` and verify all tests pass.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T17:57:49.984Z"
          }
        ],
        "updatedAt": "2026-01-02T17:57:49.984Z"
      },
      {
        "id": "52",
        "title": "Test JSON list parsing from env var",
        "description": "Verify pydantic auto-parses JSON arrays for list[Model] fields.",
        "details": "Create `tests/configuration/test_complex_env_parsing.py`:\n\n```python\nimport os\nfrom unittest.mock import patch\n\nimport pytest\nfrom pydantic import ValidationError\n\nfrom buvis.pybase.configuration.examples.complex_env_settings import (\n    PayrollSettings,\n    PaymentRule,\n)\n\n\nclass TestJSONListParsing:\n    @patch.dict(os.environ, {\n        \"BUVIS_PAYROLL_PAYMENT_RULES\": '[{\"rule_id\":\"a\",\"enabled\":true}]'\n    })\n    def test_json_array_parsed(self):\n        \"\"\"PRD test 1: JSON array -> list[PaymentRule]\"\"\"\n        settings = PayrollSettings()\n        assert len(settings.payment_rules) == 1\n        assert settings.payment_rules[0].rule_id == \"a\"\n        assert settings.payment_rules[0].enabled is True\n\n    @patch.dict(os.environ, {\"BUVIS_PAYROLL_PAYMENT_RULES\": \"[]\"})\n    def test_empty_array(self):\n        \"\"\"PRD test 2: '[]' -> empty list\"\"\"\n        settings = PayrollSettings()\n        assert settings.payment_rules == []\n\n    @patch.dict(os.environ, {\"BUVIS_PAYROLL_BATCH_SIZE\": \"500\"})\n    def test_plain_scalar_still_works(self):\n        \"\"\"PRD test 5: Plain scalar 500 works for int fields\"\"\"\n        settings = PayrollSettings()\n        assert settings.batch_size == 500\n```",
        "testStrategy": "Run pytest on test_complex_env_parsing.py, verify JSON array and empty array tests pass.",
        "priority": "high",
        "dependencies": [
          "51"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test file with imports and TestJSONListParsing class",
            "description": "Create tests/configuration/test_complex_env_parsing.py with required imports and empty test class structure.",
            "dependencies": [],
            "details": "Create `tests/configuration/test_complex_env_parsing.py` with:\n```python\nfrom __future__ import annotations\n\nimport os\nfrom unittest.mock import patch\n\nimport pytest\nfrom pydantic import ValidationError\n\nfrom buvis.pybase.configuration.examples.complex_env_settings import (\n    PayrollSettings,\n    PaymentRule,\n)\n\n\nclass TestJSONListParsing:\n    \"\"\"Tests for JSON array parsing from env vars.\"\"\"\n    pass\n```\nFollow project patterns from test_shell_adapter.py.",
            "status": "pending",
            "testStrategy": "Run `uv run python -c \"import tests.configuration.test_complex_env_parsing\"` to verify imports resolve.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement test_json_array_parsed test",
            "description": "Add test verifying JSON array '[{\"rule_id\":\"a\",\"enabled\":true}]' parses to list[PaymentRule].",
            "dependencies": [
              1
            ],
            "details": "Add to TestJSONListParsing:\n```python\n@patch.dict(os.environ, {\n    \"BUVIS_PAYROLL_PAYMENT_RULES\": '[{\"rule_id\":\"a\",\"enabled\":true}]'\n})\ndef test_json_array_parsed(self):\n    \"\"\"PRD test 1: JSON array -> list[PaymentRule]\"\"\"\n    settings = PayrollSettings()\n    assert len(settings.payment_rules) == 1\n    assert settings.payment_rules[0].rule_id == \"a\"\n    assert settings.payment_rules[0].enabled is True\n```\nThis validates PRD-00006 test case 1.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_complex_env_parsing.py::TestJSONListParsing::test_json_array_parsed -v`",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement test_empty_array test",
            "description": "Add test verifying '[]' env var parses to empty list.",
            "dependencies": [
              1
            ],
            "details": "Add to TestJSONListParsing:\n```python\n@patch.dict(os.environ, {\"BUVIS_PAYROLL_PAYMENT_RULES\": \"[]\"})\ndef test_empty_array(self):\n    \"\"\"PRD test 2: '[]' -> empty list\"\"\"\n    settings = PayrollSettings()\n    assert settings.payment_rules == []\n```\nThis validates PRD-00006 test case 2: empty JSON array results in empty Python list.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_complex_env_parsing.py::TestJSONListParsing::test_empty_array -v`",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement test_plain_scalar_still_works test",
            "description": "Add test verifying plain scalar '500' still works for int fields alongside JSON parsing.",
            "dependencies": [
              1
            ],
            "details": "Add to TestJSONListParsing:\n```python\n@patch.dict(os.environ, {\"BUVIS_PAYROLL_BATCH_SIZE\": \"500\"})\ndef test_plain_scalar_still_works(self):\n    \"\"\"PRD test 5: Plain scalar 500 works for int fields\"\"\"\n    settings = PayrollSettings()\n    assert settings.batch_size == 500\n```\nThis validates PRD-00006 test case 5: simple scalars work normally even when complex JSON parsing is enabled for other fields.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_complex_env_parsing.py::TestJSONListParsing::test_plain_scalar_still_works -v`",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run full test suite and verify all tests pass",
            "description": "Execute pytest on test_complex_env_parsing.py and verify all 3 TestJSONListParsing tests pass.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Run `uv run pytest tests/configuration/test_complex_env_parsing.py -v` and verify output shows:\n- test_json_array_parsed PASSED\n- test_empty_array PASSED\n- test_plain_scalar_still_works PASSED\n\nIf any test fails, debug the issue - likely env var name mismatch or PayrollSettings model config issue from Task 51.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_complex_env_parsing.py -v` - all 3 tests in TestJSONListParsing must pass with exit code 0.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:36:28.732Z"
      },
      {
        "id": "53",
        "title": "Test JSON parse error handling",
        "description": "Verify invalid JSON raises ValidationError with parse error details.",
        "details": "Add to `tests/configuration/test_complex_env_parsing.py`:\n\n```python\nclass TestJSONParseErrors:\n    @patch.dict(os.environ, {\n        \"BUVIS_PAYROLL_PAYMENT_RULES\": \"[{broken\"\n    })\n    def test_invalid_json_raises(self):\n        \"\"\"PRD test 3: '[{broken' -> ValidationError with JSON parse error\"\"\"\n        with pytest.raises(ValidationError) as exc_info:\n            PayrollSettings()\n        # Verify error mentions JSON parsing issue\n        error_str = str(exc_info.value)\n        assert \"payment_rules\" in error_str.lower() or \"json\" in error_str.lower()\n\n    @patch.dict(os.environ, {\n        \"BUVIS_PAYROLL_PAYMENT_RULES\": '[{\"rule_id\":123}]'\n    })\n    def test_wrong_type_in_json(self):\n        \"\"\"PRD test 4: rule_id:123 (wrong type) -> ValidationError\"\"\"\n        with pytest.raises(ValidationError) as exc_info:\n            PayrollSettings()\n        # Should mention type error for rule_id\n        assert \"rule_id\" in str(exc_info.value)\n\n    @patch.dict(os.environ, {\n        \"BUVIS_PAYROLL_PAYMENT_RULES\": '[{\"enabled\":true}]'\n    })\n    def test_missing_required_field(self):\n        \"\"\"PRD: Missing field -> ValidationError\"\"\"\n        with pytest.raises(ValidationError) as exc_info:\n            PayrollSettings()\n        assert \"rule_id\" in str(exc_info.value)\n```\n\nThese test all error cases from PRD error table.",
        "testStrategy": "Run pytest, verify all 3 error case tests raise ValidationError with appropriate messages.",
        "priority": "high",
        "dependencies": [
          "51"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test_complex_env_parsing.py with imports and fixtures",
            "description": "Create the test file with required imports (os, pytest, patch.dict) and import PayrollSettings and ValidationError from the example models.",
            "dependencies": [],
            "details": "Create `tests/configuration/test_complex_env_parsing.py`. Add imports: os, pytest, unittest.mock.patch, pydantic.ValidationError. Import PayrollSettings from `buvis.pybase.configuration.examples.nested_settings`. Follow existing test pattern from test_shell_adapter.py using class-based organization.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_complex_env_parsing.py --collect-only` to verify file is valid and imports resolve.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add test for invalid JSON syntax error",
            "description": "Test that malformed JSON like '[{broken' in BUVIS_PAYROLL_PAYMENT_RULES raises ValidationError with JSON parse error details.",
            "dependencies": [
              1
            ],
            "details": "Add TestJSONParseErrors class with test_invalid_json_raises. Use @patch.dict(os.environ, {\"BUVIS_PAYROLL_PAYMENT_RULES\": \"[{broken\"}) to set malformed JSON. Assert pytest.raises(ValidationError). Verify error string contains 'payment_rules' or 'json' to confirm proper error context. This covers PRD test case 3.",
            "status": "pending",
            "testStrategy": "Run pytest, verify ValidationError is raised and error message mentions JSON parsing issue.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add test for wrong type in JSON value",
            "description": "Test that JSON with wrong type (rule_id:123 as int instead of str) raises ValidationError with type mismatch details.",
            "dependencies": [
              1
            ],
            "details": "Add test_wrong_type_in_json to TestJSONParseErrors. Use @patch.dict with '[{\"rule_id\":123}]' (int instead of str). Assert ValidationError is raised. Verify error mentions 'rule_id' field. This covers PRD test case 4 from the error table - wrong type validation.",
            "status": "pending",
            "testStrategy": "Run pytest, verify ValidationError raised with 'rule_id' in error message indicating type validation failure.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add test for missing required field in JSON",
            "description": "Test that JSON missing required field (e.g., only 'enabled' without 'rule_id') raises ValidationError mentioning the missing field.",
            "dependencies": [
              1
            ],
            "details": "Add test_missing_required_field to TestJSONParseErrors. Use @patch.dict with '[{\"enabled\":true}]' - valid JSON but missing required rule_id field. Assert ValidationError raised. Verify 'rule_id' in error message. This covers PRD 'Missing field' error case from error table.",
            "status": "pending",
            "testStrategy": "Run pytest, verify ValidationError raised with clear indication that 'rule_id' field is required but missing.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run full test suite and verify all error cases pass",
            "description": "Run pytest on test_complex_env_parsing.py to verify all 3 JSON error case tests raise appropriate ValidationError with descriptive messages.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Run `uv run pytest tests/configuration/test_complex_env_parsing.py -v` to execute all tests. Verify all 3 error case tests pass: invalid JSON syntax, wrong type, missing field. Each should raise ValidationError with appropriate field/context in error message. Consider adding brief docstrings matching PRD test case numbers.",
            "status": "pending",
            "testStrategy": "All 3 tests pass. Error messages are descriptive and match PRD error table expectations.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:39:06.726Z"
      },
      {
        "id": "54",
        "title": "Create dict field example (HCM headers)",
        "description": "Create example showing JSON dict parsing for dict[str, str] fields.",
        "details": "Add to `complex_env_settings.py`:\n\n```python\nclass HCMSettings(BaseSettings):\n    \"\"\"HCM settings demonstrating dict parsing from JSON.\n    \n    Env vars:\n    - BUVIS_HCM_HEADERS: JSON object for HTTP headers\n    \n    Example:\n        export BUVIS_HCM_HEADERS='{\"Authorization\":\"Bearer xxx\",\"X-Api-Key\":\"yyy\"}'\n    \"\"\"\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_HCM_\",\n        case_sensitive=False,\n        frozen=True,\n        extra=\"forbid\",\n    )\n    \n    headers: dict[str, str] = Field(default_factory=dict)\n    api_url: str = \"\"\n```\n\nPydantic auto-parses JSON objects for dict-typed fields.",
        "testStrategy": "Set BUVIS_HCM_HEADERS='{\"X-Api-Key\":\"test\"}', verify headers dict contains the key-value pair.",
        "priority": "high",
        "dependencies": [
          "51"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add HCMSettings class to complex_env_settings.py",
            "description": "Create HCMSettings BaseSettings class with dict[str, str] headers field and api_url field.",
            "dependencies": [],
            "details": "Add to `src/buvis/pybase/configuration/examples/complex_env_settings.py`:\n\n```python\nclass HCMSettings(BaseSettings):\n    \"\"\"HCM settings demonstrating dict parsing from JSON.\n    \n    Env vars:\n    - BUVIS_HCM_HEADERS: JSON object for HTTP headers\n    - BUVIS_HCM_API_URL: API endpoint URL\n    \n    Example:\n        export BUVIS_HCM_HEADERS='{\"Authorization\":\"Bearer xxx\",\"X-Api-Key\":\"yyy\"}'\n    \"\"\"\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_HCM_\",\n        case_sensitive=False,\n        frozen=True,\n        extra=\"forbid\",\n    )\n    \n    headers: dict[str, str] = Field(default_factory=dict)\n    api_url: str = \"\"\n```\n\nUse `from __future__ import annotations`. Add Field import if missing.",
            "status": "pending",
            "testStrategy": "Import HCMSettings from buvis.pybase.configuration.examples.complex_env_settings without error.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Export HCMSettings from examples module __init__.py",
            "description": "Add HCMSettings to the examples module exports for external access.",
            "dependencies": [
              1
            ],
            "details": "Update `src/buvis/pybase/configuration/examples/__init__.py` to export HCMSettings:\n\n```python\nfrom .complex_env_settings import HCMSettings\n\n__all__ = [..., \"HCMSettings\"]\n```\n\nFollow existing export patterns. If __init__.py doesn't exist yet (depends on Task 51), create it with PayrollSettings + HCMSettings exports.",
            "status": "pending",
            "testStrategy": "Run: python -c 'from buvis.pybase.configuration.examples import HCMSettings; print(\"OK\")'",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add HCMSettings tests to test_complex_env_settings.py",
            "description": "Create TestHCMSettings class with tests for dict parsing, defaults, and immutability.",
            "dependencies": [
              1
            ],
            "details": "Add to `tests/configuration/test_complex_env_settings.py`:\n\n```python\nclass TestHCMSettings:\n    def test_headers_default_empty_dict(self):\n        settings = HCMSettings()\n        assert settings.headers == {}\n    \n    def test_api_url_default_empty(self):\n        settings = HCMSettings()\n        assert settings.api_url == \"\"\n    \n    def test_json_dict_parsing_from_env(self):\n        with patch.dict(os.environ, {\"BUVIS_HCM_HEADERS\": '{\"X-Api-Key\":\"test123\"}\"'}):\n            settings = HCMSettings()\n            assert settings.headers == {\"X-Api-Key\": \"test123\"}\n    \n    def test_immutable(self):\n        settings = HCMSettings()\n        with pytest.raises(ValidationError):\n            settings.api_url = \"changed\"\n```\n\nUse @patch.dict(os.environ) for env mocking. Follow class-based test pattern.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_complex_env_settings.py::TestHCMSettings -v` - all tests pass.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Test multi-key dict parsing from env var",
            "description": "Add test verifying multiple key-value pairs parse correctly from JSON env var.",
            "dependencies": [
              3
            ],
            "details": "Add test method to TestHCMSettings:\n\n```python\ndef test_multiple_headers_from_env(self):\n    headers_json = '{\"Authorization\":\"Bearer abc\",\"X-Api-Key\":\"xyz\",\"Content-Type\":\"application/json\"}'\n    with patch.dict(os.environ, {\"BUVIS_HCM_HEADERS\": headers_json}):\n        settings = HCMSettings()\n        assert settings.headers[\"Authorization\"] == \"Bearer abc\"\n        assert settings.headers[\"X-Api-Key\"] == \"xyz\"\n        assert settings.headers[\"Content-Type\"] == \"application/json\"\n        assert len(settings.headers) == 3\n```\n\nTests JSON object with 3 keys to verify full dict parsing works.",
            "status": "pending",
            "testStrategy": "Run test method, verify all 3 header values are correctly parsed and dict has exactly 3 entries.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify HCMSettings integration and run full test suite",
            "description": "Run pre-commit hooks and full test suite to verify HCMSettings works correctly.",
            "dependencies": [
              4
            ],
            "details": "Run validation:\n\n1. `uv run pre-commit run --all-files` - verify lint passes\n2. `uv run pytest tests/configuration/test_complex_env_settings.py -v` - all HCMSettings tests pass\n3. Quick integration check:\n   ```bash\n   BUVIS_HCM_HEADERS='{\"X-Api-Key\":\"test\"}' python -c \"\n   from buvis.pybase.configuration.examples import HCMSettings\n   s = HCMSettings()\n   assert s.headers == {'X-Api-Key': 'test'}\n   print('Dict parsing OK')\n   \"\n   ```\n\nFix any failing tests or lint issues.",
            "status": "pending",
            "testStrategy": "All pre-commit hooks pass, all pytest tests pass, integration check prints 'Dict parsing OK'.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:41:12.865Z"
      },
      {
        "id": "55",
        "title": "Test JSON dict parsing from env var",
        "description": "Verify pydantic auto-parses JSON objects for dict fields.",
        "details": "Add to `tests/configuration/test_complex_env_parsing.py`:\n\n```python\nfrom buvis.pybase.configuration.examples.complex_env_settings import HCMSettings\n\n\nclass TestJSONDictParsing:\n    @patch.dict(os.environ, {\n        \"BUVIS_HCM_HEADERS\": '{\"Authorization\":\"Bearer xxx\",\"X-Api-Key\":\"yyy\"}'\n    })\n    def test_json_dict_parsed(self):\n        \"\"\"PRD dict example: JSON object -> dict[str, str]\"\"\"\n        settings = HCMSettings()\n        assert settings.headers[\"Authorization\"] == \"Bearer xxx\"\n        assert settings.headers[\"X-Api-Key\"] == \"yyy\"\n\n    @patch.dict(os.environ, {\"BUVIS_HCM_HEADERS\": \"{}\"})\n    def test_empty_dict(self):\n        settings = HCMSettings()\n        assert settings.headers == {}\n\n    @patch.dict(os.environ, {\"BUVIS_HCM_HEADERS\": '{\"key\":123}'})\n    def test_wrong_value_type_raises(self):\n        \"\"\"dict[str, str] rejects int value\"\"\"\n        with pytest.raises(ValidationError):\n            HCMSettings()\n```",
        "testStrategy": "All dict parsing tests pass including type validation.",
        "priority": "high",
        "dependencies": [
          "54"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify test file and HCMSettings exist from dependencies",
            "description": "Confirm prerequisite artifacts from tasks 52 and 54 are in place before adding dict tests.",
            "dependencies": [],
            "details": "Check that `tests/configuration/test_complex_env_parsing.py` exists (from task 52) and that `HCMSettings` class with `headers: dict[str, str]` field exists in `src/buvis/pybase/configuration/examples/complex_env_settings.py` (from task 54). These are blocking dependencies.",
            "status": "pending",
            "testStrategy": "File existence checks; import HCMSettings succeeds without error.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add HCMSettings import to test file",
            "description": "Update imports in test_complex_env_parsing.py to include HCMSettings class.",
            "dependencies": [
              1
            ],
            "details": "Add `HCMSettings` to the existing import statement from `buvis.pybase.configuration.examples.complex_env_settings`. Ensure `os`, `patch`, `pytest`, and `ValidationError` imports already present from task 52.",
            "status": "pending",
            "testStrategy": "Import statement parses without syntax or import errors.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement test_json_dict_parsed for valid JSON object",
            "description": "Create TestJSONDictParsing class with happy-path test for JSON dict parsing.",
            "dependencies": [
              2
            ],
            "details": "Add `TestJSONDictParsing` class. Implement `test_json_dict_parsed` with `@patch.dict(os.environ, {\"BUVIS_HCM_HEADERS\": '{\"Authorization\":\"Bearer xxx\",\"X-Api-Key\":\"yyy\"}'})`. Assert `settings.headers[\"Authorization\"] == \"Bearer xxx\"` and `settings.headers[\"X-Api-Key\"] == \"yyy\"`.",
            "status": "pending",
            "testStrategy": "pytest test passes; dict contains both expected key-value pairs.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement test_empty_dict for empty JSON object",
            "description": "Add test verifying empty JSON object parses to empty dict.",
            "dependencies": [
              3
            ],
            "details": "Add `test_empty_dict` method to `TestJSONDictParsing`. Use `@patch.dict(os.environ, {\"BUVIS_HCM_HEADERS\": \"{}\"})`. Assert `settings.headers == {}`.",
            "status": "pending",
            "testStrategy": "pytest test passes; headers field is an empty dict.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement test_wrong_value_type_raises for type validation",
            "description": "Add test verifying dict[str, str] rejects non-string values.",
            "dependencies": [
              3
            ],
            "details": "Add `test_wrong_value_type_raises` method to `TestJSONDictParsing`. Use `@patch.dict(os.environ, {\"BUVIS_HCM_HEADERS\": '{\"key\":123}'})`. Assert `pytest.raises(ValidationError)` when instantiating `HCMSettings()` with integer value instead of string.",
            "status": "pending",
            "testStrategy": "pytest test passes; ValidationError raised for int value in dict[str, str] field.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:42:06.862Z"
      },
      {
        "id": "56",
        "title": "Implement JSON size limit validator",
        "description": "Create validator to reject JSON env values exceeding 64KB.",
        "details": "Add to `src/buvis/pybase/configuration/validators.py`:\n\n```python\nimport os\nfrom typing import Any\n\nfrom pydantic import field_validator, model_validator\n\nMAX_JSON_ENV_SIZE = 64 * 1024  # 64KB\n\n\ndef validate_json_env_size(env_var_name: str) -> None:\n    \"\"\"Reject env vars with JSON values exceeding size limit.\n    \n    Args:\n        env_var_name: Name of env var to check\n        \n    Raises:\n        ValueError: If value exceeds MAX_JSON_ENV_SIZE\n    \"\"\"\n    value = os.environ.get(env_var_name, \"\")\n    if len(value.encode(\"utf-8\")) > MAX_JSON_ENV_SIZE:\n        raise ValueError(\n            f\"{env_var_name} exceeds max size of {MAX_JSON_ENV_SIZE} bytes\"\n        )\n```\n\nPer PRD security: \"Size limits: Reject unreasonably large JSON values (>64KB)\"\n\nUsage: Call in @model_validator(mode='before') or as explicit check before instantiation.",
        "testStrategy": "Create 65KB string, verify validate_json_env_size raises ValueError. 64KB string passes.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create validators.py with MAX_JSON_ENV_SIZE constant",
            "description": "Create the validators.py file in src/buvis/pybase/configuration/ with the size limit constant and necessary imports.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/validators.py` with:\n```python\nfrom __future__ import annotations\n\nimport os\n\nMAX_JSON_ENV_SIZE = 64 * 1024  # 64KB\n```\nFollow existing codebase patterns: use `from __future__ import annotations` at top.",
            "status": "done",
            "testStrategy": "Verify constant value equals 65536 bytes (64 * 1024).",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:00:24.213Z"
          },
          {
            "id": 2,
            "title": "Add JsonEnvSizeError to exceptions.py",
            "description": "Add a custom exception class for JSON environment variable size validation failures.",
            "dependencies": [],
            "details": "Add to `src/buvis/pybase/configuration/exceptions.py`:\n```python\nclass JsonEnvSizeError(ValueError):\n    \"\"\"JSON environment variable exceeds size limit.\"\"\"\n\n    def __init__(self, env_var_name: str, size: int, max_size: int) -> None:\n        msg = f\"{env_var_name} ({size} bytes) exceeds max size of {max_size} bytes\"\n        super().__init__(msg)\n        self.env_var_name = env_var_name\n        self.size = size\n        self.max_size = max_size\n```\nProvides clear error message with details for debugging.",
            "status": "done",
            "testStrategy": "Test exception instantiation and verify message format contains var name and sizes.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:00:24.261Z"
          },
          {
            "id": 3,
            "title": "Implement validate_json_env_size function",
            "description": "Implement the core validation function that checks environment variable size against the 64KB limit.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add to `validators.py`:\n```python\nfrom buvis.pybase.configuration.exceptions import JsonEnvSizeError\n\ndef validate_json_env_size(env_var_name: str) -> None:\n    \"\"\"Reject env vars with JSON values exceeding size limit.\n\n    Args:\n        env_var_name: Name of env var to check.\n\n    Raises:\n        JsonEnvSizeError: If value exceeds MAX_JSON_ENV_SIZE.\n    \"\"\"\n    value = os.environ.get(env_var_name, \"\")\n    size = len(value.encode(\"utf-8\"))\n    if size > MAX_JSON_ENV_SIZE:\n        raise JsonEnvSizeError(env_var_name, size, MAX_JSON_ENV_SIZE)\n```\nUses UTF-8 encoding for accurate byte count.",
            "status": "done",
            "testStrategy": "Test with 64KB string (passes) and 65KB string (raises JsonEnvSizeError). Test empty/missing env var.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:00:24.303Z"
          },
          {
            "id": 4,
            "title": "Create test_validators.py with size validation tests",
            "description": "Create comprehensive tests for the JSON size validator in tests/configuration/.",
            "dependencies": [
              3
            ],
            "details": "Create `tests/configuration/test_validators.py`:\n```python\nimport os\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom buvis.pybase.configuration.validators import (\n    MAX_JSON_ENV_SIZE,\n    validate_json_env_size,\n)\nfrom buvis.pybase.configuration.exceptions import JsonEnvSizeError\n\n\nclass TestMaxJsonEnvSizeConstant:\n    def test_value_is_64kb(self) -> None:\n        assert MAX_JSON_ENV_SIZE == 64 * 1024\n\n\nclass TestValidateJsonEnvSize:\n    def test_passes_for_empty_env_var(self) -> None:\n        with patch.dict(os.environ, {}, clear=True):\n            validate_json_env_size(\"MISSING_VAR\")\n\n    def test_passes_at_exact_limit(self) -> None:\n        value = \"a\" * MAX_JSON_ENV_SIZE\n        with patch.dict(os.environ, {\"TEST_VAR\": value}):\n            validate_json_env_size(\"TEST_VAR\")\n\n    def test_raises_over_limit(self) -> None:\n        value = \"a\" * (MAX_JSON_ENV_SIZE + 1)\n        with patch.dict(os.environ, {\"TEST_VAR\": value}):\n            with pytest.raises(JsonEnvSizeError) as exc:\n                validate_json_env_size(\"TEST_VAR\")\n            assert exc.value.env_var_name == \"TEST_VAR\"\n\n    def test_utf8_multibyte_chars_counted_correctly(self) -> None:\n        # 3-byte UTF-8 chars: 21846 chars = 65538 bytes > 64KB\n        value = \"\\u4e2d\" * 21846\n        with patch.dict(os.environ, {\"TEST_VAR\": value}):\n            with pytest.raises(JsonEnvSizeError):\n                validate_json_env_size(\"TEST_VAR\")\n```",
            "status": "done",
            "testStrategy": "Run pytest on test_validators.py, verify all tests pass including edge cases.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:00:24.527Z"
          },
          {
            "id": 5,
            "title": "Export validator and exception in __init__.py",
            "description": "Update configuration/__init__.py to export the new validator function, constant, and exception.",
            "dependencies": [
              3
            ],
            "details": "Update `src/buvis/pybase/configuration/__init__.py`:\n```python\nfrom .configuration import Configuration, ConfigurationKeyNotFoundError, cfg\nfrom .exceptions import JsonEnvSizeError\nfrom .validators import MAX_JSON_ENV_SIZE, validate_json_env_size\n\n__all__ = [\n    \"Configuration\",\n    \"ConfigurationKeyNotFoundError\",\n    \"JsonEnvSizeError\",\n    \"MAX_JSON_ENV_SIZE\",\n    \"cfg\",\n    \"validate_json_env_size\",\n]\n```\nEnables clean imports: `from buvis.pybase.configuration import validate_json_env_size`",
            "status": "done",
            "testStrategy": "Verify imports work: `from buvis.pybase.configuration import validate_json_env_size, MAX_JSON_ENV_SIZE, JsonEnvSizeError`",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:00:24.924Z"
          }
        ],
        "updatedAt": "2026-01-02T18:00:24.924Z"
      },
      {
        "id": "57",
        "title": "Create SecureSettings mixin with size validation",
        "description": "Create mixin class that validates JSON field sizes at model instantiation.",
        "details": "Add to `complex_env_settings.py` or `validators.py`:\n\n```python\nfrom pydantic import model_validator\nfrom pydantic_settings import BaseSettings\n\n\nclass SecureSettingsMixin:\n    \"\"\"Mixin adding security validations for settings.\n    \n    Validates:\n    - JSON env values don't exceed 64KB\n    - Complex types come from validated JSON, not eval()\n    \"\"\"\n    \n    @model_validator(mode=\"before\")\n    @classmethod\n    def validate_json_sizes(cls, data: dict) -> dict:\n        \"\"\"Check env var sizes before parsing.\"\"\"\n        import os\n        prefix = getattr(cls.model_config, \"env_prefix\", \"\")\n        \n        for key, value in os.environ.items():\n            if key.startswith(prefix) and len(value.encode()) > MAX_JSON_ENV_SIZE:\n                raise ValueError(\n                    f\"{key} exceeds max size of {MAX_JSON_ENV_SIZE} bytes\"\n                )\n        return data\n\n\nclass SecurePayrollSettings(SecureSettingsMixin, BaseSettings):\n    \"\"\"PayrollSettings with size validation.\"\"\"\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_PAYROLL_\",\n        frozen=True,\n        extra=\"forbid\",\n    )\n    payment_rules: list[PaymentRule] = Field(default_factory=list)\n```\n\nNote: model_validator runs before field parsing, allowing size check first.",
        "testStrategy": "Set oversized BUVIS_PAYROLL_PAYMENT_RULES (>64KB), verify SecurePayrollSettings raises ValueError on instantiation.",
        "priority": "medium",
        "dependencies": [
          "56"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add pydantic-settings dependency to pyproject.toml",
            "description": "Add pydantic-settings package as a project dependency since it's not currently in pyproject.toml but required for BaseSettings and model_validator functionality.",
            "dependencies": [],
            "details": "Add `pydantic-settings>=2.0.0,<3` to the dependencies list in pyproject.toml. Run `uv sync --all-groups` after adding. The package provides BaseSettings class and SettingsConfigDict needed for environment-based configuration.",
            "status": "pending",
            "testStrategy": "Run `uv sync --all-groups` and verify `from pydantic_settings import BaseSettings` imports successfully in Python REPL.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create secure_settings.py with MAX_JSON_ENV_SIZE constant",
            "description": "Create new file src/buvis/pybase/configuration/secure_settings.py with the 64KB size limit constant and necessary imports.",
            "dependencies": [
              1
            ],
            "details": "Create secure_settings.py with:\n```python\nfrom __future__ import annotations\n\nMAX_JSON_ENV_SIZE = 64 * 1024  # 64KB limit for JSON env vars\n```\nFollow existing patterns: use `from __future__ import annotations`, add module docstring explaining security rationale.",
            "status": "pending",
            "testStrategy": "Import MAX_JSON_ENV_SIZE and verify it equals 65536 bytes.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement SecureSettingsMixin class with model_validator",
            "description": "Add SecureSettingsMixin class to secure_settings.py with validate_json_sizes model_validator that checks env var sizes before parsing.",
            "dependencies": [
              2
            ],
            "details": "Implement mixin class in secure_settings.py:\n- Use `@model_validator(mode='before')` decorator\n- Get env_prefix from cls.model_config\n- Iterate os.environ, check prefixed vars against MAX_JSON_ENV_SIZE\n- Raise ValueError with descriptive message if exceeded\n- Return data dict unchanged if valid\nFollow Google docstring format per project conventions.",
            "status": "pending",
            "testStrategy": "Unit test: mock os.environ with oversized value, verify ValueError raised with correct message.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create SecurePayrollSettings example class",
            "description": "Add SecurePayrollSettings class demonstrating SecureSettingsMixin usage with BUVIS_PAYROLL_ prefix and PaymentRule list field.",
            "dependencies": [
              3
            ],
            "details": "Add to secure_settings.py:\n- Define PaymentRule type (TypedDict or Pydantic model)\n- Create SecurePayrollSettings(SecureSettingsMixin, BaseSettings) with:\n  - env_prefix='BUVIS_PAYROLL_'\n  - frozen=True, extra='forbid'\n  - payment_rules: list[PaymentRule] field with default_factory=list\nExport both classes in configuration/__init__.py.",
            "status": "pending",
            "testStrategy": "Test: instantiate SecurePayrollSettings with valid JSON env var, verify payment_rules parsed correctly.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create tests/configuration/test_secure_settings.py",
            "description": "Create comprehensive test suite for SecureSettingsMixin covering size validation, normal operation, and edge cases.",
            "dependencies": [
              4
            ],
            "details": "Create test file following existing test patterns (class-based, pytest-mock):\n- TestSecureSettingsMixin class with:\n  - test_validates_oversized_env_raises: set >64KB env var, verify ValueError\n  - test_allows_valid_sized_env: set <64KB env var, verify passes\n  - test_ignores_non_prefixed_env: oversized non-prefixed var allowed\n  - test_validates_at_instantiation: verify validation runs before field parsing\nUse @patch.dict(os.environ, ...) for env var mocking.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_secure_settings.py -v` and verify all tests pass.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "58",
        "title": "Implement sanitized logging for settings",
        "description": "Create __repr__ that masks potentially sensitive JSON values.",
        "details": "Add sanitized repr to settings base:\n\n```python\nimport re\n\n_SENSITIVE_PATTERNS = re.compile(\n    r'(authorization|api[_-]?key|secret|token|password|bearer)',\n    re.IGNORECASE\n)\n\n\nclass SafeLoggingMixin:\n    \"\"\"Mixin that sanitizes sensitive values in __repr__.\"\"\"\n    \n    def __repr__(self) -> str:\n        \"\"\"Repr with sensitive values masked.\"\"\"\n        fields = []\n        for name, value in self.__dict__.items():\n            if name.startswith(\"_\"):\n                continue\n            # Mask if field name looks sensitive\n            if _SENSITIVE_PATTERNS.search(name):\n                fields.append(f\"{name}='***'\")\n            elif isinstance(value, dict):\n                # Mask dict values with sensitive keys\n                safe_dict = {\n                    k: \"***\" if _SENSITIVE_PATTERNS.search(k) else v\n                    for k, v in value.items()\n                }\n                fields.append(f\"{name}={safe_dict}\")\n            else:\n                fields.append(f\"{name}={value!r}\")\n        return f\"{self.__class__.__name__}({', '.join(fields)})\"\n```\n\nPer PRD: \"Sanitize before logging: Don't log raw JSON (may contain secrets)\"",
        "testStrategy": "Create settings with headers containing Authorization, verify repr masks the value.",
        "priority": "medium",
        "dependencies": [
          "54"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create sensitive patterns module with regex constant",
            "description": "Create new file for sanitization utilities with compiled regex pattern for detecting sensitive field names.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/sanitization.py` with `_SENSITIVE_PATTERNS` regex constant. Pattern: `re.compile(r'(authorization|api[_-]?key|secret|token|password|bearer)', re.IGNORECASE)`. Import `re` and use `__future__ annotations`. Follow existing module patterns.",
            "status": "pending",
            "testStrategy": "Unit test regex matches expected sensitive patterns (api_key, API-KEY, Authorization, password, bearer_token) and rejects non-sensitive names (username, email, config).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement SafeLoggingMixin base __repr__ for scalar fields",
            "description": "Create mixin class with __repr__ that masks scalar fields whose names match sensitive patterns.",
            "dependencies": [
              1
            ],
            "details": "Add `SafeLoggingMixin` class to `sanitization.py`. Implement `__repr__` that iterates `self.__dict__.items()`, skips `_` prefixed names, masks values where field name matches `_SENSITIVE_PATTERNS`, and formats as `ClassName(field1=value, field2='***')`. Use `!r` repr formatting for non-masked values.",
            "status": "pending",
            "testStrategy": "Create test class inheriting mixin with `api_key='secret123'` and `name='public'`. Verify repr shows `api_key='***'` and `name='public'`.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add dict value masking for nested sensitive keys",
            "description": "Extend __repr__ to recursively mask dict values that have sensitive key names.",
            "dependencies": [
              2
            ],
            "details": "In `SafeLoggingMixin.__repr__`, add branch for `isinstance(value, dict)`. Create safe_dict by iterating dict items and replacing values with `'***'` where key matches `_SENSITIVE_PATTERNS`. Format dict fields with the sanitized version. Keep original dict unchanged.",
            "status": "pending",
            "testStrategy": "Test class with `headers={'Authorization': 'Bearer xyz', 'Content-Type': 'json'}`. Verify repr shows `{'Authorization': '***', 'Content-Type': 'json'}`.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Write comprehensive test suite for SafeLoggingMixin",
            "description": "Create test file with full coverage of sanitization edge cases and patterns.",
            "dependencies": [
              3
            ],
            "details": "Create `tests/configuration/test_sanitization.py`. Test classes: `TestSensitivePatterns` (regex matching), `TestSafeLoggingMixin` (scalar masking, dict masking, mixed fields, empty dicts, no sensitive fields, private field skipping). Use pytest fixtures for test settings classes. Follow existing test patterns from `test_shell_adapter.py`.",
            "status": "pending",
            "testStrategy": "Run pytest on new test file. Verify all edge cases covered: case insensitivity, various sensitive patterns, nested dicts, empty values, private attributes ignored.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Export SafeLoggingMixin in configuration module __init__.py",
            "description": "Add public export of SafeLoggingMixin and optionally the patterns constant for module consumers.",
            "dependencies": [
              4
            ],
            "details": "Update `src/buvis/pybase/configuration/__init__.py` to import and export `SafeLoggingMixin` from `.sanitization`. Add to `__all__` list. Optionally export `SENSITIVE_PATTERNS` (renamed from private) if consumers need to extend pattern matching. Verify import works: `from buvis.pybase.configuration import SafeLoggingMixin`.",
            "status": "pending",
            "testStrategy": "Import test: `from buvis.pybase.configuration import SafeLoggingMixin` succeeds. Integration test: create settings class using mixin, verify repr sanitization works end-to-end.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "59",
        "title": "Export complex env examples from module",
        "description": "Update configuration/__init__.py to export complex env parsing examples and validators.",
        "details": "Update `src/buvis/pybase/configuration/__init__.py`:\n\n```python\nfrom .configuration import Configuration, cfg\nfrom .exceptions import ConfigurationKeyNotFoundError\nfrom .validators import (\n    MAX_JSON_ENV_SIZE,\n    MAX_NESTING_DEPTH,\n    get_model_depth,\n    validate_json_env_size,\n    validate_nesting_depth,\n)\n\n__all__ = [\n    \"Configuration\",\n    \"ConfigurationKeyNotFoundError\",\n    \"MAX_JSON_ENV_SIZE\",\n    \"MAX_NESTING_DEPTH\",\n    \"cfg\",\n    \"get_model_depth\",\n    \"validate_json_env_size\",\n    \"validate_nesting_depth\",\n]\n```\n\nNote: PaymentRule and PayrollSettings are examples in examples/ subpackage, not exported from main module. Users copy the pattern.",
        "testStrategy": "Verify imports work: from buvis.pybase.configuration import validate_json_env_size, MAX_JSON_ENV_SIZE",
        "priority": "medium",
        "dependencies": [
          "56",
          "57",
          "58"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor exception import to use exceptions module directly",
            "description": "Update the import statement for ConfigurationKeyNotFoundError to import directly from .exceptions instead of through .configuration module.",
            "dependencies": [],
            "details": "Change `from .configuration import Configuration, ConfigurationKeyNotFoundError, cfg` to separate imports:\n- `from .configuration import Configuration, cfg`\n- `from .exceptions import ConfigurationKeyNotFoundError`\n\nThis decouples the exception from the configuration module and follows the established pattern where exceptions.py defines the exception class.",
            "status": "pending",
            "testStrategy": "Run `python -c \"from buvis.pybase.configuration import ConfigurationKeyNotFoundError\"` to verify import works",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add validators module imports to __init__.py",
            "description": "Import validator functions and constants from the validators module created by dependency tasks.",
            "dependencies": [
              1
            ],
            "details": "Add import block for validators:\n```python\nfrom .validators import (\n    MAX_JSON_ENV_SIZE,\n    MAX_NESTING_DEPTH,\n    get_model_depth,\n    validate_json_env_size,\n    validate_nesting_depth,\n)\n```\nThis exposes the validation utilities for consumers who need to validate env var sizes and model nesting depth.",
            "status": "pending",
            "testStrategy": "Run `python -c \"from buvis.pybase.configuration import validate_json_env_size, MAX_JSON_ENV_SIZE\"` to verify imports",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update __all__ with alphabetically sorted exports",
            "description": "Rewrite the __all__ list to include all exports in alphabetical order for consistent API surface.",
            "dependencies": [
              1,
              2
            ],
            "details": "Replace __all__ with:\n```python\n__all__ = [\n    \"Configuration\",\n    \"ConfigurationKeyNotFoundError\",\n    \"MAX_JSON_ENV_SIZE\",\n    \"MAX_NESTING_DEPTH\",\n    \"cfg\",\n    \"get_model_depth\",\n    \"validate_json_env_size\",\n    \"validate_nesting_depth\",\n]\n```\nMaintain alphabetical order for readability. Note: PaymentRule/PayrollSettings are examples, not exported here.",
            "status": "pending",
            "testStrategy": "Verify `from buvis.pybase.configuration import *` imports all expected symbols",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add module-level docstring documenting exports",
            "description": "Add a brief docstring to __init__.py explaining what the configuration module provides.",
            "dependencies": [
              3
            ],
            "details": "Add at top of file:\n```python\n\"\"\"Configuration module for BUVIS Python projects.\n\nExports:\n    Configuration: YAML config manager\n    cfg: Singleton configuration instance\n    ConfigurationKeyNotFoundError: Raised when key missing\n    Validators: MAX_JSON_ENV_SIZE, MAX_NESTING_DEPTH, validate_*, get_model_depth\n\"\"\"\n```\nKeeps documentation minimal per project conventions.",
            "status": "pending",
            "testStrategy": "Check `from buvis.pybase.configuration import __doc__` returns the docstring",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run pre-commit and tests to verify module integrity",
            "description": "Execute pre-commit hooks and pytest to ensure the updated module passes all quality checks.",
            "dependencies": [
              4
            ],
            "details": "Run:\n1. `uv run pre-commit run --all-files` - verify ruff formatting/linting passes\n2. `uv run pytest tests/` - ensure existing tests pass\n3. `python -c \"from buvis.pybase.configuration import validate_nesting_depth, MAX_NESTING_DEPTH, cfg\"` - final import verification\n\nFix any import errors or linting issues that arise.",
            "status": "pending",
            "testStrategy": "Pre-commit and pytest must pass with zero errors; manual import test must succeed",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "60",
        "title": "Run full test suite and verify PRD compliance",
        "description": "Run all tests for complex env parsing, verify all 5 PRD test cases pass.",
        "details": "Execute:\n\n```bash\nuv run pre-commit run --all-files\nuv run pytest tests/configuration/test_complex_env_parsing.py -v\n```\n\nVerify PRD compliance checklist:\n1.  `'[{\"rule_id\":\"a\",\"enabled\":true}]'` -> `[PaymentRule(rule_id=\"a\", enabled=True)]`\n2.  `'[]'` -> empty list\n3.  `'[{broken'` -> ValidationError with JSON parse error\n4.  `'[{\"rule_id\":123}]'` -> ValidationError (wrong type)\n5.  Plain scalar `500` still works for int fields\n6.  Dict parsing works: `'{\"key\":\"value\"}'` -> dict\n7.  Size limit rejects >64KB values\n8.  Logging masks sensitive values\n\nFix any failures before marking complete.",
        "testStrategy": "All pre-commit hooks pass, all pytest tests pass, PRD checklist verified.",
        "priority": "high",
        "dependencies": [
          "52",
          "53",
          "55",
          "57",
          "58",
          "59"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Run pre-commit hooks and fix lint/format issues",
            "description": "Execute pre-commit run --all-files to check code quality across all files modified by the complex env parsing feature implementation.",
            "dependencies": [],
            "details": "Run `uv run pre-commit run --all-files`. This executes ruff linting, formatting checks, and other hooks. If any hook fails, fix the reported issues in the affected files (likely tests/configuration/test_complex_env_parsing.py and src/buvis/pybase/configuration/examples/). Re-run until all hooks pass with exit code 0.",
            "status": "pending",
            "testStrategy": "Exit code 0 from pre-commit run --all-files. No failures reported.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Run pytest and verify basic JSON list parsing tests",
            "description": "Execute pytest on test_complex_env_parsing.py and verify PRD test cases 1, 2, and 5 pass (JSON array parsing, empty array, plain scalar).",
            "dependencies": [
              1
            ],
            "details": "Run `uv run pytest tests/configuration/test_complex_env_parsing.py -v`. Verify passing: test_json_array_parsed (PRD #1: '[{\"rule_id\":\"a\",\"enabled\":true}]' -> [PaymentRule(...)]), test_empty_array (PRD #2: '[]' -> []), test_plain_scalar_still_works (PRD #5: 500 works for int). If failures, check PayrollSettings model_config env_prefix matches test env vars.",
            "status": "pending",
            "testStrategy": "pytest shows PASSED for test_json_array_parsed, test_empty_array, test_plain_scalar_still_works.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Verify ValidationError tests for invalid JSON",
            "description": "Confirm PRD test cases 3 and 4 pass (invalid JSON syntax raises ValidationError, wrong type raises ValidationError).",
            "dependencies": [
              2
            ],
            "details": "From pytest output, verify passing: test_invalid_json_syntax (PRD #3: '[{broken' raises ValidationError with JSON parse error), test_wrong_type (PRD #4: '[{\"rule_id\":123}]' raises ValidationError for type mismatch). Error messages should include field name and reason. Check tests use pytest.raises(ValidationError) and validate error contains expected context.",
            "status": "pending",
            "testStrategy": "pytest shows PASSED for test_invalid_json_syntax, test_wrong_type. Errors contain field names.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Verify dict parsing and security tests",
            "description": "Confirm PRD test cases 6, 7, and 8 pass (dict parsing, size limit 64KB, sensitive value masking in logs).",
            "dependencies": [
              3
            ],
            "details": "Verify passing tests for: dict field parsing (PRD #6: '{\"key\":\"value\"}' -> dict), size limit enforcement (PRD #7: >64KB value rejected with ValidationError), sensitive value masking (PRD #8: password/secret fields masked in log output as '****'). If size limit test missing, it may be in Task 58's scope. Check test_dict_parsing, test_size_limit, test_sensitive_masking exist and pass.",
            "status": "pending",
            "testStrategy": "All 3 additional tests pass. Size limit rejects large values. Logs show masked sensitive fields.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Document PRD compliance and mark task complete",
            "description": "Review all 8 PRD compliance items are verified, document results, fix any remaining failures.",
            "dependencies": [
              4
            ],
            "details": "Create final checklist verification: 1) JSON array->list[Model] , 2) empty array->[] , 3) invalid JSON->ValidationError , 4) wrong type->ValidationError , 5) plain scalar works , 6) dict parsing , 7) 64KB size limit , 8) sensitive masking . If any item fails, debug and fix before completion. Run final `uv run pytest tests/configuration/ -v` to confirm all configuration tests pass together.",
            "status": "pending",
            "testStrategy": "All 8 PRD items verified. Full pytest run on tests/configuration/ passes with 0 failures.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "61",
        "title": "Add Pydantic dependency",
        "description": "Add pydantic as a project dependency to enable settings management with automatic ENV variable handling and validation.",
        "details": "Add pydantic>=2.0,<3 to dependencies in pyproject.toml. Pydantic v2 provides BaseSettings class that automatically reads from environment variables with the `BUVIS_` prefix convention. Run `uv sync` to install.\n\n```toml\n# pyproject.toml\ndependencies = [\n  ...\n  \"pydantic>=2.0,<3\",\n  \"pydantic-settings>=2.0,<3\",  # Required for BaseSettings in v2\n]\n```",
        "testStrategy": "Verify dependency resolves: `uv sync --all-groups` succeeds. Test import: `python -c \"from pydantic_settings import BaseSettings\"`",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add pydantic package to pyproject.toml dependencies",
            "description": "Add pydantic>=2.0,<3 to the project dependencies list in pyproject.toml",
            "dependencies": [],
            "details": "Edit pyproject.toml line 25, add new dependency entry: \"pydantic>=2.0,<3\". Place after existing dependencies, before the closing bracket. This provides BaseModel and core validation.",
            "status": "done",
            "testStrategy": "File contains the new dependency line with correct version bounds",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:01:01.157Z"
          },
          {
            "id": 2,
            "title": "Add pydantic-settings package to pyproject.toml dependencies",
            "description": "Add pydantic-settings>=2.0,<3 to the project dependencies list in pyproject.toml",
            "dependencies": [
              1
            ],
            "details": "Edit pyproject.toml, add after pydantic: \"pydantic-settings>=2.0,<3\". This separate package provides BaseSettings class with ENV variable handling in pydantic v2.",
            "status": "done",
            "testStrategy": "File contains pydantic-settings dependency with correct version bounds",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:01:01.201Z"
          },
          {
            "id": 3,
            "title": "Run uv sync to install new dependencies",
            "description": "Execute uv sync --all-groups to install pydantic and pydantic-settings packages",
            "dependencies": [
              2
            ],
            "details": "Run `uv sync --all-groups` in project root. This resolves dependencies, updates uv.lock, and installs packages to virtual env. Verify command exits 0 with no resolution errors.",
            "status": "done",
            "testStrategy": "Command exits successfully, uv.lock updated with pydantic and pydantic-settings entries",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:01:01.457Z"
          },
          {
            "id": 4,
            "title": "Verify pydantic package imports correctly",
            "description": "Test that pydantic BaseModel can be imported in Python",
            "dependencies": [
              3
            ],
            "details": "Run: `uv run python -c \"from pydantic import BaseModel, ConfigDict; print('pydantic OK')\"`. This confirms core pydantic is installed and importable.",
            "status": "done",
            "testStrategy": "Import command prints 'pydantic OK' with exit code 0",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:01:01.888Z"
          },
          {
            "id": 5,
            "title": "Verify pydantic-settings package imports correctly",
            "description": "Test that pydantic-settings BaseSettings can be imported in Python",
            "dependencies": [
              3
            ],
            "details": "Run: `uv run python -c \"from pydantic_settings import BaseSettings, SettingsConfigDict; print('pydantic-settings OK')\"`. This confirms ENV variable settings support is available.",
            "status": "done",
            "testStrategy": "Import command prints 'pydantic-settings OK' with exit code 0",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:01:02.317Z"
          }
        ],
        "updatedAt": "2026-01-02T18:01:02.317Z"
      },
      {
        "id": "62",
        "title": "Create GlobalSettings model with defaults",
        "description": "Define a Pydantic BaseSettings model that establishes the schema for all configuration values with their default values (lowest precedence).",
        "details": "Create `src/buvis/pybase/configuration/settings.py`:\n\n```python\nfrom __future__ import annotations\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\nclass GlobalSettings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_\",\n        env_nested_delimiter=\"__\",\n        extra=\"ignore\",\n    )\n    \n    debug: bool = False\n    log_level: str = \"INFO\"\n    config_dir: str = \"~/.config/buvis\"\n    # Add fields as needed from existing config usage\n```\n\nPydantic automatically handles ENV -> field mapping (BUVIS_DEBUG -> debug). Defaults are priority 4 (lowest).",
        "testStrategy": "Unit test: instantiate GlobalSettings() with no args, verify all defaults. Test ENV override: with mock env BUVIS_DEBUG=true, verify debug=True.",
        "priority": "high",
        "dependencies": [
          "61"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add pydantic-settings dependency to pyproject.toml",
            "description": "Add pydantic-settings package to project dependencies to enable BaseSettings functionality.",
            "dependencies": [],
            "details": "Add `pydantic-settings>=2.0,<3` to the dependencies array in pyproject.toml. Run `uv sync` to install. pydantic-settings provides BaseSettings with automatic env var loading, SettingsConfigDict for configuration, and nested model support.",
            "status": "pending",
            "testStrategy": "Run `uv sync --all-groups` and verify import works: `python -c 'from pydantic_settings import BaseSettings'`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create settings.py with GlobalSettings scaffold",
            "description": "Create src/buvis/pybase/configuration/settings.py with basic GlobalSettings class structure.",
            "dependencies": [
              1
            ],
            "details": "Create settings.py with:\n```python\nfrom __future__ import annotations\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass GlobalSettings(BaseSettings):\n    \"\"\"Global settings for BUVIS applications.\n    \n    Env vars use BUVIS_ prefix (e.g., BUVIS_DEBUG).\n    Defaults are lowest precedence (priority 4).\n    \"\"\"\n    \n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_\",\n        env_nested_delimiter=\"__\",\n        extra=\"ignore\",\n        frozen=True,\n    )\n```\nFollow existing patterns: `from __future__ import annotations`, Google docstrings.",
            "status": "pending",
            "testStrategy": "Import test: `from buvis.pybase.configuration.settings import GlobalSettings`",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Define GlobalSettings fields with types and defaults",
            "description": "Add all configuration fields based on existing usage patterns in the codebase.",
            "dependencies": [
              2
            ],
            "details": "Add fields to GlobalSettings:\n```python\n    debug: bool = False\n    log_level: str = \"INFO\"\n    config_dir: str = \"~/.config/buvis\"\n    dev_mode: bool = False  # Maps to BUVIS_DEV_MODE (existing usage in uv_tool.py)\n    config_file: str | None = None  # Maps to BUVIS_CONFIG_FILE\n```\nUse modern type hints (`str | None` not `Optional[str]`). Defaults represent lowest precedence values. Field names use snake_case, env vars auto-map with BUVIS_ prefix.",
            "status": "pending",
            "testStrategy": "Instantiate GlobalSettings() with no args, verify all defaults match expected values.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Export GlobalSettings in configuration __init__.py",
            "description": "Update configuration module's __init__.py to export GlobalSettings class.",
            "dependencies": [
              3
            ],
            "details": "Edit src/buvis/pybase/configuration/__init__.py:\n```python\nfrom .configuration import Configuration, ConfigurationKeyNotFoundError, cfg\nfrom .settings import GlobalSettings\n\n__all__ = [\"Configuration\", \"ConfigurationKeyNotFoundError\", \"cfg\", \"GlobalSettings\"]\n```\nFollow existing export pattern with explicit `__all__`.",
            "status": "pending",
            "testStrategy": "Verify import works: `from buvis.pybase.configuration import GlobalSettings`",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create tests/configuration/test_settings.py with unit tests",
            "description": "Create comprehensive test suite for GlobalSettings model.",
            "dependencies": [
              4
            ],
            "details": "Create tests/configuration/test_settings.py:\n```python\nimport os\nfrom unittest.mock import patch\n\nimport pytest\nfrom pydantic import ValidationError\n\nfrom buvis.pybase.configuration.settings import GlobalSettings\n\n\nclass TestGlobalSettingsDefaults:\n    def test_debug_default_false(self):\n        settings = GlobalSettings()\n        assert settings.debug is False\n\n    def test_log_level_default_info(self):\n        settings = GlobalSettings()\n        assert settings.log_level == \"INFO\"\n\n    def test_config_dir_default(self):\n        settings = GlobalSettings()\n        assert settings.config_dir == \"~/.config/buvis\"\n\n\nclass TestGlobalSettingsEnvOverride:\n    @patch.dict(os.environ, {\"BUVIS_DEBUG\": \"true\"})\n    def test_debug_env_override(self):\n        settings = GlobalSettings()\n        assert settings.debug is True\n\n    @patch.dict(os.environ, {\"BUVIS_LOG_LEVEL\": \"DEBUG\"})\n    def test_log_level_env_override(self):\n        settings = GlobalSettings()\n        assert settings.log_level == \"DEBUG\"\n\n\nclass TestGlobalSettingsImmutability:\n    def test_frozen_settings(self):\n        settings = GlobalSettings()\n        with pytest.raises(ValidationError):\n            settings.debug = True\n```\nFollow existing test patterns: class-based, pytest fixtures, mock env vars.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py -v` and verify all tests pass.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:42:30.956Z"
      },
      {
        "id": "63",
        "title": "Implement YAML config loader",
        "description": "Create a method to load YAML configuration files and return a dict suitable for passing as kwargs to GlobalSettings.",
        "details": "Add to `src/buvis/pybase/configuration/resolver.py`:\n\n```python\nfrom __future__ import annotations\nimport os\nfrom pathlib import Path\nfrom typing import Any\nimport yaml\n\ndef _load_yaml_config(file_path: Path | None = None) -> dict[str, Any]:\n    \"\"\"Load YAML config, return empty dict if not found.\"\"\"\n    if file_path is None:\n        file_path = Path(\n            os.getenv(\"BUVIS_CONFIG_FILE\", Path.home() / \".config/buvis/config.yaml\")\n        )\n    \n    if not file_path.exists():\n        return {}\n    \n    with file_path.open() as f:\n        return yaml.safe_load(f) or {}\n```\n\nThis provides priority 3 values. Return empty dict (not None) when file missing so **kwargs works.",
        "testStrategy": "Test with valid YAML returns dict. Test with missing file returns {}. Test with empty file returns {}. Test with invalid YAML raises exception.",
        "priority": "high",
        "dependencies": [
          "62"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create resolver.py module with imports",
            "description": "Create the new resolver.py file in src/buvis/pybase/configuration/ with necessary imports and module structure.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/resolver.py` with imports: `from __future__ import annotations`, `import os`, `from pathlib import Path`, `from typing import Any`, `import yaml`. Follow existing code conventions in the configuration module.",
            "status": "pending",
            "testStrategy": "Verify file exists and imports resolve without errors.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement default config path resolution",
            "description": "Add logic to determine config file path from BUVIS_CONFIG_FILE env var or default to ~/.config/buvis/config.yaml.",
            "dependencies": [
              1
            ],
            "details": "In `_load_yaml_config`, when `file_path` is None, resolve path via: `Path(os.getenv(\"BUVIS_CONFIG_FILE\", Path.home() / \".config/buvis/config.yaml\"))`. This matches existing pattern in configuration.py:77-79.",
            "status": "pending",
            "testStrategy": "Test env var override takes precedence. Test default path used when env var unset.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement file existence check with empty dict fallback",
            "description": "Add check for file existence and return empty dict when file not found instead of raising exception.",
            "dependencies": [
              2
            ],
            "details": "Before attempting to read, check `if not file_path.exists(): return {}`. This differs from existing Configuration class which raises FileNotFoundError - here we silently return empty dict so **kwargs unpacking works cleanly.",
            "status": "pending",
            "testStrategy": "Test with non-existent file returns empty dict `{}`. Test with non-existent directory returns empty dict.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement YAML loading with safe_load",
            "description": "Add YAML file reading using yaml.safe_load with empty file handling.",
            "dependencies": [
              3
            ],
            "details": "Open file with `file_path.open()` context manager, load with `yaml.safe_load(f)`. Handle empty file case by returning `yaml.safe_load(f) or {}` since safe_load returns None for empty files. This pattern exists in configuration.py:90.",
            "status": "pending",
            "testStrategy": "Test valid YAML returns parsed dict. Test empty file returns `{}`. Test invalid YAML raises yaml.YAMLError.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add unit tests for _load_yaml_config",
            "description": "Create comprehensive test suite covering all scenarios in tests/configuration/test_resolver.py.",
            "dependencies": [
              4
            ],
            "details": "Create `tests/configuration/test_resolver.py` with class `TestLoadYamlConfig`. Test cases: (1) valid YAML file returns dict, (2) missing file returns {}, (3) empty file returns {}, (4) invalid YAML raises exception, (5) BUVIS_CONFIG_FILE env var override, (6) explicit file_path param. Use tmp_path fixture and monkeypatch for env vars.",
            "status": "pending",
            "testStrategy": "Run pytest on test file. Verify all 6 scenarios pass. Check coverage of _load_yaml_config function.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:44:11.018Z"
      },
      {
        "id": "64",
        "title": "Implement ConfigResolver with precedence logic",
        "description": "Create ConfigResolver class that implements the CLI > ENV > YAML > Defaults precedence chain.",
        "details": "In `src/buvis/pybase/configuration/resolver.py`:\n\n```python\nfrom __future__ import annotations\nfrom typing import Any\nfrom pathlib import Path\nfrom .settings import GlobalSettings\n\nclass ConfigResolver:\n    def __init__(self, config_path: Path | None = None) -> None:\n        self._config_path = config_path\n    \n    def resolve(\n        self,\n        cli_overrides: dict[str, Any] | None = None,\n    ) -> GlobalSettings:\n        # 1. Load YAML (becomes constructor kwargs)\n        yaml_config = _load_yaml_config(self._config_path)\n        \n        # 2. Create settings - Pydantic applies ENV automatically over YAML\n        settings = GlobalSettings(**yaml_config)\n        \n        # 3. Apply CLI overrides (highest priority)\n        if cli_overrides:\n            for key, value in cli_overrides.items():\n                if value is not None:  # None = not provided, fall through\n                    setattr(settings, key, value)\n        \n        return settings\n```\n\nPrecedence works because: defaults in model < yaml passed as kwargs < ENV read by Pydantic < CLI setattr.",
        "testStrategy": "Test all 5 PRD scenarios: (1) all sources set -> CLI wins, (2) no CLI -> ENV wins, (3) no CLI/ENV -> YAML wins, (4) only default -> default used, (5) CLI=None -> falls through.",
        "priority": "high",
        "dependencies": [
          "63"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create resolver.py with ConfigResolver class skeleton",
            "description": "Create the resolver.py module with ConfigResolver class, constructor accepting config_path, and type imports.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/resolver.py` with:\n- `from __future__ import annotations`\n- Type imports: `Any`, `Path`\n- Import `GlobalSettings` from `.settings` (Task 63 dependency)\n- `ConfigResolver.__init__(self, config_path: Path | None = None)` storing `self._config_path`\n- Empty `resolve()` method stub returning `GlobalSettings()`",
            "status": "pending",
            "testStrategy": "Verify module imports without errors and ConfigResolver instantiates with optional path parameter.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement _load_yaml_config helper function",
            "description": "Create private function to load YAML config file and return dict for GlobalSettings kwargs.",
            "dependencies": [
              1
            ],
            "details": "Add `_load_yaml_config(path: Path | None) -> dict[str, Any]` function:\n- Return empty dict if path is None\n- Return empty dict if path doesn't exist (graceful degradation)\n- Use `yaml.safe_load()` to parse file contents\n- Return empty dict if YAML is empty/null\n- Follow existing pattern from `Configuration._load_configuration()` line 89",
            "status": "pending",
            "testStrategy": "Test with: None path, non-existent path, valid YAML, empty YAML, malformed YAML (should raise).",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement resolve() with GlobalSettings instantiation",
            "description": "Complete resolve() method to load YAML and create GlobalSettings with proper kwargs passing.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement `resolve(cli_overrides: dict[str, Any] | None = None) -> GlobalSettings`:\n1. Call `_load_yaml_config(self._config_path)` to get YAML dict\n2. Instantiate `GlobalSettings(**yaml_config)` - Pydantic applies ENV vars automatically over YAML kwargs\n3. Return the settings instance (CLI override logic in next subtask)\n\nPrecedence at this point: defaults < yaml < env (Pydantic handles env automatically)",
            "status": "pending",
            "testStrategy": "Test that YAML values override defaults, ENV values override YAML when GlobalSettings has env settings configured.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement CLI override application in resolve()",
            "description": "Add CLI override logic using setattr to apply highest-priority overrides after settings creation.",
            "dependencies": [
              3
            ],
            "details": "Extend resolve() method:\n```python\nif cli_overrides:\n    for key, value in cli_overrides.items():\n        if value is not None:  # None = not provided, fall through\n            setattr(settings, key, value)\n```\nCLI None values intentionally skip to allow lower-priority sources to win. This completes the precedence chain: defaults < yaml < env < cli.",
            "status": "pending",
            "testStrategy": "Test CLI=value overrides all others. Test CLI=None falls through to ENV. Verify setattr works on frozen Pydantic model (may need model_config adjustment).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add comprehensive tests for all 5 PRD precedence scenarios",
            "description": "Create test_resolver.py with tests covering all precedence combinations per the PRD test strategy.",
            "dependencies": [
              4
            ],
            "details": "Create `tests/configuration/test_resolver.py` with class-based tests:\n1. `test_cli_wins_when_all_sources_set` - CLI > ENV > YAML > default\n2. `test_env_wins_when_no_cli` - ENV > YAML > default (cli_overrides=None)\n3. `test_yaml_wins_when_no_cli_or_env` - YAML > default (no env set)\n4. `test_default_used_when_only_default` - no yaml, no env, no cli\n5. `test_cli_none_falls_through` - CLI={key: None} uses ENV value\n\nUse `@patch.dict(os.environ)` for ENV, tmp_path fixture for YAML files, mock GlobalSettings if needed.",
            "status": "pending",
            "testStrategy": "Run pytest on test_resolver.py. All 5 scenarios must pass. Integration test with real GlobalSettings when Task 63 complete.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:47:15.130Z"
      },
      {
        "id": "65",
        "title": "Add source tracking and DEBUG logging",
        "description": "Track which source provided each configuration value and log at DEBUG level (without logging actual values for security).",
        "details": "Enhance ConfigResolver to track sources:\n\n```python\nimport logging\nfrom enum import Enum\n\nclass ConfigSource(Enum):\n    DEFAULT = \"default\"\n    YAML = \"yaml\"\n    ENV = \"env\"\n    CLI = \"cli\"\n\nclass ConfigResolver:\n    def __init__(self, config_path: Path | None = None) -> None:\n        self._config_path = config_path\n        self._sources: dict[str, ConfigSource] = {}\n        self._logger = logging.getLogger(__name__)\n    \n    def resolve(self, cli_overrides: dict[str, Any] | None = None) -> GlobalSettings:\n        yaml_config = _load_yaml_config(self._config_path)\n        env_keys = {k.removeprefix(\"BUVIS_\").lower() for k in os.environ if k.startswith(\"BUVIS_\")}\n        \n        settings = GlobalSettings(**yaml_config)\n        \n        # Track sources for each field\n        for field in settings.model_fields:\n            if cli_overrides and cli_overrides.get(field) is not None:\n                self._sources[field] = ConfigSource.CLI\n            elif field in env_keys:\n                self._sources[field] = ConfigSource.ENV\n            elif field in yaml_config:\n                self._sources[field] = ConfigSource.YAML\n            else:\n                self._sources[field] = ConfigSource.DEFAULT\n        \n        # Apply CLI and log\n        if cli_overrides:\n            for key, value in cli_overrides.items():\n                if value is not None:\n                    setattr(settings, key, value)\n        \n        self._log_sources()\n        return settings\n    \n    def _log_sources(self) -> None:\n        for field, source in self._sources.items():\n            self._logger.debug(\"Config '%s' from %s\", field, source.value)\n    \n    @property\n    def sources(self) -> dict[str, ConfigSource]:\n        return self._sources.copy()\n```",
        "testStrategy": "Verify sources dict populated correctly for each scenario. Mock logger and verify DEBUG calls happen with field names but no values. Test sources property returns copy.",
        "priority": "medium",
        "dependencies": [
          "64"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ConfigSource enum in configuration module",
            "description": "Define ConfigSource enum with values DEFAULT, YAML, ENV, CLI to represent configuration value origins.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/source.py` with:\n```python\nfrom __future__ import annotations\n\nfrom enum import Enum\n\n\nclass ConfigSource(Enum):\n    \"\"\"Source from which a configuration value was obtained.\"\"\"\n    DEFAULT = \"default\"\n    YAML = \"yaml\"\n    ENV = \"env\"\n    CLI = \"cli\"\n```\nThis is the first enum in the codebase. Keep it simple, no methods needed.",
            "status": "pending",
            "testStrategy": "Unit test that ConfigSource enum has exactly 4 members with correct string values. Test that ConfigSource.YAML.value == 'yaml' etc.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add _sources dict and logger to ConfigResolver.__init__",
            "description": "Initialize source tracking dict and logger instance in ConfigResolver constructor.",
            "dependencies": [
              1
            ],
            "details": "In `ConfigResolver.__init__`, add:\n- `self._sources: dict[str, ConfigSource] = {}` for tracking which source provided each field\n- `self._logger = logging.getLogger(__name__)` following existing adapter pattern\n\nImport logging at module top. This prepares ConfigResolver for source tracking without changing resolve() logic yet.",
            "status": "pending",
            "testStrategy": "Test that newly instantiated ConfigResolver has empty _sources dict and has _logger attribute that is a Logger instance.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement source tracking logic in resolve() method",
            "description": "Track which source (CLI, ENV, YAML, DEFAULT) provided each configuration field value during resolution.",
            "dependencies": [
              2
            ],
            "details": "In ConfigResolver.resolve(), after loading yaml_config and determining env_keys, iterate over settings.model_fields and set _sources[field] based on priority:\n1. CLI override present and not None  ConfigSource.CLI\n2. Field in env_keys  ConfigSource.ENV  \n3. Field in yaml_config  ConfigSource.YAML\n4. Otherwise  ConfigSource.DEFAULT\n\nThis must happen before any modifications to settings object.",
            "status": "pending",
            "testStrategy": "Create ConfigResolver, call resolve() with: 1) CLI override for field A, 2) env var for field B, 3) yaml value for field C, 4) defaults only. Verify _sources dict maps each field to correct ConfigSource.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add _log_sources() method and sources property",
            "description": "Implement DEBUG logging of sources (no values) and read-only sources property returning defensive copy.",
            "dependencies": [
              3
            ],
            "details": "Add to ConfigResolver:\n```python\ndef _log_sources(self) -> None:\n    for field, source in self._sources.items():\n        self._logger.debug(\"Config '%s' from %s\", field, source.value)\n\n@property\ndef sources(self) -> dict[str, ConfigSource]:\n    return self._sources.copy()\n```\nCall _log_sources() at end of resolve(). IMPORTANT: Never log actual values - only field names and sources for security.",
            "status": "pending",
            "testStrategy": "Mock logger, call resolve(), verify debug() called once per field with field name and source but NO values. Test sources property returns copy (modify returned dict, original unchanged).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Export ConfigSource and add comprehensive tests",
            "description": "Export ConfigSource from configuration module and create test file with full coverage.",
            "dependencies": [
              4
            ],
            "details": "1. Add to `configuration/__init__.py`: `from .source import ConfigSource` and add to __all__\n2. Create `tests/configuration/test_config_resolver.py` with:\n   - TestConfigSource: enum values, membership\n   - TestConfigResolverSourceTracking: sources populated correctly for each scenario (CLI > ENV > YAML > DEFAULT)\n   - TestConfigResolverLogging: mock logger, verify DEBUG calls have field names but no values\n   - TestConfigResolverSourcesProperty: verify returns copy",
            "status": "pending",
            "testStrategy": "Run pytest on new test file. Verify import works: `from buvis.pybase.configuration import ConfigSource`. Check test coverage includes all source determination branches.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "66",
        "title": "Handle edge cases",
        "description": "Implement proper handling for edge cases: empty string ENV values, missing required fields, None vs absent.",
        "details": "Edge case handling per PRD:\n\n1. **CLI value is None**: Already handled - None means \"not provided\", falls through.\n\n2. **ENV empty string \"\"**: Pydantic treats empty string as a value, not missing. This is correct per PRD.\n\n3. **YAML key absent**: Returns model default. Already works.\n\n4. **Required field missing everywhere**: Add required fields to GlobalSettings:\n```python\nclass GlobalSettings(BaseSettings):\n    # Required field - will raise ValidationError if missing from all sources\n    hostname: str  # No default = required\n```\n\n5. **Validation on all sources**: Pydantic validates everything. Add custom validators:\n```python\nfrom pydantic import field_validator\n\nclass GlobalSettings(BaseSettings):\n    log_level: str = \"INFO\"\n    \n    @field_validator(\"log_level\")\n    @classmethod\n    def validate_log_level(cls, v: str) -> str:\n        valid = {\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"}\n        if v.upper() not in valid:\n            raise ValueError(f\"log_level must be one of {valid}\")\n        return v.upper()\n```",
        "testStrategy": "Test ENV=\"\" uses empty string. Test required field missing raises ValidationError at startup. Test invalid value from any source raises ValidationError.",
        "priority": "medium",
        "dependencies": [
          "64"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add field_validator for log_level with Literal constraint",
            "description": "Implement pydantic field_validator to ensure log_level is one of the valid levels and normalizes to uppercase.",
            "dependencies": [],
            "details": "In `src/buvis/pybase/configuration/settings.py`, add field_validator to GlobalSettings:\n\n```python\nfrom pydantic import field_validator\nfrom typing import Literal\n\nclass GlobalSettings(BaseSettings):\n    log_level: str = \"INFO\"\n    \n    @field_validator(\"log_level\")\n    @classmethod\n    def validate_log_level(cls, v: str) -> str:\n        valid = {\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"}\n        upper = v.upper()\n        if upper not in valid:\n            raise ValueError(f\"log_level must be one of {valid}, got '{v}'\")\n        return upper\n```\n\nThis handles case-insensitive input while storing uppercase. Alternatively, use `Literal[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]` type directly if case normalization isn't needed.",
            "status": "pending",
            "testStrategy": "Test valid values (case variations: 'debug', 'DEBUG', 'Debug'). Test invalid value raises ValidationError with clear message. Test from ENV, YAML, and CLI sources.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Test and document ENV empty string behavior",
            "description": "Verify pydantic-settings treats empty string ENV values as actual values (not missing), add tests documenting this behavior.",
            "dependencies": [
              1
            ],
            "details": "Per PRD-00007: `ENV value is empty string \"\" -> Use empty string (not default)`.\n\nAdd tests in `tests/configuration/test_settings_edge_cases.py`:\n\n```python\nimport os\nfrom unittest.mock import patch\n\nclass TestEnvEmptyString:\n    def test_env_empty_string_used_not_default(self) -> None:\n        \"\"\"ENV='' should use empty string, not fall back to default.\"\"\"\n        with patch.dict(os.environ, {\"BUVIS_OUTPUT_FORMAT\": \"\"}):\n            settings = GlobalSettings()\n            # Empty string is the value, not 'text' default\n            assert settings.output_format == \"\"\n    \n    def test_env_unset_uses_default(self) -> None:\n        \"\"\"Unset ENV should use model default.\"\"\"\n        # Ensure var is not set\n        os.environ.pop(\"BUVIS_OUTPUT_FORMAT\", None)\n        settings = GlobalSettings()\n        assert settings.output_format == \"text\"\n```\n\nNote: This may require adjusting validators to handle empty strings appropriately (e.g., empty log_level should fail validation).",
            "status": "pending",
            "testStrategy": "Test ENV=\"\" uses empty string. Test ENV unset uses default. Test validator rejects empty string for fields requiring non-empty values.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add required field and test ValidationError on missing",
            "description": "Define at least one required field in GlobalSettings and verify ValidationError is raised at startup when missing from all sources.",
            "dependencies": [
              1
            ],
            "details": "Per PRD-00001: \"No secrets in defaults\" means some fields must be required (no default).\n\nExample in `settings.py`:\n```python\nclass GlobalSettings(BaseSettings):\n    # Required - raises ValidationError if missing everywhere\n    api_endpoint: str  # No default = required\n    \n    # Optional with defaults\n    debug: bool = False\n```\n\nAdd test in `tests/configuration/test_settings_edge_cases.py`:\n```python\nimport pytest\nfrom pydantic import ValidationError\n\nclass TestRequiredFieldMissing:\n    def test_required_field_missing_raises_validation_error(self) -> None:\n        \"\"\"Missing required field from all sources raises ValidationError.\"\"\"\n        # Ensure ENV not set\n        os.environ.pop(\"BUVIS_API_ENDPOINT\", None)\n        \n        with pytest.raises(ValidationError) as exc_info:\n            GlobalSettings()  # No YAML, no ENV, no CLI\n        \n        assert \"api_endpoint\" in str(exc_info.value)\n        assert \"Field required\" in str(exc_info.value)\n```",
            "status": "pending",
            "testStrategy": "Test required field missing raises ValidationError at startup with clear field name in error. Test required field provided via any source succeeds.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Ensure CLI None values fall through in ConfigResolver",
            "description": "Verify ConfigResolver.resolve() skips None CLI values, allowing lower-priority sources to provide the value.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Per PRD-00007: `CLI value is None -> Fall through to ENV`.\n\nIn `resolver.py`, the `resolve()` method must filter out None values from cli_overrides:\n\n```python\ndef resolve(self, cli_overrides: dict[str, Any] | None = None) -> GlobalSettings:\n    yaml_config = self._load_yaml_config()\n    settings = GlobalSettings(**yaml_config)\n    \n    if cli_overrides:\n        for key, value in cli_overrides.items():\n            if value is not None:  # None means \"not provided\"\n                setattr(settings, key, value)\n    \n    return settings\n```\n\nThis is already in Task 64's implementation. Verify with tests:\n\n```python\nclass TestCliNoneFallthrough:\n    def test_cli_none_falls_through_to_env(self) -> None:\n        with patch.dict(os.environ, {\"BUVIS_DEBUG\": \"true\"}):\n            resolver = ConfigResolver()\n            settings = resolver.resolve(cli_overrides={\"debug\": None})\n            assert settings.debug is True  # ENV wins\n```",
            "status": "pending",
            "testStrategy": "Test CLI=None with ENV set -> ENV wins. Test CLI=None with YAML set -> YAML wins. Test CLI=None with no other source -> default used.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add comprehensive edge case integration tests",
            "description": "Create integration tests covering all PRD-00007 edge cases in combination with ConfigResolver and all sources.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create `tests/configuration/test_edge_cases_integration.py` with full precedence chain tests:\n\n```python\nimport os\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch\n\nimport pytest\nimport yaml\nfrom pydantic import ValidationError\n\nfrom buvis.pybase.configuration import ConfigResolver, GlobalSettings\n\n\nclass TestEdgeCasesIntegration:\n    def test_yaml_absent_key_uses_default(self, tmp_path: Path) -> None:\n        \"\"\"YAML key absent -> model default used.\"\"\"\n        config = tmp_path / \"buvis.yaml\"\n        config.write_text(yaml.dump({\"debug\": True}))  # no log_level\n        \n        resolver = ConfigResolver(config)\n        settings = resolver.resolve()\n        \n        assert settings.log_level == \"INFO\"  # default\n    \n    def test_all_sources_set_cli_wins(self, tmp_path: Path) -> None:\n        \"\"\"All sources set -> CLI wins per precedence.\"\"\"\n        config = tmp_path / \"buvis.yaml\"\n        config.write_text(yaml.dump({\"debug\": False}))\n        \n        with patch.dict(os.environ, {\"BUVIS_DEBUG\": \"true\"}):\n            resolver = ConfigResolver(config)\n            settings = resolver.resolve(cli_overrides={\"debug\": False})\n            assert settings.debug is False  # CLI wins\n    \n    def test_invalid_value_any_source_raises(self, tmp_path: Path) -> None:\n        \"\"\"Invalid value from any source raises ValidationError.\"\"\"\n        config = tmp_path / \"buvis.yaml\"\n        config.write_text(yaml.dump({\"log_level\": \"INVALID\"}))\n        \n        resolver = ConfigResolver(config)\n        with pytest.raises(ValidationError):\n            resolver.resolve()\n```",
            "status": "pending",
            "testStrategy": "Test each PRD-00007 edge case table row. Test invalid values from YAML, ENV, and CLI all raise ValidationError. Verify error messages include source and field info.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "67",
        "title": "Create configuration singleton with resolver",
        "description": "Create a new singleton pattern that uses ConfigResolver while maintaining backward compatibility with existing cfg usage.",
        "details": "Update `src/buvis/pybase/configuration/__init__.py` to provide both old and new interfaces:\n\n```python\nfrom .configuration import Configuration, ConfigurationKeyNotFoundError, cfg\nfrom .settings import GlobalSettings\nfrom .resolver import ConfigResolver, ConfigSource\n\n# New resolved config singleton\n_resolver = ConfigResolver()\n_settings: GlobalSettings | None = None\n\ndef get_settings(cli_overrides: dict | None = None) -> GlobalSettings:\n    \"\"\"Get resolved settings (singleton on first call).\"\"\"\n    global _settings\n    if _settings is None:\n        _settings = _resolver.resolve(cli_overrides)\n    return _settings\n\ndef reset_settings() -> None:\n    \"\"\"Reset singleton (for testing).\"\"\"\n    global _settings\n    _settings = None\n\n__all__ = [\n    \"Configuration\", \"ConfigurationKeyNotFoundError\", \"cfg\",  # Legacy\n    \"GlobalSettings\", \"ConfigResolver\", \"ConfigSource\",  # New\n    \"get_settings\", \"reset_settings\",\n]\n```\n\nThis preserves `cfg` for existing users while providing `get_settings()` for new code.",
        "testStrategy": "Test get_settings() returns same instance on repeated calls. Test reset_settings() clears singleton. Test legacy cfg still works. Test cli_overrides only applied on first call.",
        "priority": "medium",
        "dependencies": [
          "64",
          "65"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add imports for settings and resolver modules",
            "description": "Update configuration/__init__.py to import GlobalSettings, ConfigResolver, and ConfigSource from their respective modules.",
            "dependencies": [],
            "details": "Add imports at top of __init__.py:\n```python\nfrom .configuration import Configuration, ConfigurationKeyNotFoundError, cfg\nfrom .settings import GlobalSettings\nfrom .resolver import ConfigResolver, ConfigSource\n```\nKeep existing imports intact to preserve backward compatibility with cfg.",
            "status": "pending",
            "testStrategy": "Verify imports work: `from buvis.pybase.configuration import GlobalSettings, ConfigResolver, ConfigSource` should not raise ImportError.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add module-level state for resolver singleton",
            "description": "Create module-level variables _resolver and _settings to hold singleton instances.",
            "dependencies": [
              1
            ],
            "details": "Add after imports:\n```python\n# New resolved config singleton\n_resolver = ConfigResolver()\n_settings: GlobalSettings | None = None\n```\n_resolver is eagerly instantiated; _settings is lazily created on first get_settings() call.",
            "status": "pending",
            "testStrategy": "Verify _resolver is ConfigResolver instance and _settings starts as None by inspecting module attributes.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement get_settings() singleton function",
            "description": "Create get_settings() function that returns resolved GlobalSettings, creating singleton on first call.",
            "dependencies": [
              2
            ],
            "details": "Add function:\n```python\ndef get_settings(cli_overrides: dict | None = None) -> GlobalSettings:\n    \"\"\"Get resolved settings (singleton on first call).\"\"\"\n    global _settings\n    if _settings is None:\n        _settings = _resolver.resolve(cli_overrides)\n    return _settings\n```\nNote: cli_overrides only applied on first call when singleton created.",
            "status": "pending",
            "testStrategy": "Test get_settings() returns same instance on repeated calls. Test cli_overrides applied on first call only.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement reset_settings() for testing",
            "description": "Create reset_settings() function that clears the singleton for test isolation.",
            "dependencies": [
              2
            ],
            "details": "Add function:\n```python\ndef reset_settings() -> None:\n    \"\"\"Reset singleton (for testing).\"\"\"\n    global _settings\n    _settings = None\n```\nThis allows tests to reset state between test cases.",
            "status": "pending",
            "testStrategy": "After get_settings(), call reset_settings(), verify next get_settings() creates new instance.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Update __all__ and add integration tests",
            "description": "Export all new symbols in __all__ and create tests/configuration/test_settings_singleton.py.",
            "dependencies": [
              3,
              4
            ],
            "details": "Update __all__:\n```python\n__all__ = [\n    \"Configuration\", \"ConfigurationKeyNotFoundError\", \"cfg\",  # Legacy\n    \"GlobalSettings\", \"ConfigResolver\", \"ConfigSource\",  # New\n    \"get_settings\", \"reset_settings\",\n]\n```\nCreate test file with: (1) test_get_settings_returns_singleton, (2) test_reset_settings_clears_singleton, (3) test_legacy_cfg_still_works, (4) test_cli_overrides_only_on_first_call.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_settings_singleton.py -v` - all 4 tests pass. Verify legacy imports still work.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "68",
        "title": "Write precedence integration tests",
        "description": "Create comprehensive tests covering all precedence scenarios from the PRD.",
        "details": "Create `tests/configuration/test_config_resolver.py`:\n\n```python\nimport os\nfrom pathlib import Path\nfrom unittest.mock import patch\nimport pytest\nfrom buvis.pybase.configuration import ConfigResolver, GlobalSettings\n\n@pytest.fixture\ndef yaml_config(tmp_path: Path) -> Path:\n    cfg = tmp_path / \"config.yaml\"\n    cfg.write_text(\"debug: false\\nlog_level: WARNING\")\n    return cfg\n\nclass TestPrecedence:\n    def test_cli_wins_over_all(self, yaml_config: Path) -> None:\n        \"\"\"CLI > ENV > YAML > Default.\"\"\"\n        with patch.dict(os.environ, {\"BUVIS_DEBUG\": \"true\"}):\n            resolver = ConfigResolver(yaml_config)\n            settings = resolver.resolve(cli_overrides={\"debug\": False})\n            assert settings.debug is False  # CLI wins\n    \n    def test_env_wins_over_yaml(self, yaml_config: Path) -> None:\n        \"\"\"ENV > YAML when no CLI.\"\"\"\n        with patch.dict(os.environ, {\"BUVIS_DEBUG\": \"true\"}):\n            resolver = ConfigResolver(yaml_config)\n            settings = resolver.resolve()\n            assert settings.debug is True  # ENV wins over YAML's false\n    \n    def test_yaml_wins_over_default(self, yaml_config: Path) -> None:\n        \"\"\"YAML > Default when no CLI/ENV.\"\"\"\n        with patch.dict(os.environ, {}, clear=True):\n            resolver = ConfigResolver(yaml_config)\n            settings = resolver.resolve()\n            assert settings.log_level == \"WARNING\"  # YAML wins\n    \n    def test_default_used_when_nothing_else(self, tmp_path: Path) -> None:\n        empty_yaml = tmp_path / \"empty.yaml\"\n        empty_yaml.write_text(\"\")\n        with patch.dict(os.environ, {}, clear=True):\n            resolver = ConfigResolver(empty_yaml)\n            settings = resolver.resolve()\n            assert settings.debug is False  # Default\n    \n    def test_cli_none_falls_through(self, yaml_config: Path) -> None:\n        with patch.dict(os.environ, {\"BUVIS_DEBUG\": \"true\"}):\n            resolver = ConfigResolver(yaml_config)\n            settings = resolver.resolve(cli_overrides={\"debug\": None})\n            assert settings.debug is True  # ENV wins, CLI None ignored\n```",
        "testStrategy": "Run pytest -v tests/configuration/. All 5 PRD test scenarios must pass. Add edge case tests for empty string, validation errors.",
        "priority": "high",
        "dependencies": [
          "64",
          "66"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test file with fixtures for ConfigResolver",
            "description": "Set up tests/configuration/test_config_resolver.py with necessary imports and pytest fixtures for YAML config files and environment variable management.",
            "dependencies": [],
            "details": "Create the test file with imports (os, pathlib.Path, unittest.mock.patch, pytest, ConfigResolver, GlobalSettings). Add yaml_config fixture using tmp_path that creates debug: false and log_level: WARNING. Add empty_yaml fixture for default-only tests. Follow existing test patterns from test_shell_adapter.py.",
            "status": "pending",
            "testStrategy": "File exists with correct imports and fixtures. Fixtures can be used by test methods.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement 5 core PRD precedence test cases",
            "description": "Write TestPrecedence class with the 5 mandatory scenarios from PRD-00007: CLI wins, ENV wins, YAML wins, defaults only, CLI None fallthrough.",
            "dependencies": [
              1
            ],
            "details": "Create TestPrecedence class with: test_cli_wins_over_all (CLI>ENV>YAML>Default), test_env_wins_over_yaml (ENV>YAML when no CLI), test_yaml_wins_over_default (YAML>Default when no CLI/ENV), test_default_used_when_nothing_else (empty YAML, clear ENV), test_cli_none_falls_through (CLI None defers to ENV). Use patch.dict(os.environ, ...) for ENV control.",
            "status": "pending",
            "testStrategy": "Run pytest -v tests/configuration/test_config_resolver.py::TestPrecedence. All 5 tests must pass.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add ENV empty string edge case test",
            "description": "Test that ENV empty string is treated as explicit value per PRD-00007 edge case: 'ENV value is empty string \"\" -> Use empty string (not default)'.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add test_env_empty_string_is_explicit to TestPrecedence class. Set BUVIS_LOG_LEVEL='' in ENV with default being 'INFO'. Assert settings.log_level == '' (empty string used, not default). This validates precedence system respects explicit empty values.",
            "status": "pending",
            "testStrategy": "Test passes and confirms empty string ENV overrides default value.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add validation error tests for missing required fields",
            "description": "Test that ValidationError is raised when required fields are missing from all sources per PRD-00007: 'Required field missing everywhere -> ValidationError at startup'.",
            "dependencies": [
              1
            ],
            "details": "Create TestValidationErrors class. Add test_required_field_missing_raises that creates settings model with required field (no default), omits from YAML/ENV/CLI, and asserts ValidationError is raised with useful message. Add test_invalid_type_raises for type coercion failures (e.g. debug='notabool').",
            "status": "pending",
            "testStrategy": "Tests pass and properly catch ValidationError with pytest.raises context manager.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add multi-source precedence combination test",
            "description": "Create integration test with multiple settings where different sources win for different fields, verifying independent precedence per setting.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add test_mixed_sources_different_fields to TestPrecedence. Set debug in CLI (False), log_level in ENV (DEBUG), another_field in YAML only. Resolve and assert each field came from its highest-priority source. This validates that precedence is per-field, not global.",
            "status": "pending",
            "testStrategy": "Test passes confirming each field respects its own highest-priority source independently.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "69",
        "title": "Add security-sensitive field audit logging",
        "description": "For security-sensitive settings, log source at INFO level (not just DEBUG) per PRD security constraints.",
        "details": "Extend GlobalSettings to mark sensitive fields and ConfigResolver to log them:\n\n```python\n# settings.py\nfrom pydantic import Field\n\nclass GlobalSettings(BaseSettings):\n    api_key: str | None = Field(default=None, json_schema_extra={\"sensitive\": True})\n    jira_token: str | None = Field(default=None, json_schema_extra={\"sensitive\": True})\n\n# resolver.py\ndef _log_sources(self) -> None:\n    for field, source in self._sources.items():\n        field_info = GlobalSettings.model_fields.get(field)\n        is_sensitive = field_info and field_info.json_schema_extra and field_info.json_schema_extra.get(\"sensitive\")\n        \n        if is_sensitive:\n            self._logger.info(\"Security config '%s' loaded from %s\", field, source.value)\n        else:\n            self._logger.debug(\"Config '%s' from %s\", field, source.value)\n```\n\nNever log actual values of sensitive fields.",
        "testStrategy": "Mock logger, verify sensitive fields logged at INFO, non-sensitive at DEBUG. Verify no actual values appear in any log calls.",
        "priority": "low",
        "dependencies": [
          "65"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define sensitive field marker in GlobalSettings model",
            "description": "Add json_schema_extra={'sensitive': True} to security-relevant fields in GlobalSettings using pydantic Field().",
            "dependencies": [],
            "details": "In settings.py, import Field from pydantic. Mark api_key, jira_token, and any other credential fields with Field(default=None, json_schema_extra={'sensitive': True}). This metadata enables the resolver to distinguish sensitive from non-sensitive fields at runtime.",
            "status": "pending",
            "testStrategy": "Test that GlobalSettings.model_fields['api_key'].json_schema_extra.get('sensitive') returns True for marked fields and None/False for unmarked fields.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add helper method to detect sensitive fields",
            "description": "Create _is_sensitive_field() helper in ConfigResolver to check field metadata.",
            "dependencies": [
              1
            ],
            "details": "Add method to ConfigResolver: def _is_sensitive_field(self, field_name: str) -> bool that retrieves FieldInfo from GlobalSettings.model_fields, checks json_schema_extra dict for 'sensitive' key. Return False if field not found or metadata missing. Keep logic isolated for testability.",
            "status": "pending",
            "testStrategy": "Unit test _is_sensitive_field() with mock GlobalSettings containing both sensitive and non-sensitive fields. Verify correct boolean returns.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement differentiated log levels in _log_sources()",
            "description": "Modify ConfigResolver._log_sources() to use INFO for sensitive fields and DEBUG for others.",
            "dependencies": [
              2
            ],
            "details": "In _log_sources(), iterate self._sources dict. For each field, call _is_sensitive_field(). If sensitive: logger.info(\"Security config '%s' loaded from %s\", field, source.value). Else: logger.debug(\"Config '%s' from %s\", field, source.value). Only log field names and source enum values, never actual config values.",
            "status": "pending",
            "testStrategy": "Mock logger, call _log_sources() with mixed sensitive/non-sensitive fields. Assert logger.info called only for sensitive fields, logger.debug for others.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add safeguard against value logging",
            "description": "Ensure no code path in ConfigResolver can log actual sensitive values.",
            "dependencies": [
              3
            ],
            "details": "Audit all logger calls in ConfigResolver. Remove or guard any that could include field values. Add code comment warning against logging values. Consider adding assertion in tests that scans all log format strings for value placeholders. The _log_sources method must only log: field name (str), source (ConfigSource enum) - never the resolved value.",
            "status": "pending",
            "testStrategy": "Capture all log output during config resolution. Use regex to verify no log messages contain actual secret values from test fixtures.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Write integration tests for audit logging",
            "description": "Add comprehensive tests verifying sensitive field audit logging behavior end-to-end.",
            "dependencies": [
              4
            ],
            "details": "Create tests/configuration/test_sensitive_logging.py. Test cases: (1) sensitive field from env logs at INFO with source, (2) sensitive field from file logs at INFO, (3) non-sensitive field logs at DEBUG only, (4) verify log messages contain field name and source but never actual values, (5) test with mock secrets like 'test-api-key-12345' and assert it never appears in captured logs.",
            "status": "pending",
            "testStrategy": "Use pytest caplog fixture to capture logs. Set log level to DEBUG. Verify exact log level (INFO vs DEBUG) for each field type. Grep captured logs for test secret values to ensure they're never present.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "70",
        "title": "Update module exports and docstrings",
        "description": "Ensure all new classes are properly exported, documented, and the module docstring explains the precedence system.",
        "details": "Update `__init__.py` module docstring and ensure clean exports:\n\n```python\n\"\"\"Configuration management with precedence: CLI > ENV > YAML > Defaults.\n\nUsage:\n    from buvis.pybase.configuration import get_settings\n    \n    # Basic usage (ENV and YAML)\n    settings = get_settings()\n    \n    # With CLI overrides\n    settings = get_settings(cli_overrides={\"debug\": True})\n    \n    # Access settings\n    if settings.debug:\n        ...\n\nPrecedence (highest to lowest):\n    1. CLI arguments (cli_overrides dict)\n    2. Environment variables (BUVIS_* prefix)\n    3. YAML config file (~/.config/buvis/config.yaml or BUVIS_CONFIG_FILE)\n    4. Model defaults\n\nLegacy:\n    The `cfg` singleton still works but doesn't support precedence.\n    Migrate to `get_settings()` for new code.\n\"\"\"\n```\n\nAlso add `__all__` to resolver.py and settings.py.",
        "testStrategy": "Verify all exports work: `from buvis.pybase.configuration import ConfigResolver, GlobalSettings, ConfigSource, get_settings`. Run `python -c` import test.",
        "priority": "low",
        "dependencies": [
          "67",
          "68"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Write comprehensive module docstring for configuration __init__.py",
            "description": "Add a detailed module docstring to configuration/__init__.py explaining the precedence system (CLI > ENV > YAML > Defaults), usage examples, and legacy compatibility notes.",
            "dependencies": [],
            "details": "Add the module docstring at the top of `src/buvis/pybase/configuration/__init__.py` before any imports. The docstring should include:\n1. One-line summary of the module purpose\n2. Usage examples with `get_settings()` for basic and CLI override scenarios\n3. Precedence hierarchy explanation (CLI > ENV > YAML > Defaults)\n4. Legacy note about `cfg` singleton still working but recommending `get_settings()` for new code\n\nFollow the format from the task description. Keep docstring concise per CLAUDE.md guidelines.",
            "status": "pending",
            "testStrategy": "Verify docstring renders correctly with `python -c \"import buvis.pybase.configuration; print(buvis.pybase.configuration.__doc__)\"`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add __all__ export list to resolver.py",
            "description": "Add explicit __all__ list to resolver.py exporting ConfigResolver and ConfigSource classes.",
            "dependencies": [],
            "details": "In `src/buvis/pybase/configuration/resolver.py` (created by task 67), add:\n\n```python\n__all__ = [\"ConfigResolver\", \"ConfigSource\"]\n```\n\nPlace after imports, before class definitions. Follow existing codebase pattern where `__all__` immediately follows imports. ConfigSource is likely an enum/class for tracking where config values came from.",
            "status": "pending",
            "testStrategy": "Verify `from buvis.pybase.configuration.resolver import ConfigResolver, ConfigSource` works and `resolver.__all__` contains expected exports.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add __all__ export list to settings.py",
            "description": "Add explicit __all__ list to settings.py exporting GlobalSettings and any related classes.",
            "dependencies": [],
            "details": "In `src/buvis/pybase/configuration/settings.py` (created by task 68), add:\n\n```python\n__all__ = [\"GlobalSettings\"]\n```\n\nPlace after imports, before class definitions. Follow existing codebase pattern. If there are additional settings classes (like ToolSettings per task 79), include those in __all__ as well.",
            "status": "pending",
            "testStrategy": "Verify `from buvis.pybase.configuration.settings import GlobalSettings` works and `settings.__all__` contains expected exports.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update __init__.py imports and __all__ to include new classes",
            "description": "Update configuration/__init__.py to import and export ConfigResolver, GlobalSettings, ConfigSource, and get_settings function.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Update `src/buvis/pybase/configuration/__init__.py` with new imports and exports:\n\n```python\nfrom .configuration import Configuration, ConfigurationKeyNotFoundError, cfg\nfrom .resolver import ConfigResolver, ConfigSource\nfrom .settings import GlobalSettings\n\n__all__ = [\n    \"Configuration\",\n    \"ConfigurationKeyNotFoundError\",\n    \"ConfigResolver\",\n    \"ConfigSource\",\n    \"GlobalSettings\",\n    \"cfg\",\n    \"get_settings\",\n]\n```\n\nAdd `get_settings` convenience function if not already in resolver.py. Follow alphabetical ordering in __all__ per existing adapters pattern.",
            "status": "pending",
            "testStrategy": "Verify all imports work: `from buvis.pybase.configuration import ConfigResolver, GlobalSettings, ConfigSource, get_settings, cfg`",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create import verification test script",
            "description": "Write a test or verification script to confirm all exports from configuration module work correctly.",
            "dependencies": [
              4
            ],
            "details": "Create verification either as:\n1. A pytest test in `tests/configuration/test_configuration_exports.py`, or\n2. A simple verification command\n\nTest should verify:\n```python\nfrom buvis.pybase.configuration import (\n    Configuration,\n    ConfigResolver,\n    ConfigSource,\n    ConfigurationKeyNotFoundError,\n    GlobalSettings,\n    cfg,\n    get_settings,\n)\n\n# Verify __all__ matches actual exports\nimport buvis.pybase.configuration as config_module\nassert set(config_module.__all__) == {\n    \"Configuration\", \"ConfigResolver\", \"ConfigSource\",\n    \"ConfigurationKeyNotFoundError\", \"GlobalSettings\", \"cfg\", \"get_settings\"\n}\n```",
            "status": "pending",
            "testStrategy": "Run `python -c \"from buvis.pybase.configuration import ConfigResolver, GlobalSettings, ConfigSource, get_settings\"` and `uv run pytest tests/configuration/` to verify all exports work.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "71",
        "title": "Refactor ConfigResolver to use ConfigurationLoader",
        "description": "Update ConfigResolver to use ConfigurationLoader.find_config_files() for multi-file discovery instead of single YAML loading.",
        "details": "Modify `src/buvis/pybase/configuration/resolver.py` to integrate with ConfigurationLoader:\n\n```python\nfrom __future__ import annotations\nimport os\nimport logging\nfrom typing import Any\nfrom .loader import ConfigurationLoader\nfrom .settings import GlobalSettings\n\nclass ConfigResolver:\n    def __init__(self, tool_name: str | None = None) -> None:\n        self.tool_name = tool_name\n        self.loader = ConfigurationLoader()\n        self._logger = logging.getLogger(__name__)\n\n    def resolve(\n        self,\n        config_dir: str | None = None,\n        cli_overrides: dict[str, Any] | None = None,\n    ) -> GlobalSettings:\n        # Set config dir override if provided\n        if config_dir:\n            os.environ[\"BUVIS_CONFIG_DIR\"] = config_dir\n\n        # Find and load YAML files\n        yaml_files = self.loader.find_config_files(tool_name=self.tool_name)\n        merged_yaml: dict[str, Any] = {}\n        for path in yaml_files:\n            file_config = self.loader.load_yaml(path)\n            merged_yaml = self.loader.merge_configs(merged_yaml, file_config)\n\n        # Create settings (YAML as base, Pydantic loads ENV)\n        settings = GlobalSettings(**merged_yaml)\n\n        # Apply CLI overrides\n        if cli_overrides:\n            for key, value in cli_overrides.items():\n                if value is not None and hasattr(settings, key):\n                    setattr(settings, key, value)\n\n        return settings\n```\n\nThis replaces the simpler single-file loader with multi-file discovery using ConfigurationLoader from tasks 11-20.",
        "testStrategy": "Unit test: mock ConfigurationLoader.find_config_files to return multiple paths. Verify all paths loaded and merged in order. Test with tool_name=None and tool_name='payroll'.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ConfigResolver class skeleton with ConfigurationLoader dependency",
            "description": "Create the resolver.py file with ConfigResolver class that imports and instantiates ConfigurationLoader.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/resolver.py` with basic structure:\n\n```python\nfrom __future__ import annotations\nimport os\nimport logging\nfrom typing import Any\nfrom .loader import ConfigurationLoader\nfrom .settings import GlobalSettings\n\nclass ConfigResolver:\n    \"\"\"Resolves configuration from multiple YAML files with ENV/CLI overrides.\"\"\"\n    \n    def __init__(self, tool_name: str | None = None) -> None:\n        self.tool_name = tool_name\n        self.loader = ConfigurationLoader()\n        self._logger = logging.getLogger(__name__)\n```\n\nThis establishes the dependency on ConfigurationLoader (from tasks 11-20) and GlobalSettings (from task 2). The class accepts optional tool_name for tool-specific config discovery.",
            "status": "done",
            "testStrategy": "Unit test: verify ConfigResolver instantiation creates ConfigurationLoader. Test with tool_name=None and tool_name='payroll'. Verify logger is configured.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:04:12.317Z"
          },
          {
            "id": 2,
            "title": "Implement resolve() method with multi-file discovery",
            "description": "Add resolve() method that calls ConfigurationLoader.find_config_files() and loads all discovered YAML files.",
            "dependencies": [
              1
            ],
            "details": "Add resolve() method to ConfigResolver:\n\n```python\ndef resolve(\n    self,\n    config_dir: str | None = None,\n    cli_overrides: dict[str, Any] | None = None,\n) -> GlobalSettings:\n    # Set config dir override if provided\n    if config_dir:\n        os.environ[\"BUVIS_CONFIG_DIR\"] = config_dir\n    \n    # Find YAML files (base + tool-specific)\n    yaml_files = self.loader.find_config_files(tool_name=self.tool_name)\n    self._logger.debug(\"Found config files: %s\", yaml_files)\n    \n    # Load each file\n    merged_yaml: dict[str, Any] = {}\n    for path in yaml_files:\n        file_config = self.loader.load_yaml(path)\n        merged_yaml = self.loader.merge_configs(merged_yaml, file_config)\n```\n\nThis replaces single-file loading with multi-file discovery. The config_dir param allows overriding the search directory via BUVIS_CONFIG_DIR env var.",
            "status": "done",
            "testStrategy": "Mock ConfigurationLoader.find_config_files to return ['/path/buvis.yaml', '/path/buvis-tool.yaml']. Verify load_yaml called for each path in order. Test config_dir sets BUVIS_CONFIG_DIR env var.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:04:12.365Z"
          },
          {
            "id": 3,
            "title": "Add GlobalSettings instantiation with merged YAML data",
            "description": "Complete resolve() by creating GlobalSettings from merged YAML dict, letting Pydantic handle ENV resolution.",
            "dependencies": [
              2
            ],
            "details": "Continue resolve() method after merging:\n\n```python\n    # Create settings from merged YAML\n    # Pydantic BaseSettings handles ENV variables automatically\n    settings = GlobalSettings(**merged_yaml)\n    self._logger.debug(\"Created settings: %s\", settings.model_dump())\n    \n    return settings\n```\n\nGlobalSettings inherits from pydantic_settings.BaseSettings (task 2), so it automatically:\n- Validates all fields at instantiation\n- Resolves BUVIS_* environment variables\n- Applies field defaults where YAML/ENV missing\n\nThe merged_yaml dict provides base values that ENV can override per Pydantic precedence.",
            "status": "done",
            "testStrategy": "Mock GlobalSettings constructor. Verify it receives merged dict from loader. Test that ValidationError from GlobalSettings propagates up. Test empty merged_yaml creates settings with defaults.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:04:12.409Z"
          },
          {
            "id": 4,
            "title": "Implement CLI overrides application",
            "description": "Add CLI override logic that applies command-line values on top of resolved settings.",
            "dependencies": [
              3
            ],
            "details": "Add CLI override handling before returning settings:\n\n```python\n    # Apply CLI overrides (highest precedence)\n    if cli_overrides:\n        for key, value in cli_overrides.items():\n            if value is not None and hasattr(settings, key):\n                setattr(settings, key, value)\n                self._logger.debug(\"CLI override: %s=%s\", key, value)\n    \n    return settings\n```\n\nCLI overrides have highest precedence: YAML < ENV < CLI. Only non-None values for existing attributes are applied. This supports patterns like `--verbose` or `--config-dir` from command line.",
            "status": "done",
            "testStrategy": "Test cli_overrides={'log_level': 'DEBUG'} updates settings.log_level. Test cli_overrides={'unknown': 'x'} is ignored (no hasattr). Test cli_overrides={'log_level': None} is skipped. Test empty cli_overrides dict does nothing.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:04:12.583Z"
          },
          {
            "id": 5,
            "title": "Export ConfigResolver in configuration module __init__.py",
            "description": "Update configuration/__init__.py to export ConfigResolver alongside existing Configuration class.",
            "dependencies": [
              4
            ],
            "details": "Update `src/buvis/pybase/configuration/__init__.py`:\n\n```python\nfrom .configuration import Configuration, ConfigurationKeyNotFoundError, cfg\nfrom .resolver import ConfigResolver\n\n__all__ = [\n    \"Configuration\",\n    \"ConfigurationKeyNotFoundError\",\n    \"cfg\",\n    \"ConfigResolver\",\n]\n```\n\nThis maintains backward compatibility with existing Configuration singleton while exposing the new ConfigResolver for Pydantic-based config. Users can import either:\n- `from buvis.pybase.configuration import cfg` (legacy)\n- `from buvis.pybase.configuration import ConfigResolver` (new)",
            "status": "done",
            "testStrategy": "Test `from buvis.pybase.configuration import ConfigResolver` succeeds. Verify existing imports still work: `from buvis.pybase.configuration import cfg, Configuration`. Check __all__ contains all expected exports.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:04:13.010Z"
          }
        ],
        "updatedAt": "2026-01-02T18:04:13.010Z"
      },
      {
        "id": "72",
        "title": "Add tool_name parameter support",
        "description": "Implement tool_name parameter that passes to ConfigurationLoader for tool-specific config file discovery (buvis-{tool}.yaml).",
        "details": "The tool_name parameter enables loading tool-specific configs:\n\n```python\n# Usage\nresolver = ConfigResolver(tool_name=\"payroll\")\nsettings = resolver.resolve()\n# Loads: buvis.yaml + buvis-payroll.yaml (merged)\n```\n\nIn resolve():\n```python\nyaml_files = self.loader.find_config_files(tool_name=self.tool_name)\n# Returns paths like:\n# - ~/.config/buvis/buvis.yaml (base)\n# - ~/.config/buvis/buvis-payroll.yaml (tool-specific)\n```\n\nTool-specific files are merged on top of base config per PRD-00002 discovery order. Later files override earlier values.\n\nValidation:\n```python\ndef __init__(self, tool_name: str | None = None) -> None:\n    if tool_name is not None:\n        if not tool_name.islower() or '-' in tool_name:\n            raise ValueError(\"tool_name must be lowercase without hyphens\")\n    self.tool_name = tool_name\n```",
        "testStrategy": "Test: ConfigResolver() finds only buvis.yaml. Test: ConfigResolver(tool_name='payroll') finds buvis.yaml + buvis-payroll.yaml. Test: tool_name='PayRoll' raises ValueError. Verify merge order (tool-specific overrides base).",
        "priority": "high",
        "dependencies": [
          "71"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add tool_name validation in ConfigResolver.__init__",
            "description": "Implement validation that rejects tool_name values with uppercase letters or hyphens.",
            "dependencies": [],
            "details": "Add validation logic after tool_name assignment in __init__:\n```python\ndef __init__(self, tool_name: str | None = None) -> None:\n    if tool_name is not None:\n        if not tool_name.islower() or '-' in tool_name:\n            msg = \"tool_name must be lowercase without hyphens\"\n            raise ValueError(msg)\n    self.tool_name = tool_name\n    self.loader = ConfigurationLoader()\n    self._logger = logging.getLogger(__name__)\n```\nThe validation ensures tool names like 'payroll' pass while 'PayRoll' or 'pay-roll' fail. This prevents inconsistent file naming (buvis-Pay-Roll.yaml vs buvis-payroll.yaml).",
            "status": "pending",
            "testStrategy": "Test ValueError raised for 'PayRoll', 'UPPER', 'with-hyphen'. Test None and 'lowercase' accepted.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Verify tool_name passed to ConfigurationLoader.find_config_files",
            "description": "Ensure resolve() correctly passes self.tool_name to loader.find_config_files() for tool-specific discovery.",
            "dependencies": [
              1
            ],
            "details": "In resolve() method, confirm the call passes tool_name:\n```python\nyaml_files = self.loader.find_config_files(tool_name=self.tool_name)\n```\nThis is already in task 71's implementation but needs explicit verification. The find_config_files method (PRD-00002) generates candidates:\n- base / \"buvis.yaml\" for all searches\n- base / f\"buvis-{tool_name}.yaml\" when tool_name provided\n\nAdd debug logging: `self._logger.debug(\"Finding configs with tool_name=%s\", self.tool_name)`",
            "status": "pending",
            "testStrategy": "Mock loader.find_config_files, verify it receives tool_name=None when not set, tool_name='payroll' when set.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create test_resolver.py with TestConfigResolverInit class",
            "description": "Create test file for ConfigResolver with tests covering __init__ tool_name validation.",
            "dependencies": [
              1
            ],
            "details": "Create tests/configuration/test_resolver.py:\n```python\nimport pytest\nfrom buvis.pybase.configuration.resolver import ConfigResolver\n\nclass TestConfigResolverInit:\n    def test_init_no_tool_name(self) -> None:\n        resolver = ConfigResolver()\n        assert resolver.tool_name is None\n\n    def test_init_valid_tool_name(self) -> None:\n        resolver = ConfigResolver(tool_name=\"payroll\")\n        assert resolver.tool_name == \"payroll\"\n\n    def test_init_uppercase_raises(self) -> None:\n        with pytest.raises(ValueError, match=\"lowercase\"):\n            ConfigResolver(tool_name=\"PayRoll\")\n\n    def test_init_hyphen_raises(self) -> None:\n        with pytest.raises(ValueError, match=\"hyphens\"):\n            ConfigResolver(tool_name=\"pay-roll\")\n```",
            "status": "pending",
            "testStrategy": "Run pytest tests/configuration/test_resolver.py::TestConfigResolverInit -v",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add tests for tool_name file discovery behavior",
            "description": "Test that ConfigResolver without tool_name finds only buvis.yaml while with tool_name finds both base and tool-specific files.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add TestConfigResolverToolNameDiscovery class:\n```python\nfrom unittest.mock import Mock, patch\nfrom pathlib import Path\n\nclass TestConfigResolverToolNameDiscovery:\n    def test_resolve_without_tool_name_calls_loader_with_none(self) -> None:\n        resolver = ConfigResolver()\n        with patch.object(resolver.loader, 'find_config_files', return_value=[]) as mock_find:\n            with patch.object(resolver.loader, 'load_yaml', return_value={}):\n                resolver.resolve()\n        mock_find.assert_called_once_with(tool_name=None)\n\n    def test_resolve_with_tool_name_calls_loader_with_value(self) -> None:\n        resolver = ConfigResolver(tool_name=\"payroll\")\n        with patch.object(resolver.loader, 'find_config_files', return_value=[]) as mock_find:\n            resolver.resolve()\n        mock_find.assert_called_once_with(tool_name=\"payroll\")\n```",
            "status": "pending",
            "testStrategy": "Verify mock assertions pass showing correct tool_name propagation.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add tests for tool-specific config merge order",
            "description": "Test that tool-specific configs are merged on top of base configs, with tool values overriding base values.",
            "dependencies": [
              4
            ],
            "details": "Add TestConfigResolverMergeOrder class:\n```python\nclass TestConfigResolverMergeOrder:\n    def test_tool_config_overrides_base(self) -> None:\n        resolver = ConfigResolver(tool_name=\"payroll\")\n        base = Path(\"/config/buvis.yaml\")\n        tool = Path(\"/config/buvis-payroll.yaml\")\n        \n        with patch.object(resolver.loader, 'find_config_files', return_value=[base, tool]):\n            with patch.object(resolver.loader, 'load_yaml', side_effect=[\n                {\"log_level\": \"INFO\", \"debug\": False},  # base\n                {\"log_level\": \"DEBUG\"},  # tool-specific override\n            ]):\n                with patch.object(resolver.loader, 'merge_configs', wraps=resolver.loader.merge_configs):\n                    settings = resolver.resolve()\n        \n        # Tool-specific log_level=DEBUG should override base log_level=INFO\n        assert settings.log_level == \"DEBUG\"\n        assert settings.debug is False  # preserved from base\n```\nPer PRD-00002: later files override earlier values.",
            "status": "pending",
            "testStrategy": "Verify merged settings have tool-specific values overriding base while preserving non-overridden base values.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:48:16.345Z"
      },
      {
        "id": "73",
        "title": "Add config_dir runtime override",
        "description": "Implement config_dir parameter in resolve() that temporarily sets BUVIS_CONFIG_DIR for custom config locations.",
        "details": "Enable runtime config directory override:\n\n```python\ndef resolve(\n    self,\n    config_dir: str | None = None,\n    cli_overrides: dict[str, Any] | None = None,\n) -> GlobalSettings:\n    original_dir = os.environ.get(\"BUVIS_CONFIG_DIR\")\n    try:\n        if config_dir:\n            os.environ[\"BUVIS_CONFIG_DIR\"] = config_dir\n        # ... rest of resolve logic ...\n    finally:\n        # Restore original\n        if original_dir is None:\n            os.environ.pop(\"BUVIS_CONFIG_DIR\", None)\n        else:\n            os.environ[\"BUVIS_CONFIG_DIR\"] = original_dir\n```\n\nUse try/finally to ensure env var restored after resolve completes. This allows:\n```python\nsettings = resolver.resolve(config_dir=\"/etc/buvis\")\n```\n\nwithout permanently modifying environment.",
        "testStrategy": "Test: config_dir='/tmp/custom' changes where configs loaded from. Test: BUVIS_CONFIG_DIR restored after resolve(). Test: resolve() works without config_dir (uses default discovery).",
        "priority": "high",
        "dependencies": [
          "71"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add config_dir parameter to resolve() method signature",
            "description": "Update the resolve() method signature to accept an optional config_dir parameter for runtime config directory override.",
            "dependencies": [],
            "details": "In `src/buvis/pybase/configuration/resolver.py`, modify the resolve() method signature:\n\n```python\ndef resolve(\n    self,\n    config_dir: str | None = None,\n    cli_overrides: dict[str, Any] | None = None,\n) -> GlobalSettings:\n```\n\nEnsure the parameter is typed as `str | None` following the project's modern type hint style from `__future__ import annotations`.",
            "status": "pending",
            "testStrategy": "Verify resolve() accepts config_dir parameter without error. Test with config_dir=None (default) still works.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement env var save and set logic at method start",
            "description": "Add code to save original BUVIS_CONFIG_DIR value and set new value when config_dir provided.",
            "dependencies": [
              1
            ],
            "details": "At the start of resolve() method, before any config loading:\n\n```python\noriginal_dir = os.environ.get(\"BUVIS_CONFIG_DIR\")\nif config_dir:\n    os.environ[\"BUVIS_CONFIG_DIR\"] = config_dir\n```\n\nUse `os.environ.get()` to capture original value (returns None if not set). Only modify env var if config_dir argument is truthy.",
            "status": "pending",
            "testStrategy": "Mock os.environ. Verify BUVIS_CONFIG_DIR gets set when config_dir='/tmp/custom'. Verify no change when config_dir=None.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Wrap resolve logic in try/finally for env var restoration",
            "description": "Wrap the existing resolve logic in try/finally block to ensure BUVIS_CONFIG_DIR is always restored.",
            "dependencies": [
              2
            ],
            "details": "Wrap all config loading and resolution logic in try block with finally for cleanup:\n\n```python\ntry:\n    # ... existing resolve logic: find_config_files, load_yaml, merge, GlobalSettings ...\n    return settings\nfinally:\n    if original_dir is None:\n        os.environ.pop(\"BUVIS_CONFIG_DIR\", None)\n    else:\n        os.environ[\"BUVIS_CONFIG_DIR\"] = original_dir\n```\n\nUse `os.environ.pop()` with default to avoid KeyError if var was never set.",
            "status": "pending",
            "testStrategy": "Test restoration after successful resolve. Test restoration after resolve raises exception. Verify original value restored, not just deleted.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Write tests for config_dir parameter functionality",
            "description": "Add test class for config_dir override behavior covering set, restore, and edge cases.",
            "dependencies": [
              3
            ],
            "details": "In `tests/configuration/test_config_resolver.py`, add `TestConfigResolverConfigDir` class:\n\n```python\nclass TestConfigResolverConfigDir:\n    @patch.dict(os.environ, {}, clear=True)\n    def test_config_dir_sets_env_var(self, mock_loader):\n        # Verify config_dir='/tmp/custom' sets BUVIS_CONFIG_DIR during resolve\n\n    @patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": \"/original\"}, clear=False)\n    def test_config_dir_restores_original(self, mock_loader):\n        # Verify original value restored after resolve completes\n\n    @patch.dict(os.environ, {}, clear=True)\n    def test_config_dir_removes_when_originally_unset(self, mock_loader):\n        # Verify env var removed (not left empty) when originally unset\n```\n\nFollow existing `@patch.dict(os.environ, ...)` pattern from test_shell_adapter.py.",
            "status": "pending",
            "testStrategy": "Run pytest on new tests. Verify all three scenarios pass: setting, restoring original, removing when unset.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test env var restoration on exception during resolve",
            "description": "Add test verifying BUVIS_CONFIG_DIR restored even when resolve() raises an exception.",
            "dependencies": [
              4
            ],
            "details": "Add test to verify try/finally cleanup works on error:\n\n```python\n@patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": \"/original\"}, clear=False)\ndef test_config_dir_restored_on_exception(self, mock_loader):\n    mock_loader.find_config_files.side_effect = PermissionError(\"denied\")\n    resolver = ConfigResolver()\n    \n    with pytest.raises(PermissionError):\n        resolver.resolve(config_dir=\"/custom\")\n    \n    assert os.environ.get(\"BUVIS_CONFIG_DIR\") == \"/original\"\n```\n\nThis ensures cleanup happens in finally block regardless of success/failure.",
            "status": "pending",
            "testStrategy": "Test passes when PermissionError raised and BUVIS_CONFIG_DIR equals '/original' after.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:50:37.742Z"
      },
      {
        "id": "74",
        "title": "Implement enhanced YAML error handling",
        "description": "Wrap YAML loading to catch yaml.YAMLError and re-raise with file path and line number in ConfigurationError.",
        "details": "Create enhanced error handling in resolver:\n\n```python\nfrom buvis.pybase.configuration.exceptions import ConfigurationError\nimport yaml\n\ndef _load_yaml_with_context(self, path: Path) -> dict[str, Any]:\n    \"\"\"Load YAML with enhanced error context.\"\"\"\n    try:\n        return self.loader.load_yaml(path)\n    except yaml.YAMLError as e:\n        line = getattr(e, 'problem_mark', None)\n        line_num = line.line + 1 if line else 'unknown'\n        raise ConfigurationError(\n            f\"YAML syntax error in {path}:{line_num}: {e}\"\n        ) from e\n    except PermissionError:\n        self._logger.warning(\"Permission denied reading %s, skipping\", path)\n        return {}  # Skip file, continue loading per PRD\n```\n\nAdd ConfigurationError to exceptions.py:\n```python\nclass ConfigurationError(Exception):\n    \"\"\"Configuration loading or validation failed.\"\"\"\n    pass\n```\n\nPermission denied skips file and continues (PRD error table).",
        "testStrategy": "Test: invalid YAML raises ConfigurationError with file path and line number. Test: permission denied logs warning and returns empty dict. Test: error message is clear and actionable.",
        "priority": "high",
        "dependencies": [
          "71"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add ConfigurationError exception class to exceptions.py",
            "description": "Create a new ConfigurationError exception in the existing exceptions.py file for configuration loading/validation failures.",
            "dependencies": [],
            "details": "Add ConfigurationError class to src/buvis/pybase/configuration/exceptions.py following the existing pattern:\n\n```python\nclass ConfigurationError(Exception):\n    \"\"\"Configuration loading or validation failed.\"\"\"\n    pass\n```\n\nPlace it after ConfigurationKeyNotFoundError. Keep it minimal - no custom __init__ needed since the message will be constructed at raise site.",
            "status": "pending",
            "testStrategy": "Unit test verifying ConfigurationError can be raised and caught, and preserves message correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Export ConfigurationError from configuration __init__.py",
            "description": "Update the configuration module's __init__.py to export the new ConfigurationError exception for public use.",
            "dependencies": [
              1
            ],
            "details": "Modify src/buvis/pybase/configuration/__init__.py:\n\n1. Add import: `from .exceptions import ConfigurationError`\n2. Add to __all__: append \"ConfigurationError\"\n\nResult:\n```python\nfrom .configuration import Configuration, ConfigurationKeyNotFoundError, cfg\nfrom .exceptions import ConfigurationError\n\n__all__ = [\"Configuration\", \"ConfigurationKeyNotFoundError\", \"ConfigurationError\", \"cfg\"]\n```",
            "status": "pending",
            "testStrategy": "Verify import works: `from buvis.pybase.configuration import ConfigurationError`",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement _load_yaml_with_context method in resolver",
            "description": "Create the enhanced YAML loading method that wraps yaml.safe_load and catches yaml.YAMLError to re-raise with file path and line number context.",
            "dependencies": [
              1,
              2
            ],
            "details": "In src/buvis/pybase/configuration/resolver.py (created by Task 64), add method:\n\n```python\ndef _load_yaml_with_context(self, path: Path) -> dict[str, Any]:\n    \"\"\"Load YAML with enhanced error context.\"\"\"\n    try:\n        return self.loader.load_yaml(path)\n    except yaml.YAMLError as e:\n        line = getattr(e, 'problem_mark', None)\n        line_num = line.line + 1 if line else 'unknown'\n        raise ConfigurationError(\n            f\"YAML syntax error in {path}:{line_num}: {e}\"\n        ) from e\n```\n\nRequires import: `import yaml` and `from .exceptions import ConfigurationError`",
            "status": "pending",
            "testStrategy": "Test with invalid YAML: verify ConfigurationError raised with correct file path and line number in message.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add PermissionError handling to _load_yaml_with_context",
            "description": "Extend the YAML loading method to gracefully handle PermissionError by logging a warning and returning empty dict to allow loading to continue.",
            "dependencies": [
              3
            ],
            "details": "Extend _load_yaml_with_context in resolver.py:\n\n```python\ndef _load_yaml_with_context(self, path: Path) -> dict[str, Any]:\n    \"\"\"Load YAML with enhanced error context.\"\"\"\n    try:\n        return self.loader.load_yaml(path)\n    except yaml.YAMLError as e:\n        line = getattr(e, 'problem_mark', None)\n        line_num = line.line + 1 if line else 'unknown'\n        raise ConfigurationError(\n            f\"YAML syntax error in {path}:{line_num}: {e}\"\n        ) from e\n    except PermissionError:\n        self._logger.warning(\"Permission denied reading %s, skipping\", path)\n        return {}  # Skip file, continue loading per PRD\n```\n\nRequires: `self._logger = logging.getLogger(__name__)` in __init__",
            "status": "pending",
            "testStrategy": "Mock file read to raise PermissionError. Verify empty dict returned and warning logged.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add comprehensive tests for enhanced YAML error handling",
            "description": "Create tests covering YAML syntax errors, permission denied scenarios, and error message format validation.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create tests/configuration/test_resolver.py (or extend if exists):\n\n```python\nimport pytest\nfrom unittest.mock import Mock, patch\nfrom pathlib import Path\nimport yaml\n\nfrom buvis.pybase.configuration.resolver import ConfigResolver\nfrom buvis.pybase.configuration import ConfigurationError\n\n\nclass TestLoadYamlWithContext:\n    def test_yaml_error_includes_file_path(self, resolver):\n        # Mock loader to raise yaml.YAMLError with problem_mark\n        ...\n        with pytest.raises(ConfigurationError, match=r\"test\\.yaml:5:\"):\n            resolver._load_yaml_with_context(Path(\"test.yaml\"))\n\n    def test_yaml_error_without_line_number(self, resolver):\n        # Test when problem_mark is None -> 'unknown' line\n        ...\n\n    def test_permission_denied_returns_empty_dict(self, resolver):\n        ...\n        assert result == {}\n\n    def test_permission_denied_logs_warning(self, resolver, caplog):\n        ...\n        assert \"Permission denied\" in caplog.text\n```",
            "status": "pending",
            "testStrategy": "Run pytest on new test file. All 4+ test cases must pass. Verify error messages are actionable.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:53:29.288Z"
      },
      {
        "id": "75",
        "title": "Implement type validation error handling",
        "description": "Wrap Pydantic ValidationError to provide field path and expected type in ConfigurationError.",
        "details": "Enhance resolve() to wrap validation errors:\n\n```python\nfrom pydantic import ValidationError\n\ndef resolve(self, ...) -> GlobalSettings:\n    # ... merge yaml ...\n    \n    try:\n        settings = GlobalSettings(**merged_yaml)\n    except ValidationError as e:\n        errors = []\n        for err in e.errors():\n            field_path = '.'.join(str(loc) for loc in err['loc'])\n            msg = err['msg']\n            errors.append(f\"  {field_path}: {msg}\")\n        raise ConfigurationError(\n            f\"Configuration validation failed:\\n\" + \"\\n\".join(errors)\n        ) from e\n    \n    # ... apply CLI ...\n    return settings\n```\n\nThis transforms Pydantic's technical errors into user-friendly messages:\n```\nConfiguration validation failed:\n  log_level: Input should be 'DEBUG', 'INFO', 'WARNING', 'ERROR' or 'CRITICAL'\n  database.pool.min_size: Input should be a valid integer\n```",
        "testStrategy": "Test: invalid log_level raises ConfigurationError with field path. Test: nested field validation (database.pool.min_size) shows full path. Test: multiple errors listed together.",
        "priority": "high",
        "dependencies": [
          "71",
          "74"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add ValidationError import and error formatting helper",
            "description": "Import Pydantic ValidationError in resolver.py and create helper function to format validation errors into user-friendly strings.",
            "dependencies": [],
            "details": "In `src/buvis/pybase/configuration/resolver.py`, add import `from pydantic import ValidationError`. Create a private helper method `_format_validation_errors(self, errors: list[dict]) -> list[str]` that iterates over Pydantic error dicts, joins the 'loc' tuple with dots to create field paths (e.g., 'database.pool.min_size'), and combines with 'msg' to create formatted error lines like '  {field_path}: {msg}'.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Wrap GlobalSettings instantiation in try/except block",
            "description": "Modify resolve() method to catch Pydantic ValidationError when instantiating GlobalSettings from merged YAML config.",
            "dependencies": [
              1
            ],
            "details": "In the `resolve()` method of ConfigResolver, wrap the `settings = GlobalSettings(**merged_yaml)` call in a try/except block that catches `ValidationError as e`. This is the core modification that enables catching type validation failures from Pydantic's model validation.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Raise ConfigurationError with formatted validation messages",
            "description": "In the except block, convert Pydantic errors to formatted strings and raise ConfigurationError with user-friendly message.",
            "dependencies": [
              1,
              2
            ],
            "details": "In the ValidationError except block: call `e.errors()` to get error list, use the helper from subtask 1 to format each error, join with newlines, and raise `ConfigurationError(f\"Configuration validation failed:\\n\" + \"\\n\".join(errors)) from e`. The `from e` preserves the original traceback for debugging.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add tests for single field validation errors",
            "description": "Write tests verifying ConfigurationError is raised with correct field path for invalid single field values like log_level.",
            "dependencies": [
              3
            ],
            "details": "In `tests/configuration/test_resolver.py`, create `TestValidationErrorHandling` class. Add test: pass invalid log_level (e.g., 'INVALID') to resolve(), assert `pytest.raises(ConfigurationError)`, verify error message contains 'log_level' field path and describes the validation failure.",
            "status": "pending",
            "testStrategy": "Test: provide YAML with log_level='INVALID', verify ConfigurationError raised and message contains 'log_level' and expected type hint.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add tests for nested field paths and multiple errors",
            "description": "Write tests for nested field validation (database.pool.min_size) and multiple simultaneous validation errors.",
            "dependencies": [
              4
            ],
            "details": "Add two more tests: (1) Pass invalid nested value (e.g., database.pool.min_size='not_int'), verify error message shows full dotted path 'database.pool.min_size'. (2) Pass YAML with multiple invalid fields, verify all errors appear in the ConfigurationError message, demonstrating batch error reporting.",
            "status": "pending",
            "testStrategy": "Test: nested field shows 'database.pool.min_size' in error. Test: multiple invalid fields results in multiple error lines listed together in exception message.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:02:25.881Z"
      },
      {
        "id": "76",
        "title": "Add secret masking in error messages",
        "description": "Ensure error messages never include values of fields that look like secrets (password, token, key, secret).",
        "details": "Add secret detection to error formatting:\n\n```python\nimport re\n\n_SENSITIVE_PATTERN = re.compile(\n    r'(password|secret|token|api[_-]?key|auth|credential)',\n    re.IGNORECASE\n)\n\ndef _is_sensitive_field(field_path: str) -> bool:\n    return bool(_SENSITIVE_PATTERN.search(field_path))\n\ndef _format_validation_error(self, e: ValidationError) -> str:\n    errors = []\n    for err in e.errors():\n        field_path = '.'.join(str(loc) for loc in err['loc'])\n        if _is_sensitive_field(field_path):\n            msg = \"invalid value (hidden)\"\n        else:\n            msg = err['msg']\n        errors.append(f\"  {field_path}: {msg}\")\n    return \"Configuration validation failed:\\n\" + \"\\n\".join(errors)\n```\n\nPer PRD security: \"Mask secrets in errors: Don't include secret values in error messages\"\n\nAlso ensure YAML loading errors don't leak secrets:\n```python\nexcept yaml.YAMLError as e:\n    # YAMLError doesn't typically include values, but sanitize just in case\n    raise ConfigurationError(\n        f\"YAML syntax error in {path}: check line {line_num}\"\n    )\n```",
        "testStrategy": "Test: validation error on 'api_key' field shows 'invalid value (hidden)' not actual value. Test: error on 'database_password' masked. Test: error on 'debug' shows actual message.",
        "priority": "medium",
        "dependencies": [
          "75"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create sensitive field detection module",
            "description": "Implement the core pattern matching logic to detect field names that contain sensitive data like passwords, tokens, keys, and secrets.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/secrets.py` with:\n- `_SENSITIVE_PATTERN` regex compiled pattern matching: password, secret, token, api_key, api-key, auth, credential (case-insensitive)\n- `is_sensitive_field(field_path: str) -> bool` function that checks if any part of a dotted field path matches the pattern\n- Export from module `__init__.py`\n- Use `re.IGNORECASE` flag for case-insensitive matching",
            "status": "pending",
            "testStrategy": "Test is_sensitive_field returns True for: 'password', 'api_key', 'database.password', 'auth_token', 'API_KEY'. Returns False for: 'debug', 'username', 'database.host'.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement validation error formatter with masking",
            "description": "Create a formatter function that processes pydantic ValidationError instances and masks values from sensitive fields.",
            "dependencies": [
              1
            ],
            "details": "In `secrets.py` add:\n- `format_validation_error(e: ValidationError) -> str` function\n- Iterates through `e.errors()`, extracts field path from `loc` tuple\n- For sensitive fields: replace error message with 'invalid value (hidden)'\n- For non-sensitive fields: use original `msg`\n- Returns formatted string: 'Configuration validation failed:\\n' + joined errors\n- Handle edge cases: empty loc, nested paths with integers (list indices)",
            "status": "pending",
            "testStrategy": "Mock ValidationError with errors on 'api_key' (should mask), 'database.password' (should mask), 'debug' (should show actual msg). Verify output format matches expected pattern.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add safe YAML error handling",
            "description": "Ensure YAML parsing errors are caught and re-raised without potentially leaking sensitive configuration values.",
            "dependencies": [],
            "details": "In `configuration.py` `_load_configuration` method:\n- Wrap `yaml.safe_load` in try/except for `yaml.YAMLError`\n- Extract line number from `e.problem_mark.line` if available\n- Raise `ConfigurationError` (or custom exception) with sanitized message: 'YAML syntax error in {path}: check line {line_num}'\n- Never include the problematic YAML content in error message\n- Add `ConfigurationError` to exceptions.py if not present",
            "status": "pending",
            "testStrategy": "Feed malformed YAML with sensitive-looking content (e.g., 'password: secret\\n  bad_indent'). Verify raised error contains only path + line number, not the actual content.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate masking into configuration resolver",
            "description": "Connect the validation error formatter to the configuration resolution flow so all validation errors use masked output.",
            "dependencies": [
              1,
              2
            ],
            "details": "In the config resolver (likely added by task 75):\n- Import `format_validation_error` from secrets module\n- Catch `ValidationError` during settings resolution\n- Call `format_validation_error(e)` to get sanitized message\n- Raise `ConfigurationError` with the sanitized message\n- Ensure integration works with both CLI override validation and YAML/env validation\n- Do NOT mask field names, only values/error messages containing values",
            "status": "pending",
            "testStrategy": "End-to-end test: create settings with api_key field, provide invalid value, verify error message shows 'api_key: invalid value (hidden)' not the actual invalid value.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add comprehensive tests for secret masking",
            "description": "Create test module with full coverage of secret detection and error masking functionality.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create `tests/configuration/test_secrets.py`:\n- TestIsSensitiveField class: test various field names (positive/negative cases), test dotted paths, test case insensitivity\n- TestFormatValidationError class: mock ValidationError objects, verify masking behavior, verify non-sensitive fields show actual messages\n- TestYamlErrorHandling class: test malformed YAML doesn't leak content\n- Use pytest fixtures for common test data\n- Follow existing test patterns from test_shell_adapter.py",
            "status": "pending",
            "testStrategy": "Run pytest with coverage. Verify >90% coverage on secrets.py. All edge cases covered: empty strings, unicode field names, deeply nested paths.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "77",
        "title": "Implement immutable settings after resolve",
        "description": "Ensure GlobalSettings uses frozen=True and document that settings should not be modified after resolve().",
        "details": "Verify GlobalSettings has frozen config (from task 62):\n\n```python\nclass GlobalSettings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_\",\n        env_nested_delimiter=\"__\",\n        frozen=True,  # CRITICAL: makes settings immutable\n        extra=\"forbid\",\n    )\n```\n\nWith frozen=True, any attempt to modify raises:\n```python\nsettings = resolver.resolve()\nsettings.debug = True  # Raises ValidationError\n```\n\nAdd docstring to resolve():\n```python\ndef resolve(self, ...) -> GlobalSettings:\n    \"\"\"Load configuration with precedence: CLI > ENV > YAML > Defaults.\n    \n    Returns:\n        GlobalSettings: Immutable settings object. Do not attempt to\n        modify after resolution - changes will raise ValidationError.\n        \n    Warning:\n        Call resolve() once per process. Multiple calls are inefficient\n        and may produce inconsistent results if environment changes.\n    \"\"\"\n```\n\nPer PRD: \"No reload: Settings immutable after resolve() returns\"",
        "testStrategy": "Test: attempt to setattr on resolved settings raises ValidationError. Test: nested settings (settings.database.url) also immutable.",
        "priority": "medium",
        "dependencies": [
          "71"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify frozen=True in GlobalSettings model_config",
            "description": "Ensure GlobalSettings has frozen=True and extra='forbid' in SettingsConfigDict to enforce immutability and reject unknown fields.",
            "dependencies": [],
            "details": "In src/buvis/pybase/configuration/settings.py, verify or add:\n\n```python\nclass GlobalSettings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_prefix=\"BUVIS_\",\n        env_nested_delimiter=\"__\",\n        frozen=True,  # Makes settings immutable\n        extra=\"forbid\",  # Rejects unknown fields\n    )\n```\n\nIf task 62 already added frozen=True, confirm it's present. The frozen=True config makes Pydantic raise ValidationError on any setattr attempt after model creation.",
            "status": "pending",
            "testStrategy": "Instantiate GlobalSettings and attempt setattr - should raise pydantic.ValidationError",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add immutability docstring to resolve() method",
            "description": "Document in ConfigResolver.resolve() docstring that returned settings are immutable and should not be modified.",
            "dependencies": [
              1
            ],
            "details": "In src/buvis/pybase/configuration/resolver.py, add comprehensive docstring:\n\n```python\ndef resolve(\n    self,\n    config_dir: str | None = None,\n    cli_overrides: dict[str, Any] | None = None,\n) -> GlobalSettings:\n    \"\"\"Load configuration with precedence: CLI > ENV > YAML > Defaults.\n    \n    Returns:\n        GlobalSettings: Immutable settings object. Do not attempt to\n        modify after resolution - changes will raise ValidationError.\n        \n    Warning:\n        Call resolve() once per process. Multiple calls are inefficient\n        and may produce inconsistent results if environment changes.\n    \"\"\"\n```",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Test top-level field immutability",
            "description": "Write tests verifying that direct attribute assignment on GlobalSettings raises ValidationError.",
            "dependencies": [
              1
            ],
            "details": "Create tests/configuration/test_settings_immutable.py:\n\n```python\nimport pytest\nfrom pydantic import ValidationError\nfrom buvis.pybase.configuration.settings import GlobalSettings\n\nclass TestGlobalSettingsImmutability:\n    def test_debug_field_immutable(self) -> None:\n        settings = GlobalSettings()\n        with pytest.raises(ValidationError):\n            settings.debug = True\n\n    def test_log_level_field_immutable(self) -> None:\n        settings = GlobalSettings()\n        with pytest.raises(ValidationError):\n            settings.log_level = \"DEBUG\"\n```\n\nPydantic v2 frozen models raise ValidationError (not AttributeError) on mutation.",
            "status": "pending",
            "testStrategy": "Run pytest tests/configuration/test_settings_immutable.py - all tests pass",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Test nested settings immutability",
            "description": "Write tests verifying nested tool settings (e.g. settings.payroll) are also immutable.",
            "dependencies": [
              3
            ],
            "details": "Add to tests/configuration/test_settings_immutable.py:\n\n```python\nfrom buvis.pybase.configuration.settings import ToolSettings\n\nclass TestNestedSettingsImmutability:\n    def test_tool_settings_field_immutable(self) -> None:\n        tool = ToolSettings()\n        with pytest.raises(ValidationError):\n            tool.enabled = False\n\n    def test_nested_in_global_immutable(self) -> None:\n        # Assuming GlobalSettings has tool namespaces\n        settings = GlobalSettings()\n        # If settings.payroll exists as nested model\n        if hasattr(settings, 'payroll'):\n            with pytest.raises(ValidationError):\n                settings.payroll.enabled = False\n```\n\nAlso verify ToolSettings base model has `model_config = ConfigDict(frozen=True)`.",
            "status": "pending",
            "testStrategy": "Run full test suite - nested immutability tests pass",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test resolve() returns immutable settings",
            "description": "Integration test confirming ConfigResolver.resolve() returns frozen settings that reject mutations.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add to tests/configuration/test_resolver.py:\n\n```python\nimport pytest\nfrom pydantic import ValidationError\nfrom buvis.pybase.configuration import ConfigResolver\n\nclass TestResolverImmutability:\n    def test_resolved_settings_immutable(self, tmp_path) -> None:\n        resolver = ConfigResolver()\n        settings = resolver.resolve()\n        \n        with pytest.raises(ValidationError):\n            settings.debug = True\n        \n        with pytest.raises(ValidationError):\n            settings.log_level = \"ERROR\"\n```\n\nThis verifies the end-to-end contract: settings from resolve() cannot be modified.",
            "status": "pending",
            "testStrategy": "Integration test with ConfigResolver - mutations after resolve() raise ValidationError",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "78",
        "title": "Create comprehensive ConfigResolver tests",
        "description": "Write tests covering all 7 PRD test cases plus error handling and security constraints.",
        "details": "Create `tests/configuration/test_config_resolver_integration.py`:\n\n```python\nimport os\nfrom pathlib import Path\nfrom unittest.mock import patch\nimport pytest\nfrom buvis.pybase.configuration import ConfigResolver, ConfigurationError\n\n@pytest.fixture\ndef config_dir(tmp_path: Path) -> Path:\n    (tmp_path / \"buvis.yaml\").write_text(\"debug: false\\nlog_level: INFO\")\n    return tmp_path\n\nclass TestPRDScenarios:\n    def test_no_config_files_uses_defaults(self, tmp_path: Path):\n        \"\"\"PRD test 1: No config files -> defaults only.\"\"\"\n        with patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": str(tmp_path)}, clear=True):\n            resolver = ConfigResolver()\n            settings = resolver.resolve()\n            assert settings.debug is False\n            assert settings.log_level == \"INFO\"\n\n    def test_yaml_exists_loads_values(self, config_dir: Path):\n        \"\"\"PRD test 2: YAML exists -> values loaded.\"\"\"\n        (config_dir / \"buvis.yaml\").write_text(\"debug: true\\nlog_level: WARNING\")\n        with patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": str(config_dir)}, clear=True):\n            resolver = ConfigResolver()\n            settings = resolver.resolve()\n            assert settings.debug is True\n            assert settings.log_level == \"WARNING\"\n\n    def test_env_overrides_yaml(self, config_dir: Path):\n        \"\"\"PRD test 3: YAML + ENV -> ENV overrides YAML.\"\"\"\n        with patch.dict(os.environ, {\n            \"BUVIS_CONFIG_DIR\": str(config_dir),\n            \"BUVIS_DEBUG\": \"true\"\n        }):\n            resolver = ConfigResolver()\n            settings = resolver.resolve()\n            assert settings.debug is True  # ENV wins\n\n    def test_cli_overrides_all(self, config_dir: Path):\n        \"\"\"PRD test 4: YAML + ENV + CLI -> CLI overrides all.\"\"\"\n        with patch.dict(os.environ, {\n            \"BUVIS_CONFIG_DIR\": str(config_dir),\n            \"BUVIS_DEBUG\": \"true\"\n        }):\n            resolver = ConfigResolver()\n            settings = resolver.resolve(cli_overrides={\"debug\": False})\n            assert settings.debug is False  # CLI wins\n\n    def test_tool_specific_yaml_merged(self, config_dir: Path):\n        \"\"\"PRD test 5: Tool-specific YAML merged on top of base.\"\"\"\n        (config_dir / \"buvis-payroll.yaml\").write_text(\"log_level: DEBUG\")\n        with patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": str(config_dir)}, clear=True):\n            resolver = ConfigResolver(tool_name=\"payroll\")\n            settings = resolver.resolve()\n            assert settings.debug is False  # From base\n            assert settings.log_level == \"DEBUG\"  # From tool-specific\n\n    def test_invalid_yaml_raises_with_path(self, config_dir: Path):\n        \"\"\"PRD test 6: Invalid YAML -> clear error with file path.\"\"\"\n        (config_dir / \"buvis.yaml\").write_text(\"debug: [broken\")\n        with patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": str(config_dir)}, clear=True):\n            resolver = ConfigResolver()\n            with pytest.raises(ConfigurationError) as exc:\n                resolver.resolve()\n            assert \"buvis.yaml\" in str(exc.value)\n\n    def test_missing_required_field_raises(self, config_dir: Path):\n        \"\"\"PRD test 7: Missing required field -> ValidationError.\"\"\"\n        # Assuming GlobalSettings has a required field without default\n        pass  # Implement when required fields defined\n```",
        "testStrategy": "Run pytest on test file. All 7 PRD test cases must pass. Verify error messages include paths and field names.",
        "priority": "high",
        "dependencies": [
          "71",
          "72",
          "73",
          "74",
          "75"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test file structure with imports and fixtures",
            "description": "Create tests/configuration/test_config_resolver_integration.py with imports and reusable pytest fixtures.",
            "dependencies": [],
            "details": "Create the test file with:\n\n```python\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom buvis.pybase.configuration import ConfigResolver, ConfigurationError\n\n\n@pytest.fixture\ndef config_dir(tmp_path: Path) -> Path:\n    \"\"\"Create temp dir with base buvis.yaml config.\"\"\"\n    (tmp_path / \"buvis.yaml\").write_text(\"debug: false\\nlog_level: INFO\")\n    return tmp_path\n\n\n@pytest.fixture\ndef isolated_env():\n    \"\"\"Clear BUVIS_ env vars for isolated tests.\"\"\"\n    buvis_vars = [k for k in os.environ if k.startswith(\"BUVIS_\")]\n    original = {k: os.environ.pop(k) for k in buvis_vars}\n    yield\n    os.environ.update(original)\n```\n\nCreate directory `tests/configuration/` and empty `__init__.py` if needed.",
            "status": "pending",
            "testStrategy": "Verify file created and pytest discovers it via `uv run pytest tests/configuration/ --collect-only`.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement basic precedence tests (PRD 1-3)",
            "description": "Add TestPRDScenarios class with tests for defaults-only, YAML loading, and ENV overrides.",
            "dependencies": [
              1
            ],
            "details": "Add to test file:\n\n```python\nclass TestPRDScenarios:\n    def test_no_config_files_uses_defaults(self, tmp_path: Path, isolated_env):\n        \"\"\"PRD test 1: No config files -> defaults only.\"\"\"\n        with patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": str(tmp_path)}):\n            resolver = ConfigResolver()\n            settings = resolver.resolve()\n            assert settings.debug is False\n            assert settings.log_level == \"INFO\"\n\n    def test_yaml_exists_loads_values(self, config_dir: Path, isolated_env):\n        \"\"\"PRD test 2: YAML exists -> values loaded.\"\"\"\n        (config_dir / \"buvis.yaml\").write_text(\"debug: true\\nlog_level: WARNING\")\n        with patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": str(config_dir)}):\n            resolver = ConfigResolver()\n            settings = resolver.resolve()\n            assert settings.debug is True\n            assert settings.log_level == \"WARNING\"\n\n    def test_env_overrides_yaml(self, config_dir: Path, isolated_env):\n        \"\"\"PRD test 3: YAML + ENV -> ENV wins.\"\"\"\n        with patch.dict(os.environ, {\n            \"BUVIS_CONFIG_DIR\": str(config_dir),\n            \"BUVIS_DEBUG\": \"true\"\n        }):\n            resolver = ConfigResolver()\n            settings = resolver.resolve()\n            assert settings.debug is True  # ENV overrides YAML false\n```",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_config_resolver_integration.py::TestPRDScenarios -v -k 'test_no_config or test_yaml_exists or test_env_overrides'`.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement CLI override and tool-specific tests (PRD 4-5)",
            "description": "Add tests for CLI overrides taking highest precedence and tool-specific YAML merging.",
            "dependencies": [
              1
            ],
            "details": "Add to TestPRDScenarios class:\n\n```python\n    def test_cli_overrides_all(self, config_dir: Path, isolated_env):\n        \"\"\"PRD test 4: CLI overrides ENV and YAML.\"\"\"\n        with patch.dict(os.environ, {\n            \"BUVIS_CONFIG_DIR\": str(config_dir),\n            \"BUVIS_DEBUG\": \"true\"\n        }):\n            resolver = ConfigResolver()\n            settings = resolver.resolve(cli_overrides={\"debug\": False})\n            assert settings.debug is False  # CLI wins over ENV true\n\n    def test_tool_specific_yaml_merged(self, config_dir: Path, isolated_env):\n        \"\"\"PRD test 5: Tool-specific YAML merges on base.\"\"\"\n        (config_dir / \"buvis-payroll.yaml\").write_text(\"log_level: DEBUG\")\n        with patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": str(config_dir)}):\n            resolver = ConfigResolver(tool_name=\"payroll\")\n            settings = resolver.resolve()\n            assert settings.debug is False  # From base buvis.yaml\n            assert settings.log_level == \"DEBUG\"  # From buvis-payroll.yaml\n```\n\nThese tests validate the full precedence chain: Defaults < YAML < Tool-YAML < ENV < CLI.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_config_resolver_integration.py::TestPRDScenarios -v -k 'test_cli_overrides or test_tool_specific'`.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement error handling tests (PRD 6-7)",
            "description": "Add tests for invalid YAML errors, missing required fields, and permission denied scenarios.",
            "dependencies": [
              1
            ],
            "details": "Add to TestPRDScenarios class:\n\n```python\n    def test_invalid_yaml_raises_with_path(self, config_dir: Path, isolated_env):\n        \"\"\"PRD test 6: Invalid YAML -> error includes file path.\"\"\"\n        (config_dir / \"buvis.yaml\").write_text(\"debug: [broken\")\n        with patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": str(config_dir)}):\n            resolver = ConfigResolver()\n            with pytest.raises(ConfigurationError) as exc:\n                resolver.resolve()\n            assert \"buvis.yaml\" in str(exc.value)\n\n    def test_missing_required_field_raises(self, config_dir: Path, isolated_env):\n        \"\"\"PRD test 7: Missing required -> ValidationError.\"\"\"\n        # TODO: Implement when required fields defined in GlobalSettings\n        pass\n```\n\nAdd new TestErrorHandling class:\n\n```python\nclass TestErrorHandling:\n    def test_permission_denied_skips_file(self, config_dir: Path, isolated_env):\n        \"\"\"Permission denied on file -> skip and continue.\"\"\"\n        unreadable = config_dir / \"buvis-private.yaml\"\n        unreadable.write_text(\"secret: value\")\n        unreadable.chmod(0o000)\n        try:\n            with patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": str(config_dir)}):\n                resolver = ConfigResolver()\n                settings = resolver.resolve()  # Should not raise\n                assert settings is not None\n        finally:\n            unreadable.chmod(0o644)\n\n    def test_type_validation_error_includes_field(self, config_dir: Path, isolated_env):\n        \"\"\"Type mismatch -> error includes field name.\"\"\"\n        (config_dir / \"buvis.yaml\").write_text(\"debug: not_a_bool\")\n        with patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": str(config_dir)}):\n            resolver = ConfigResolver()\n            with pytest.raises(ConfigurationError) as exc:\n                resolver.resolve()\n            assert \"debug\" in str(exc.value).lower()\n```",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_config_resolver_integration.py::TestErrorHandling -v` and verify clear error messages.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement security constraint tests",
            "description": "Add tests for secret masking in errors, settings immutability, and fail-fast validation.",
            "dependencies": [
              1
            ],
            "details": "Add TestSecurityConstraints class:\n\n```python\nclass TestSecurityConstraints:\n    def test_secrets_masked_in_error_messages(self, config_dir: Path, isolated_env):\n        \"\"\"Secret values not exposed in error messages.\"\"\"\n        (config_dir / \"buvis.yaml\").write_text(\n            \"database_password: supersecret123\\ninvalid_field: [broken\"\n        )\n        with patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": str(config_dir)}):\n            resolver = ConfigResolver()\n            with pytest.raises(ConfigurationError) as exc:\n                resolver.resolve()\n            assert \"supersecret123\" not in str(exc.value)\n\n    def test_settings_immutable_after_resolve(self, config_dir: Path, isolated_env):\n        \"\"\"Settings frozen after resolution.\"\"\"\n        with patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": str(config_dir)}):\n            resolver = ConfigResolver()\n            settings = resolver.resolve()\n            with pytest.raises((TypeError, AttributeError, Exception)):\n                settings.debug = True  # Should fail - frozen\n\n    def test_fail_fast_validates_immediately(self, config_dir: Path, isolated_env):\n        \"\"\"Validation happens at resolve() not at access time.\"\"\"\n        (config_dir / \"buvis.yaml\").write_text(\"log_level: INVALID_LEVEL\")\n        with patch.dict(os.environ, {\"BUVIS_CONFIG_DIR\": str(config_dir)}):\n            resolver = ConfigResolver()\n            # Error raised at resolve(), not when accessing log_level\n            with pytest.raises(ConfigurationError):\n                resolver.resolve()\n```",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_config_resolver_integration.py::TestSecurityConstraints -v`. Verify no secrets in outputs.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:04:17.730Z"
      },
      {
        "id": "79",
        "title": "Update module exports for ConfigResolver",
        "description": "Export ConfigResolver, ConfigurationError, and related classes from configuration module.",
        "details": "Update `src/buvis/pybase/configuration/__init__.py`:\n\n```python\nfrom .configuration import Configuration, cfg\nfrom .exceptions import (\n    ConfigurationError,\n    ConfigurationKeyNotFoundError,\n    MissingEnvVarError,\n)\nfrom .loader import ConfigurationLoader\nfrom .resolver import ConfigResolver\nfrom .settings import GlobalSettings, ToolSettings\n\n# Convenience function\ndef get_resolver(tool_name: str | None = None) -> ConfigResolver:\n    \"\"\"Create a ConfigResolver for the given tool.\"\"\"\n    return ConfigResolver(tool_name=tool_name)\n\n__all__ = [\n    # Legacy\n    \"Configuration\",\n    \"cfg\",\n    # Exceptions\n    \"ConfigurationError\",\n    \"ConfigurationKeyNotFoundError\",\n    \"MissingEnvVarError\",\n    # Core classes\n    \"ConfigResolver\",\n    \"ConfigurationLoader\",\n    \"GlobalSettings\",\n    \"ToolSettings\",\n    # Convenience\n    \"get_resolver\",\n]\n```\n\nThis provides clean API:\n```python\nfrom buvis.pybase.configuration import ConfigResolver\n\nresolver = ConfigResolver()\nsettings = resolver.resolve()\n```",
        "testStrategy": "Verify all imports work: `from buvis.pybase.configuration import ConfigResolver, ConfigurationError, GlobalSettings`. Test get_resolver() returns ConfigResolver instance.",
        "priority": "medium",
        "dependencies": [
          "74",
          "78"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add ConfigurationError and MissingEnvVarError to exceptions.py",
            "description": "Create base ConfigurationError exception and MissingEnvVarError subclass in the exceptions module to support the new configuration system.",
            "dependencies": [],
            "details": "Update `src/buvis/pybase/configuration/exceptions.py` to add:\n\n```python\nclass ConfigurationError(Exception):\n    \"\"\"Base exception for configuration errors.\"\"\"\n    pass\n\nclass ConfigurationKeyNotFoundError(ConfigurationError):\n    \"\"\"Key not found in configuration exception.\"\"\"\n    # existing implementation\n\nclass MissingEnvVarError(ConfigurationError):\n    \"\"\"Required environment variable is not set.\"\"\"\n    def __init__(self, var_name: str) -> None:\n        super().__init__(f\"Required environment variable '{var_name}' is not set\")\n        self.var_name = var_name\n```\n\nMake ConfigurationKeyNotFoundError inherit from ConfigurationError for hierarchy.",
            "status": "pending",
            "testStrategy": "Test that ConfigurationError is base, ConfigurationKeyNotFoundError and MissingEnvVarError inherit from it. Verify MissingEnvVarError stores var_name attribute.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Refactor __init__.py to import exceptions from exceptions module",
            "description": "Update configuration/__init__.py to import exception classes directly from .exceptions instead of through .configuration.",
            "dependencies": [
              1
            ],
            "details": "Change the imports in `src/buvis/pybase/configuration/__init__.py`:\n\nFrom:\n```python\nfrom .configuration import Configuration, ConfigurationKeyNotFoundError, cfg\n```\n\nTo:\n```python\nfrom .configuration import Configuration, cfg\nfrom .exceptions import (\n    ConfigurationError,\n    ConfigurationKeyNotFoundError,\n    MissingEnvVarError,\n)\n```\n\nThis follows the pattern of explicit imports from source modules seen in adapters/__init__.py.",
            "status": "pending",
            "testStrategy": "Verify `from buvis.pybase.configuration import ConfigurationError, MissingEnvVarError` works. Ensure ConfigurationKeyNotFoundError still importable from both locations for backwards compatibility.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add imports for loader, resolver, and settings modules",
            "description": "Import ConfigurationLoader, ConfigResolver, GlobalSettings, and ToolSettings from their respective modules (created by dependent tasks 74 and 78).",
            "dependencies": [
              2
            ],
            "details": "Add imports to `src/buvis/pybase/configuration/__init__.py`:\n\n```python\nfrom .configuration import Configuration, cfg\nfrom .exceptions import (\n    ConfigurationError,\n    ConfigurationKeyNotFoundError,\n    MissingEnvVarError,\n)\nfrom .loader import ConfigurationLoader\nfrom .resolver import ConfigResolver\nfrom .settings import GlobalSettings, ToolSettings\n```\n\nThese modules are created by Tasks 74 (loader) and 78 (resolver). Settings module structure should define GlobalSettings and ToolSettings Pydantic models.",
            "status": "pending",
            "testStrategy": "Verify all imports work without ImportError. Test `from buvis.pybase.configuration import ConfigResolver, GlobalSettings, ToolSettings, ConfigurationLoader`.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement get_resolver convenience function",
            "description": "Add get_resolver() helper function to __init__.py for easy ConfigResolver instantiation.",
            "dependencies": [
              3
            ],
            "details": "Add convenience function after imports in `src/buvis/pybase/configuration/__init__.py`:\n\n```python\ndef get_resolver(tool_name: str | None = None) -> ConfigResolver:\n    \"\"\"Create a ConfigResolver for the given tool.\n    \n    Args:\n        tool_name: Optional tool name for tool-specific settings.\n        \n    Returns:\n        ConfigResolver instance configured for the tool.\n    \"\"\"\n    return ConfigResolver(tool_name=tool_name)\n```\n\nUse Google docstring format per project conventions. Keep it simple - just a factory function.",
            "status": "pending",
            "testStrategy": "Test get_resolver() returns ConfigResolver instance. Test get_resolver('mytool') passes tool_name correctly. Verify function is importable.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Update __all__ exports and add import verification tests",
            "description": "Finalize __all__ list with all exported symbols and create test file to verify all imports work correctly.",
            "dependencies": [
              4
            ],
            "details": "1. Update __all__ in `src/buvis/pybase/configuration/__init__.py`:\n\n```python\n__all__ = [\n    # Legacy\n    \"Configuration\",\n    \"cfg\",\n    # Exceptions\n    \"ConfigurationError\",\n    \"ConfigurationKeyNotFoundError\",\n    \"MissingEnvVarError\",\n    # Core classes\n    \"ConfigResolver\",\n    \"ConfigurationLoader\",\n    \"GlobalSettings\",\n    \"ToolSettings\",\n    # Convenience\n    \"get_resolver\",\n]\n```\n\n2. Create `tests/configuration/test_configuration_exports.py`:\n\n```python\nimport pytest\nfrom buvis.pybase.configuration import (\n    ConfigResolver,\n    ConfigurationError,\n    GlobalSettings,\n    get_resolver,\n)\n\ndef test_config_resolver_importable():\n    assert ConfigResolver is not None\n\ndef test_get_resolver_returns_instance():\n    resolver = get_resolver()\n    assert isinstance(resolver, ConfigResolver)\n```",
            "status": "pending",
            "testStrategy": "Run `python -c \"from buvis.pybase.configuration import *\"` to verify all exports. Run pytest on new test file. Check __all__ matches actual exports.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "80",
        "title": "Add usage documentation and examples",
        "description": "Add docstrings and create example usage patterns for ConfigResolver.",
        "details": "Add comprehensive docstring to ConfigResolver:\n\n```python\nclass ConfigResolver:\n    \"\"\"Unified configuration loader with precedence handling.\n    \n    Orchestrates config loading from multiple sources:\n    - YAML files (via ConfigurationLoader discovery)\n    - Environment variables (via Pydantic)\n    - CLI overrides (passed to resolve())\n    \n    Precedence (highest to lowest):\n        1. CLI overrides\n        2. Environment variables (BUVIS_* prefix)\n        3. YAML config files\n        4. Model defaults\n    \n    Examples:\n        # Basic usage\n        resolver = ConfigResolver()\n        settings = resolver.resolve()\n        \n        # Tool-specific config\n        resolver = ConfigResolver(tool_name=\"payroll\")\n        settings = resolver.resolve()\n        \n        # With CLI overrides from Click\n        @click.command()\n        @click.option('--debug', is_flag=True)\n        def main(debug):\n            resolver = ConfigResolver()\n            settings = resolver.resolve(cli_overrides={\"debug\": debug})\n        \n        # Custom config directory\n        settings = resolver.resolve(config_dir=\"/etc/buvis\")\n    \n    Raises:\n        ConfigurationError: YAML syntax error, type validation failure\n        \n    Note:\n        Settings are immutable after resolve(). Don't call resolve()\n        multiple times per process.\n    \"\"\"\n```\n\nAdd error handling example to module docstring.",
        "testStrategy": "Run `python -c 'from buvis.pybase.configuration import ConfigResolver; help(ConfigResolver)'` and verify docstring displays. Review docstring for accuracy.",
        "priority": "low",
        "dependencies": [
          "79"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add comprehensive class docstring to ConfigResolver",
            "description": "Add the main class-level docstring with overview, source list, precedence order, and usage examples as specified in the task details.",
            "dependencies": [],
            "details": "Add the docstring block to ConfigResolver class including: 1) Summary of what the class does (unified config loader with precedence). 2) List of config sources (YAML files, ENV vars, CLI overrides). 3) Precedence order (CLI > ENV > YAML > defaults). 4) Basic usage example showing resolver instantiation and resolve() call. 5) Tool-specific config example with tool_name param. 6) Click CLI override example. 7) Custom config_dir example. Follow Google docstring format matching existing patterns in configuration.py.",
            "status": "pending",
            "testStrategy": "Run `python -c 'from buvis.pybase.configuration import ConfigResolver; help(ConfigResolver)'` and verify docstring displays correctly with all sections.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add docstring to __init__ method",
            "description": "Document the ConfigResolver constructor with parameters and their purpose.",
            "dependencies": [
              1
            ],
            "details": "Add docstring to __init__(self, tool_name: str | None = None) explaining: 1) Purpose of the constructor. 2) Args section with tool_name param (optional str for tool-specific config prefix like 'payroll'). 3) Note about how tool_name affects config file discovery and ENV var prefix. Use Google format with Args section matching project conventions.",
            "status": "pending",
            "testStrategy": "Run `python -c 'from buvis.pybase.configuration import ConfigResolver; help(ConfigResolver.__init__)'` and verify parameter docs appear.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add docstring to resolve() method",
            "description": "Document the resolve method with parameters, return type, exceptions, and notes.",
            "dependencies": [
              1
            ],
            "details": "Add docstring to resolve(config_dir, cli_overrides) method including: 1) Summary of loading/merging behavior. 2) Args section: config_dir (optional custom config directory), cli_overrides (dict from CLI args). 3) Returns section: GlobalSettings instance with validated config. 4) Raises section: ConfigurationError for YAML syntax errors, type validation failures. 5) Note about immutability - don't call resolve() multiple times per process.",
            "status": "pending",
            "testStrategy": "Run `python -c 'from buvis.pybase.configuration import ConfigResolver; help(ConfigResolver.resolve)'` and verify all sections appear.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add error handling example to module docstring",
            "description": "Add module-level docstring with error handling patterns and import guidance.",
            "dependencies": [
              3
            ],
            "details": "Add or update module docstring in the file containing ConfigResolver showing: 1) Module purpose summary. 2) Error handling example with try/except ConfigurationError pattern as shown in PRD. 3) Import examples. 4) Quick reference to precedence rules. Place at top of file before imports. Example: try: settings = resolver.resolve() except ConfigurationError as e: print(f'Config error: {e}'); sys.exit(1)",
            "status": "pending",
            "testStrategy": "Import module and verify module.__doc__ contains error handling example. Check example code is syntactically valid.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify documentation displays correctly via help()",
            "description": "Test that all docstrings display properly when using Python's help() system and review for accuracy.",
            "dependencies": [
              4
            ],
            "details": "Create verification script that: 1) Imports ConfigResolver. 2) Calls help(ConfigResolver) and captures output. 3) Verifies class docstring includes Examples section. 4) Verifies __init__ docstring includes Args section. 5) Verifies resolve() docstring includes Args, Returns, Raises sections. 6) Review docstrings for accuracy against actual implementation. 7) Ensure all examples use correct API (resolve() params, return types).",
            "status": "pending",
            "testStrategy": "Run the test command from task: `python -c 'from buvis.pybase.configuration import ConfigResolver; help(ConfigResolver)'` and manually verify output. Create test if docstring verification is needed in CI.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "81",
        "title": "Add Click dependency",
        "description": "Add Click package to pyproject.toml dependencies for CLI integration support.",
        "details": "Update pyproject.toml to include click>=8.1.0,<9 in dependencies array. Run `uv sync` to install. Click 8.1+ required for modern type hints and decorators.\n\n```toml\ndependencies = [\n  ...\n  \"click>=8.1.0,<9\",\n]\n```",
        "testStrategy": "Run `uv sync --all-groups` and verify Click imports work with `uv run python -c \"import click; print(click.__version__)\"`",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify insertion point in pyproject.toml dependencies",
            "description": "Review pyproject.toml to find the correct location for adding click dependency in the dependencies array.",
            "dependencies": [],
            "details": "Open pyproject.toml and locate the dependencies array (lines 13-25). The dependency should be added alphabetically among existing dependencies. Click should be inserted after 'inflection' and before 'jira' to maintain alphabetical order.",
            "status": "done",
            "testStrategy": "Verify pyproject.toml is readable and dependencies array structure is understood.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:06:29.762Z"
          },
          {
            "id": 2,
            "title": "Add click>=8.1.0,<9 to pyproject.toml",
            "description": "Edit pyproject.toml to include the click package dependency with version constraints.",
            "dependencies": [
              1
            ],
            "details": "Add the line `\"click>=8.1.0,<9\",` to the dependencies array in pyproject.toml. Insert after inflection line (line 14) to maintain alphabetical order. Use same format as other deps with major version upper bound.",
            "status": "done",
            "testStrategy": "Run `ruff check pyproject.toml` to verify TOML syntax is valid.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:06:29.806Z"
          },
          {
            "id": 3,
            "title": "Run uv sync to install click dependency",
            "description": "Execute uv sync --all-groups to install click and update uv.lock.",
            "dependencies": [
              2
            ],
            "details": "Run `uv sync --all-groups` to install all dependencies including the newly added click package. This will resolve the dependency, download it, and update uv.lock with the resolved version.",
            "status": "done",
            "testStrategy": "Command exits with status 0 and no error messages. uv.lock file is updated with click entry.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:06:29.851Z"
          },
          {
            "id": 4,
            "title": "Verify click import works",
            "description": "Test that click can be imported successfully in Python.",
            "dependencies": [
              3
            ],
            "details": "Run `uv run python -c \"import click; print(click.__version__)\"` to verify the package is correctly installed and importable. This confirms the dependency was resolved and installed properly.",
            "status": "done",
            "testStrategy": "Command prints click version (8.1.x) without import errors.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:06:29.897Z"
          },
          {
            "id": 5,
            "title": "Verify click version meets 8.1+ requirement",
            "description": "Confirm installed click version is 8.1.0 or higher for modern type hints and decorators support.",
            "dependencies": [
              4
            ],
            "details": "Parse the version output from previous step to ensure it starts with '8.1' or higher. Click 8.1+ is required per task spec for modern type hints and decorator support used in CLI integration.",
            "status": "done",
            "testStrategy": "Version number is >= 8.1.0. Test basic decorator: `uv run python -c \"import click; @click.command()\\ndef cli(): pass\"`",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T18:06:30.069Z"
          }
        ],
        "updatedAt": "2026-01-02T18:06:30.069Z"
      },
      {
        "id": "82",
        "title": "Create GlobalSettings dataclass",
        "description": "Define dataclass to hold resolved BUVIS settings (debug, log_level) with type-safe access.",
        "details": "Create `src/buvis/pybase/configuration/settings.py`:\n\n```python\nfrom __future__ import annotations\nfrom dataclasses import dataclass, field\nfrom typing import Any\n\n@dataclass\nclass GlobalSettings:\n    \"\"\"Resolved BUVIS settings.\"\"\"\n    debug: bool = False\n    log_level: str = \"INFO\"\n    config_dir: str | None = None\n    _extra: dict[str, Any] = field(default_factory=dict)\n\n    def __getattr__(self, name: str) -> Any:\n        \"\"\"Allow access to tool-specific settings via attribute.\"\"\"\n        if name.startswith('_'):\n            raise AttributeError(name)\n        return self._extra.get(name)\n```\n\nKeep it minimal - only fields needed for standard options. Tool-specific settings accessed via `_extra` dict for extensibility.",
        "testStrategy": "Unit test: instantiate GlobalSettings with various values, verify defaults, test attribute access for both standard fields and _extra keys.",
        "priority": "high",
        "dependencies": [
          "81"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create settings.py with GlobalSettings dataclass scaffold",
            "description": "Create the new settings.py file in src/buvis/pybase/configuration/ with the basic GlobalSettings dataclass structure including imports and core fields.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/settings.py` with:\n- `from __future__ import annotations`\n- `from dataclasses import dataclass, field`\n- `from typing import Any`\n- `@dataclass` decorated GlobalSettings class\n- Core fields: `debug: bool = False`, `log_level: str = \"INFO\"`, `config_dir: str | None = None`\n- Google-format docstring: \"Resolved BUVIS settings.\"",
            "status": "pending",
            "testStrategy": "Verify file creates successfully and GlobalSettings can be imported: `from buvis.pybase.configuration.settings import GlobalSettings`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add _extra field with default_factory for extensibility",
            "description": "Add the _extra dict field using dataclass field() with default_factory to store tool-specific settings that aren't part of the core schema.",
            "dependencies": [
              1
            ],
            "details": "Add to GlobalSettings dataclass:\n- `_extra: dict[str, Any] = field(default_factory=dict)`\n- This allows storing arbitrary tool-specific settings without modifying the dataclass schema\n- Uses field(default_factory=dict) pattern to avoid mutable default argument issue\n- Field is private (underscore prefix) to indicate it's for internal/dynamic access",
            "status": "pending",
            "testStrategy": "Unit test: instantiate GlobalSettings(), verify _extra is empty dict; instantiate with _extra={'foo': 'bar'}, verify contents",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement custom __getattr__ for dynamic _extra access",
            "description": "Implement __getattr__ method to allow attribute-style access to keys stored in _extra dict, enabling settings.tool_name syntax for extensibility.",
            "dependencies": [
              2
            ],
            "details": "Add to GlobalSettings class:\n```python\ndef __getattr__(self, name: str) -> Any:\n    \"\"\"Allow access to tool-specific settings via attribute.\"\"\"\n    if name.startswith('_'):\n        raise AttributeError(name)\n    return self._extra.get(name)\n```\nThe underscore check prevents infinite recursion when accessing private attrs. Returns None for missing keys (via dict.get default).",
            "status": "pending",
            "testStrategy": "Test: settings with _extra={'jira': {...}} allows settings.jira access; Test: settings.nonexistent returns None; Test: settings._private raises AttributeError",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create test suite for GlobalSettings in tests/configuration/",
            "description": "Create tests/configuration/test_settings.py with comprehensive tests for defaults, field access, _extra dict, and __getattr__ behavior.",
            "dependencies": [
              3
            ],
            "details": "Create `tests/configuration/test_settings.py` following existing test patterns:\n- Class TestGlobalSettingsDefaults: test debug=False, log_level=\"INFO\", config_dir=None, _extra=empty dict\n- Class TestGlobalSettingsFields: test setting explicit values for all fields\n- Class TestGlobalSettingsExtraAccess: test __getattr__ returns _extra values, returns None for missing, raises AttributeError for underscore-prefixed\n- Use pytest fixtures following shell_adapter test pattern",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py -v` and verify all tests pass",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Export GlobalSettings in configuration/__init__.py",
            "description": "Add GlobalSettings to the configuration module's public API by updating __init__.py with the import and __all__ list.",
            "dependencies": [
              1
            ],
            "details": "Update `src/buvis/pybase/configuration/__init__.py`:\n- Add import: `from .settings import GlobalSettings`\n- Add \"GlobalSettings\" to __all__ list\n- Follow existing pattern: `from .configuration import Configuration, ConfigurationKeyNotFoundError, cfg`\n- Result: `from buvis.pybase.configuration import GlobalSettings` works",
            "status": "pending",
            "testStrategy": "Verify import works: `from buvis.pybase.configuration import GlobalSettings` and GlobalSettings appears in module's __all__",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:53:47.928Z"
      },
      {
        "id": "83",
        "title": "Create ConfigResolver class",
        "description": "Implement resolver with precedence: CLI overrides > ENV vars > config file defaults.",
        "details": "Create `src/buvis/pybase/configuration/resolver.py`:\n\n```python\nfrom __future__ import annotations\nimport os\nfrom pathlib import Path\nfrom .settings import GlobalSettings\nfrom .configuration import Configuration\n\nclass ConfigResolver:\n    \"\"\"Resolve settings from CLI, ENV, and config file.\"\"\"\n\n    ENV_PREFIX = \"BUVIS_\"\n\n    def resolve(\n        self,\n        config_dir: str | None = None,\n        config_file: str | None = None,\n        cli_overrides: dict[str, Any] | None = None,\n    ) -> GlobalSettings:\n        # Load base config from file\n        file_path = self._resolve_config_path(config_dir, config_file)\n        file_settings = self._load_file_settings(file_path)\n        \n        # Apply ENV overrides\n        env_settings = self._load_env_settings()\n        \n        # Apply CLI overrides (highest priority)\n        cli_settings = cli_overrides or {}\n        \n        # Merge: file < env < cli\n        merged = {**file_settings, **env_settings, **cli_settings}\n        \n        return GlobalSettings(\n            debug=merged.get(\"debug\", False),\n            log_level=merged.get(\"log_level\", \"INFO\"),\n            config_dir=config_dir,\n        )\n\n    def _load_env_settings(self) -> dict[str, Any]:\n        result = {}\n        if (val := os.getenv(\"BUVIS_DEBUG\")) is not None:\n            result[\"debug\"] = val.lower() in (\"true\", \"1\", \"yes\")\n        if (val := os.getenv(\"BUVIS_LOG_LEVEL\")) is not None:\n            result[\"log_level\"] = val.upper()\n        return result\n```\n\nKey: Only include values that are explicitly set (not None) so precedence works correctly.",
        "testStrategy": "Test each source in isolation, then test precedence: CLI wins over ENV wins over file. Use monkeypatch for ENV vars.",
        "priority": "high",
        "dependencies": [
          "82"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create resolver.py with ConfigResolver class scaffold",
            "description": "Create the new resolver.py file with ConfigResolver class structure, imports, and method signatures.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/resolver.py` with:\n- `from __future__ import annotations`\n- `import os` and `from typing import Any`\n- Import `GlobalSettings` from `.settings` and `Configuration` from `.configuration`\n- Define `ConfigResolver` class with `ENV_PREFIX = \"BUVIS_\"` class attribute\n- Add method signatures for `resolve()`, `_resolve_config_path()`, `_load_file_settings()`, and `_load_env_settings()` with pass/NotImplementedError placeholders\n- Google-format docstring: \"Resolve settings from CLI, ENV, and config file.\"",
            "status": "pending",
            "testStrategy": "Verify file creates and imports: `from buvis.pybase.configuration.resolver import ConfigResolver`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement _resolve_config_path method",
            "description": "Implement logic to determine config file path from config_dir/config_file params or defaults.",
            "dependencies": [
              1
            ],
            "details": "Implement `_resolve_config_path(self, config_dir: str | None, config_file: str | None) -> Path | None`:\n- If config_file provided, return Path(config_file) if exists\n- If config_dir provided, look for config.yaml in that dir\n- Fall back to existing Configuration class default path logic (~/.config/buvis/config.yaml)\n- Return None if no config found (don't raise - let resolve() handle defaults)\n- Use Path.exists() checks, not exceptions for missing files",
            "status": "pending",
            "testStrategy": "Test: explicit path returns that path; config_dir finds config.yaml; missing file returns None",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement _load_file_settings and _load_env_settings methods",
            "description": "Implement methods to load settings from YAML file and BUVIS_ prefixed environment variables.",
            "dependencies": [
              2
            ],
            "details": "Implement `_load_file_settings(self, file_path: Path | None) -> dict[str, Any]`:\n- If file_path is None, return empty dict\n- Use existing Configuration class to load YAML\n- Extract only GlobalSettings-relevant keys (debug, log_level)\n\nImplement `_load_env_settings(self) -> dict[str, Any]`:\n- Check BUVIS_DEBUG: convert 'true'/'1'/'yes' to bool True\n- Check BUVIS_LOG_LEVEL: convert to uppercase string\n- Only include keys that are explicitly set (not None) for correct precedence",
            "status": "pending",
            "testStrategy": "Test _load_env_settings with monkeypatch for BUVIS_DEBUG=true returns {'debug': True}",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement resolve() method with precedence merging",
            "description": "Implement main resolve() method that merges file < env < cli settings and returns GlobalSettings.",
            "dependencies": [
              3
            ],
            "details": "Implement `resolve(self, config_dir: str | None = None, config_file: str | None = None, cli_overrides: dict[str, Any] | None = None) -> GlobalSettings`:\n- Call _resolve_config_path to get file path\n- Call _load_file_settings for base settings\n- Call _load_env_settings for env overrides\n- Merge: `{**file_settings, **env_settings, **(cli_overrides or {})}`\n- Return GlobalSettings with merged values and sensible defaults (debug=False, log_level='INFO')\n- Pass config_dir through to GlobalSettings",
            "status": "pending",
            "testStrategy": "Test: CLI overrides ENV overrides file. Test: missing sources use defaults.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Export ConfigResolver and create test suite",
            "description": "Export class in __init__.py and create comprehensive tests for precedence behavior.",
            "dependencies": [
              4
            ],
            "details": "Update `src/buvis/pybase/configuration/__init__.py` to export ConfigResolver.\n\nCreate `tests/configuration/test_resolver.py`:\n- TestConfigResolver class with fixtures for temp config files\n- test_file_settings_loaded: config.yaml values appear in result\n- test_env_overrides_file: BUVIS_DEBUG=true beats file debug=false\n- test_cli_overrides_env: cli_overrides={'debug': False} beats BUVIS_DEBUG=true\n- test_defaults_when_no_sources: returns GlobalSettings(debug=False, log_level='INFO')\n- Use monkeypatch for env vars, tmp_path for config files",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_resolver.py -v` - all tests pass",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:54:02.150Z"
      },
      {
        "id": "84",
        "title": "Implement buvis_options decorator",
        "description": "Create decorator that adds --debug, --log-level, --config-dir, --config options and injects resolved settings into Click context.",
        "details": "Add to `src/buvis/pybase/configuration/click_integration.py`:\n\n```python\nfrom __future__ import annotations\nimport functools\nimport click\nfrom .resolver import ConfigResolver\nfrom .settings import GlobalSettings\n\ndef buvis_options(f):\n    \"\"\"Add standard BUVIS options to a Click command.\"\"\"\n    @click.option(\"--debug/--no-debug\", default=None, help=\"Enable debug mode\")\n    @click.option(\n        \"--log-level\",\n        type=click.Choice([\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"], case_sensitive=False),\n        default=None,\n    )\n    @click.option(\n        \"--config-dir\",\n        type=click.Path(exists=True, file_okay=False, resolve_path=True),\n        help=\"Config directory\",\n    )\n    @click.option(\n        \"--config\",\n        type=click.Path(exists=True, dir_okay=False, resolve_path=True),\n        help=\"Additional YAML config file\",\n    )\n    @click.pass_context\n    @functools.wraps(f)\n    def wrapper(ctx, debug, log_level, config_dir, config, *args, **kwargs):\n        cli_overrides = {\n            k: v for k, v in {\"debug\": debug, \"log_level\": log_level}.items()\n            if v is not None\n        }\n        resolver = ConfigResolver()\n        settings = resolver.resolve(\n            config_dir=config_dir,\n            config_file=config,\n            cli_overrides=cli_overrides,\n        )\n        ctx.ensure_object(dict)\n        ctx.obj[\"settings\"] = settings\n        return ctx.invoke(f, *args, **kwargs)\n    return wrapper\n```\n\nNote: Use `default=None` for boolean to allow ENV override. Use `click.Path(exists=True)` per PRD security constraints.",
        "testStrategy": "Test decorator on minimal Click command. Verify options appear in --help, verify settings object is injected into context, verify CLI values override ENV.",
        "priority": "high",
        "dependencies": [
          "83"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create click_integration.py with imports and decorator skeleton",
            "description": "Create the new click_integration.py file with all required imports and the buvis_options function signature.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/click_integration.py` with:\n- `from __future__ import annotations`\n- `import functools`\n- `import click`\n- `from typing import TYPE_CHECKING` with `if TYPE_CHECKING:` guard for type imports\n- `from .resolver import ConfigResolver`\n- `from .settings import GlobalSettings`\n- Empty `buvis_options(f)` function with Google-format docstring: \"Add standard BUVIS options to a Click command.\"\n- Module should pass ruff check",
            "status": "pending",
            "testStrategy": "Verify imports: `from buvis.pybase.configuration.click_integration import buvis_options` succeeds without ImportError",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Click option decorators to buvis_options",
            "description": "Implement the four Click options: --debug/--no-debug, --log-level, --config-dir, --config with proper types and defaults.",
            "dependencies": [
              1
            ],
            "details": "Stack decorators inside buvis_options:\n- `@click.option(\"--debug/--no-debug\", default=None, help=\"Enable debug mode\")` - default=None allows ENV override\n- `@click.option(\"--log-level\", type=click.Choice([\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"], case_sensitive=False), default=None)`\n- `@click.option(\"--config-dir\", type=click.Path(exists=True, file_okay=False, resolve_path=True), help=\"Config directory\")` - exists=True for security per PRD\n- `@click.option(\"--config\", type=click.Path(exists=True, dir_okay=False, resolve_path=True), help=\"Additional YAML config file\")`",
            "status": "pending",
            "testStrategy": "Create test Click command with decorator, verify all 4 options appear in --help output",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement wrapper function with ConfigResolver integration",
            "description": "Implement the inner wrapper that resolves settings via ConfigResolver and injects GlobalSettings into Click context.",
            "dependencies": [
              2
            ],
            "details": "Implement wrapper inside buvis_options:\n- Add `@click.pass_context` after option decorators\n- Add `@functools.wraps(f)` for metadata preservation\n- Define `wrapper(ctx, debug, log_level, config_dir, config, *args, **kwargs)`\n- Build cli_overrides dict filtering None values: `{k: v for k, v in {\"debug\": debug, \"log_level\": log_level}.items() if v is not None}`\n- Create ConfigResolver instance and call `resolver.resolve(config_dir=config_dir, config_file=config, cli_overrides=cli_overrides)`\n- Use `ctx.ensure_object(dict)` then `ctx.obj[\"settings\"] = settings`\n- Return `ctx.invoke(f, *args, **kwargs)`",
            "status": "pending",
            "testStrategy": "Test decorator injects settings into ctx.obj; verify CLI args override ENV vars by mocking ConfigResolver",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Export buvis_options from configuration __init__.py",
            "description": "Add buvis_options to the configuration module's public API by updating __init__.py exports.",
            "dependencies": [
              3
            ],
            "details": "Edit `src/buvis/pybase/configuration/__init__.py`:\n- Add import: `from .click_integration import buvis_options`\n- Append to `__all__`: `\"buvis_options\"`\n- Keep existing exports (Configuration, ConfigurationKeyNotFoundError, cfg)\n- Maintain alphabetical order in __all__ list",
            "status": "pending",
            "testStrategy": "Verify import path: `from buvis.pybase.configuration import buvis_options` works",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create test_click_integration.py with decorator tests",
            "description": "Create comprehensive test suite verifying decorator functionality, option parsing, and context injection.",
            "dependencies": [
              4
            ],
            "details": "Create `tests/configuration/test_click_integration.py`:\n- Use Click's CliRunner for testing\n- Fixture returning CliRunner instance\n- TestBuvisOptionsHelp: verify --debug, --log-level, --config-dir, --config appear in --help\n- TestBuvisOptionsContextInjection: verify settings object exists in ctx.obj[\"settings\"] after decorator runs\n- TestBuvisOptionsPrecedence: mock ConfigResolver to verify cli_overrides dict passed correctly when CLI args provided\n- TestBuvisOptionsDefaults: verify None values not passed to ConfigResolver (allowing ENV fallthrough)\n- Follow existing test patterns: class-based organization, Google docstrings",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_click_integration.py -v` - all tests pass",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T18:56:10.721Z"
      },
      {
        "id": "85",
        "title": "Implement get_settings helper",
        "description": "Create helper function to retrieve GlobalSettings from Click context with clear error on misuse.",
        "details": "Add to `src/buvis/pybase/configuration/click_integration.py`:\n\n```python\ndef get_settings(ctx: click.Context) -> GlobalSettings:\n    \"\"\"Get settings from Click context.\n    \n    Raises:\n        RuntimeError: If called before buvis_options decorator ran.\n    \"\"\"\n    if ctx.obj is None or \"settings\" not in ctx.obj:\n        msg = \"get_settings() called but buvis_options decorator not applied\"\n        raise RuntimeError(msg)\n    return ctx.obj[\"settings\"]\n```\n\nKeep it simple - just retrieves and validates. No caching needed since ctx.obj already stores the object.",
        "testStrategy": "Test get_settings returns same object set by decorator. Test RuntimeError raised when ctx.obj empty or missing settings key.",
        "priority": "medium",
        "dependencies": [
          "84"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create click_integration.py module with imports",
            "description": "Create the new click_integration.py file with necessary imports for Click and type hints.",
            "dependencies": [],
            "details": "Create `src/buvis/pybase/configuration/click_integration.py` with:\n```python\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import click\n\n    from .settings import GlobalSettings\n```\nUse TYPE_CHECKING guard since click is only needed for type hints. Import GlobalSettings from settings module (task 84 dependency).",
            "status": "pending",
            "testStrategy": "Verify file exists and imports resolve without errors when running ruff check.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement get_settings function signature and docstring",
            "description": "Add the get_settings function with proper type hints and Google-style docstring.",
            "dependencies": [
              1
            ],
            "details": "Add function skeleton:\n```python\ndef get_settings(ctx: click.Context) -> GlobalSettings:\n    \"\"\"Get settings from Click context.\n    \n    Args:\n        ctx: Click context with settings stored by buvis_options decorator.\n    \n    Raises:\n        RuntimeError: If called before buvis_options decorator ran.\n    \n    Returns:\n        The GlobalSettings instance from context.\n    \"\"\"\n```\nFollow project's Google docstring format convention.",
            "status": "pending",
            "testStrategy": "Verify function signature matches expected API from PRD.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement validation and retrieval logic",
            "description": "Add the core logic to validate ctx.obj and retrieve settings with clear error message.",
            "dependencies": [
              2
            ],
            "details": "Complete the function body:\n```python\n    if ctx.obj is None or \"settings\" not in ctx.obj:\n        msg = \"get_settings() called but buvis_options decorator not applied\"\n        raise RuntimeError(msg)\n    return ctx.obj[\"settings\"]\n```\nCheck both ctx.obj being None AND missing 'settings' key. Use clear error message explaining the misuse.",
            "status": "pending",
            "testStrategy": "Unit test: verify RuntimeError raised when ctx.obj is None, when ctx.obj is empty dict, and when 'settings' key missing.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Export get_settings from configuration __init__.py",
            "description": "Add get_settings to the configuration module's public API via __init__.py exports.",
            "dependencies": [
              3
            ],
            "details": "Update `src/buvis/pybase/configuration/__init__.py`:\n1. Add import: `from .click_integration import get_settings`\n2. Add to __all__: append \"get_settings\" to the existing __all__ list.\nFollow existing export pattern in the module.",
            "status": "pending",
            "testStrategy": "Verify `from buvis.pybase.configuration import get_settings` works.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add unit tests for get_settings",
            "description": "Create comprehensive tests covering success case and all error scenarios.",
            "dependencies": [
              4
            ],
            "details": "Create `tests/configuration/test_click_integration.py`:\n```python\nimport pytest\nfrom unittest.mock import MagicMock\nfrom buvis.pybase.configuration import get_settings\n\nclass TestGetSettings:\n    def test_returns_settings_from_context(self):\n        ctx = MagicMock()\n        mock_settings = MagicMock()\n        ctx.obj = {\"settings\": mock_settings}\n        assert get_settings(ctx) is mock_settings\n    \n    def test_raises_when_ctx_obj_none(self):\n        ctx = MagicMock()\n        ctx.obj = None\n        with pytest.raises(RuntimeError, match=\"buvis_options decorator not applied\"):\n            get_settings(ctx)\n    \n    def test_raises_when_settings_key_missing(self):\n        ctx = MagicMock()\n        ctx.obj = {}\n        with pytest.raises(RuntimeError, match=\"buvis_options decorator not applied\"):\n            get_settings(ctx)\n```",
            "status": "pending",
            "testStrategy": "Run pytest on test_click_integration.py, verify all 3 test cases pass.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "86",
        "title": "Update configuration module exports",
        "description": "Export new symbols (buvis_options, get_settings, GlobalSettings, ConfigResolver) from configuration/__init__.py.",
        "details": "Update `src/buvis/pybase/configuration/__init__.py`:\n\n```python\nfrom .configuration import Configuration, cfg\nfrom .exceptions import ConfigurationKeyNotFoundError\nfrom .settings import GlobalSettings\nfrom .resolver import ConfigResolver\nfrom .click_integration import buvis_options, get_settings\n\n__all__ = [\n    \"Configuration\",\n    \"ConfigurationKeyNotFoundError\",\n    \"cfg\",\n    \"GlobalSettings\",\n    \"ConfigResolver\",\n    \"buvis_options\",\n    \"get_settings\",\n]\n```\n\nFollow existing export pattern with explicit `__all__`.",
        "testStrategy": "Verify all symbols importable from `buvis.pybase.configuration`. Check `__all__` matches actual exports.",
        "priority": "medium",
        "dependencies": [
          "85"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify prerequisite modules from task 85 exist",
            "description": "Confirm that settings.py, resolver.py, and click_integration.py exist in configuration/ before updating exports.",
            "dependencies": [],
            "details": "Check that task 85 has created the three required modules:\n- `src/buvis/pybase/configuration/settings.py` - must export `GlobalSettings`\n- `src/buvis/pybase/configuration/resolver.py` - must export `ConfigResolver`\n- `src/buvis/pybase/configuration/click_integration.py` - must export `buvis_options` and `get_settings`\n\nIf any module is missing, this task is blocked until task 85 completes.",
            "status": "pending",
            "testStrategy": "Run: `ls src/buvis/pybase/configuration/*.py` and verify all 6 files exist (3 existing + 3 new)",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Refactor ConfigurationKeyNotFoundError import to use exceptions module",
            "description": "Import ConfigurationKeyNotFoundError directly from exceptions.py instead of through configuration.py.",
            "dependencies": [
              1
            ],
            "details": "Current import is indirect (via configuration.py). Update to import from exceptions module directly:\n\n```python\nfrom .configuration import Configuration, cfg\nfrom .exceptions import ConfigurationKeyNotFoundError\n```\n\nThis follows the pattern of importing from the module where the class is defined, improving clarity.",
            "status": "pending",
            "testStrategy": "Verify `from buvis.pybase.configuration import ConfigurationKeyNotFoundError` still works after change",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add import statements for new symbols from task 85 modules",
            "description": "Import GlobalSettings, ConfigResolver, buvis_options, and get_settings from their respective modules.",
            "dependencies": [
              2
            ],
            "details": "Add these imports to `__init__.py` after existing imports:\n\n```python\nfrom .settings import GlobalSettings\nfrom .resolver import ConfigResolver\nfrom .click_integration import buvis_options, get_settings\n```\n\nGroup by module and keep existing import order style (one module per line).",
            "status": "pending",
            "testStrategy": "Run python -c to verify each symbol imports without error before updating __all__",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update __all__ list with all exported symbols",
            "description": "Add GlobalSettings, ConfigResolver, buvis_options, and get_settings to the __all__ list.",
            "dependencies": [
              3
            ],
            "details": "Update `__all__` to include all 7 symbols:\n\n```python\n__all__ = [\n    \"Configuration\",\n    \"ConfigurationKeyNotFoundError\",\n    \"ConfigResolver\",\n    \"GlobalSettings\",\n    \"buvis_options\",\n    \"cfg\",\n    \"get_settings\",\n]\n```\n\nSort alphabetically (capital letters first per Python convention) to match codebase style.",
            "status": "pending",
            "testStrategy": "Run: `python -c \"from buvis.pybase.configuration import *; print(dir())\"` and verify all symbols present",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run linter and verify all exports are importable",
            "description": "Run ruff check and test that all symbols are importable from buvis.pybase.configuration.",
            "dependencies": [
              4
            ],
            "details": "Final verification steps:\n1. Run `ruff check src/buvis/pybase/configuration/__init__.py` - fix any linting errors\n2. Run `python -c \"from buvis.pybase.configuration import Configuration, ConfigurationKeyNotFoundError, cfg, GlobalSettings, ConfigResolver, buvis_options, get_settings\"`\n3. Verify `__all__` matches actual exports with: `python -c \"from buvis.pybase import configuration; print(configuration.__all__)\"`",
            "status": "pending",
            "testStrategy": "All 3 verification commands pass without errors. Add test in tests/configuration/test_exports.py if not covered.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "87",
        "title": "Write unit tests for GlobalSettings",
        "description": "Test GlobalSettings dataclass instantiation, defaults, and _extra attribute access.",
        "details": "Create `tests/configuration/test_settings.py`:\n\n```python\nimport pytest\nfrom buvis.pybase.configuration import GlobalSettings\n\nclass TestGlobalSettings:\n    def test_defaults(self):\n        s = GlobalSettings()\n        assert s.debug is False\n        assert s.log_level == \"INFO\"\n        assert s.config_dir is None\n\n    def test_explicit_values(self):\n        s = GlobalSettings(debug=True, log_level=\"DEBUG\")\n        assert s.debug is True\n        assert s.log_level == \"DEBUG\"\n\n    def test_extra_attribute_access(self):\n        s = GlobalSettings(_extra={\"payroll\": {\"batch_size\": 100}})\n        assert s.payroll == {\"batch_size\": 100}\n\n    def test_missing_extra_returns_none(self):\n        s = GlobalSettings()\n        assert s.nonexistent is None\n```\n\nFollow existing test pattern with class organization and pytest fixtures.",
        "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py -v`",
        "priority": "medium",
        "dependencies": [
          "82"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test file structure for GlobalSettings tests",
            "description": "Create the tests/configuration/ directory and test_settings.py file with imports and fixture setup",
            "dependencies": [],
            "details": "Create `tests/configuration/__init__.py` (empty) and `tests/configuration/test_settings.py`. Add imports: `import pytest` and `from buvis.pybase.configuration import GlobalSettings`. Add a fixture `@pytest.fixture def global_settings() -> GlobalSettings: return GlobalSettings()` following the pattern from test_shell_adapter.py",
            "status": "pending",
            "testStrategy": "Verify file exists and imports work: `python -c 'from tests.configuration.test_settings import *'`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Write test for GlobalSettings default values",
            "description": "Add TestGlobalSettingsDefaults class with test_defaults method verifying debug=False, log_level='INFO', config_dir=None",
            "dependencies": [
              1
            ],
            "details": "Create `class TestGlobalSettingsDefaults:` with `def test_defaults(self) -> None:` that instantiates GlobalSettings() and asserts `s.debug is False`, `s.log_level == 'INFO'`, `s.config_dir is None`. Use `is` for boolean comparison per Python conventions.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py::TestGlobalSettingsDefaults -v`",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Write test for GlobalSettings explicit value initialization",
            "description": "Add test_explicit_values method to verify non-default values are properly set during initialization",
            "dependencies": [
              1
            ],
            "details": "Add `def test_explicit_values(self) -> None:` that creates `GlobalSettings(debug=True, log_level='DEBUG', config_dir='/custom')` and asserts each field matches. Test both modified and unmodified fields to ensure no cross-contamination.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py -k explicit -v`",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Write test for _extra attribute dynamic access",
            "description": "Add TestGlobalSettingsExtra class testing __getattr__ behavior for accessing tool-specific settings via _extra dict",
            "dependencies": [
              1
            ],
            "details": "Create `class TestGlobalSettingsExtra:` with `def test_extra_attribute_access(self) -> None:`. Instantiate `GlobalSettings(_extra={'payroll': {'batch_size': 100}, 'jira': {'url': 'https://jira.example.com'}})`. Assert `s.payroll == {'batch_size': 100}` and `s.jira == {'url': '...'}`.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py::TestGlobalSettingsExtra -v`",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Write test for missing _extra attribute returns None",
            "description": "Add test verifying that accessing undefined attributes returns None instead of raising AttributeError",
            "dependencies": [
              4
            ],
            "details": "Add `def test_missing_extra_returns_none(self) -> None:` to TestGlobalSettingsExtra. Create `GlobalSettings()` with no _extra and assert `s.nonexistent is None`, `s.payroll is None`. Also test with partial _extra: `GlobalSettings(_extra={'a': 1})` and verify `s.b is None`.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_settings.py -k missing -v`",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "88",
        "title": "Write unit tests for ConfigResolver",
        "description": "Test resolver precedence (CLI > ENV > file) and edge cases.",
        "details": "Create `tests/configuration/test_resolver.py`:\n\n```python\nimport os\nimport pytest\nfrom unittest.mock import patch, Mock\nfrom buvis.pybase.configuration import ConfigResolver\n\nclass TestConfigResolver:\n    @pytest.fixture\n    def resolver(self):\n        return ConfigResolver()\n\n    def test_defaults_when_no_sources(self, resolver):\n        settings = resolver.resolve()\n        assert settings.debug is False\n        assert settings.log_level == \"INFO\"\n\n    def test_env_override(self, resolver, monkeypatch):\n        monkeypatch.setenv(\"BUVIS_DEBUG\", \"true\")\n        settings = resolver.resolve()\n        assert settings.debug is True\n\n    def test_cli_wins_over_env(self, resolver, monkeypatch):\n        monkeypatch.setenv(\"BUVIS_DEBUG\", \"true\")\n        settings = resolver.resolve(cli_overrides={\"debug\": False})\n        assert settings.debug is False  # CLI wins\n\n    def test_log_level_case_insensitive(self, resolver, monkeypatch):\n        monkeypatch.setenv(\"BUVIS_LOG_LEVEL\", \"debug\")\n        settings = resolver.resolve()\n        assert settings.log_level == \"DEBUG\"  # Uppercased\n```\n\nTest each PRD test case: 1-6 from the spec.",
        "testStrategy": "Run `uv run pytest tests/configuration/test_resolver.py -v`. Verify all 6 PRD test cases pass.",
        "priority": "medium",
        "dependencies": [
          "83"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test file structure and fixtures",
            "description": "Set up tests/configuration/test_resolver.py with pytest fixtures for ConfigResolver and temp config directories.",
            "dependencies": [],
            "details": "Create tests/configuration/__init__.py and test_resolver.py. Add fixtures: `resolver` (returns ConfigResolver()), `tmp_config_dir` (creates temp dir with optional buvis.yaml), `clean_env` (clears BUVIS_* env vars). Follow existing test_shell_adapter.py patterns for structure.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/ --collect-only` to verify test collection works.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Test default values when no sources exist",
            "description": "Test ConfigResolver returns correct defaults when no YAML, ENV, or CLI sources are provided.",
            "dependencies": [
              1
            ],
            "details": "Create TestConfigResolverDefaults class. Test: resolver.resolve() returns GlobalSettings with debug=False, log_level='INFO', output_format='text'. Uses clean_env fixture to ensure no BUVIS_* vars pollute test. PRD test case 1.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_resolver.py::TestConfigResolverDefaults -v`",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Test precedence chain (CLI > ENV > YAML)",
            "description": "Test full precedence: CLI wins over ENV wins over YAML wins over defaults.",
            "dependencies": [
              1
            ],
            "details": "Create TestConfigResolverPrecedence class with tests: (1) CLI overrides all sources, (2) ENV overrides YAML when no CLI, (3) YAML overrides defaults when no CLI/ENV, (4) All sources set -> CLI wins. Use monkeypatch.setenv for ENV, tmp_config_dir for YAML, cli_overrides dict for CLI. PRD-00007 tests 1-4.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_resolver.py::TestConfigResolverPrecedence -v`",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Test edge cases and value handling",
            "description": "Test edge cases: CLI=None fallthrough, case-insensitive log_level, empty ENV strings, tool-specific config.",
            "dependencies": [
              1
            ],
            "details": "Create TestConfigResolverEdgeCases class. Tests: (1) cli_overrides={'debug': None} falls through to ENV, (2) BUVIS_LOG_LEVEL='debug' uppercased to 'DEBUG', (3) Empty string ENV used (not default), (4) tool_name='payroll' merges tool config. PRD-00007 test 5, PRD-00008 test 5.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_resolver.py::TestConfigResolverEdgeCases -v`",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test error handling and validation",
            "description": "Test error cases: invalid YAML syntax, missing required fields, type validation failures.",
            "dependencies": [
              1
            ],
            "details": "Create TestConfigResolverErrors class. Tests: (1) Invalid YAML raises ConfigurationError with file path, (2) Invalid log_level value raises ValidationError, (3) Type mismatch (debug='notbool') raises ValidationError. Use pytest.raises context manager. PRD-00008 tests 6-7.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_resolver.py::TestConfigResolverErrors -v`",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "89",
        "title": "Write unit tests for buvis_options decorator",
        "description": "Test decorator adds correct options, injects settings, and handles option combinations.",
        "details": "Create `tests/configuration/test_click_integration.py`:\n\n```python\nimport click\nimport pytest\nfrom click.testing import CliRunner\nfrom buvis.pybase.configuration import buvis_options, get_settings\n\nclass TestBuvisOptions:\n    @pytest.fixture\n    def runner(self):\n        return CliRunner()\n\n    def test_debug_flag_sets_settings(self, runner):\n        @click.command()\n        @buvis_options\n        @click.pass_context\n        def cmd(ctx):\n            s = get_settings(ctx)\n            click.echo(f\"debug={s.debug}\")\n\n        result = runner.invoke(cmd, [\"--debug\"])\n        assert \"debug=True\" in result.output\n        assert result.exit_code == 0\n\n    def test_no_debug_overrides_env(self, runner, monkeypatch):\n        monkeypatch.setenv(\"BUVIS_DEBUG\", \"true\")\n        \n        @click.command()\n        @buvis_options\n        @click.pass_context\n        def cmd(ctx):\n            s = get_settings(ctx)\n            click.echo(f\"debug={s.debug}\")\n\n        result = runner.invoke(cmd, [\"--no-debug\"])\n        assert \"debug=False\" in result.output\n\n    def test_log_level_option(self, runner):\n        @click.command()\n        @buvis_options\n        @click.pass_context\n        def cmd(ctx):\n            s = get_settings(ctx)\n            click.echo(f\"level={s.log_level}\")\n\n        result = runner.invoke(cmd, [\"--log-level\", \"DEBUG\"])\n        assert \"level=DEBUG\" in result.output\n```\n\nUse Click's CliRunner for testing CLI behavior.",
        "testStrategy": "Run `uv run pytest tests/configuration/test_click_integration.py -v`. Verify all PRD test cases covered.",
        "priority": "medium",
        "dependencies": [
          "84",
          "85"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create test file structure with CliRunner fixture",
            "description": "Set up tests/configuration/test_click_integration.py with imports, CliRunner fixture, and TestBuvisOptions class skeleton.",
            "dependencies": [],
            "details": "Create tests/configuration/ directory and test_click_integration.py. Add imports: click, pytest, CliRunner, buvis_options, get_settings. Create CliRunner fixture that returns CliRunner() instance. Add empty TestBuvisOptions class as container for all decorator tests.",
            "status": "pending",
            "testStrategy": "File exists and imports resolve without errors when running pytest --collect-only",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Test --debug flag sets settings.debug=True",
            "description": "Verify --debug CLI flag properly injects settings with debug=True into Click context.",
            "dependencies": [
              1
            ],
            "details": "Add test_debug_flag_sets_settings method. Create minimal Click command decorated with @buvis_options and @click.pass_context. Use get_settings(ctx) to retrieve settings, echo debug value. Invoke with ['--debug'], assert 'debug=True' in output and exit_code==0.",
            "status": "pending",
            "testStrategy": "Test passes when decorator correctly processes --debug and injects settings into context",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Test --no-debug overrides BUVIS_DEBUG env var",
            "description": "Verify CLI --no-debug flag takes precedence over BUVIS_DEBUG=true environment variable.",
            "dependencies": [
              1
            ],
            "details": "Add test_no_debug_overrides_env method. Use monkeypatch.setenv('BUVIS_DEBUG', 'true') to set env. Create command with @buvis_options, invoke with ['--no-debug']. Assert 'debug=False' in output, proving CLI flag overrides env var per resolver priority.",
            "status": "pending",
            "testStrategy": "Test passes when CLI value correctly overrides environment variable value",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Test --log-level option accepts valid values",
            "description": "Verify --log-level option correctly sets settings.log_level to DEBUG, INFO, WARNING, ERROR.",
            "dependencies": [
              1
            ],
            "details": "Add test_log_level_option method. Create command that echoes s.log_level. Test with ['--log-level', 'DEBUG'], assert 'level=DEBUG' in output. Consider parametrizing with @pytest.mark.parametrize for all valid levels (DEBUG, INFO, WARNING, ERROR).",
            "status": "pending",
            "testStrategy": "Test passes for each valid log level value; invalid values should fail Click validation",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test decorator options appear in --help",
            "description": "Verify all buvis_options (--debug, --log-level, --config-dir, --config) appear in command help text.",
            "dependencies": [
              1
            ],
            "details": "Add test_options_appear_in_help method. Create minimal @buvis_options decorated command. Invoke with ['--help'], assert exit_code==0. Check output contains '--debug', '--log-level', '--config-dir', '--config' strings. Validates decorator properly attaches all expected Click options.",
            "status": "pending",
            "testStrategy": "Test passes when all four option names appear in --help output",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "90",
        "title": "Write integration test for full CLI flow",
        "description": "End-to-end test with Click group, subcommands, and settings inheritance through context.",
        "details": "Add to `tests/configuration/test_click_integration.py`:\n\n```python\nclass TestClickIntegration:\n    def test_settings_inherited_in_subcommand(self, runner):\n        @click.group()\n        @buvis_options\n        @click.pass_context\n        def cli(ctx):\n            pass\n\n        @cli.command()\n        @click.pass_context\n        def process(ctx):\n            s = get_settings(ctx)\n            click.echo(f\"debug={s.debug}\")\n\n        result = runner.invoke(cli, [\"--debug\", \"process\"])\n        assert \"debug=True\" in result.output\n        assert result.exit_code == 0\n\n    def test_get_settings_returns_same_object(self, runner):\n        results = []\n\n        @click.group()\n        @buvis_options\n        @click.pass_context\n        def cli(ctx):\n            results.append(id(get_settings(ctx)))\n\n        @cli.command()\n        @click.pass_context\n        def cmd(ctx):\n            results.append(id(get_settings(ctx)))\n\n        runner.invoke(cli, [\"cmd\"])\n        assert results[0] == results[1]  # Same object\n```\n\nVerify PRD test #6: get_settings returns same object across commands.",
        "testStrategy": "Run full test suite `uv run pytest tests/configuration/ -v`. Verify all tests pass and coverage adequate.",
        "priority": "low",
        "dependencies": [
          "89"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add TestClickIntegration class skeleton to test_click_integration.py",
            "description": "Create TestClickIntegration class in the existing test file for group/subcommand integration tests.",
            "dependencies": [],
            "details": "Add new test class after TestBuvisOptions in tests/configuration/test_click_integration.py:\n\n```python\nclass TestClickIntegration:\n    \"\"\"Integration tests for Click group/subcommand settings inheritance.\"\"\"\n```\n\nThis class will contain the end-to-end tests for settings passing through Click groups and subcommands.",
            "status": "pending",
            "testStrategy": "Verify class exists and pytest collects it with `uv run pytest --collect-only tests/configuration/test_click_integration.py::TestClickIntegration`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement test_settings_inherited_in_subcommand test method",
            "description": "Test that settings from parent @buvis_options decorator are accessible in subcommands via get_settings.",
            "dependencies": [
              1
            ],
            "details": "Add test method using runner fixture:\n\n```python\ndef test_settings_inherited_in_subcommand(self, runner):\n    @click.group()\n    @buvis_options\n    @click.pass_context\n    def cli(ctx):\n        pass\n\n    @cli.command()\n    @click.pass_context\n    def process(ctx):\n        s = get_settings(ctx)\n        click.echo(f\"debug={s.debug}\")\n\n    result = runner.invoke(cli, [\"--debug\", \"process\"])\n    assert \"debug=True\" in result.output\n    assert result.exit_code == 0\n```\n\nVerifies parent group settings flow through Click context to child subcommands.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_click_integration.py::TestClickIntegration::test_settings_inherited_in_subcommand -v`",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement test_get_settings_returns_same_object test method",
            "description": "Verify get_settings returns identical object in group and subcommand (PRD test #6).",
            "dependencies": [
              1
            ],
            "details": "Add test that captures object IDs:\n\n```python\ndef test_get_settings_returns_same_object(self, runner):\n    results = []\n\n    @click.group()\n    @buvis_options\n    @click.pass_context\n    def cli(ctx):\n        results.append(id(get_settings(ctx)))\n\n    @cli.command()\n    @click.pass_context\n    def cmd(ctx):\n        results.append(id(get_settings(ctx)))\n\n    runner.invoke(cli, [\"cmd\"])\n    assert results[0] == results[1]  # Same object\n```\n\nThis validates PRD test #6: same settings instance is reused, not recreated.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_click_integration.py::TestClickIntegration::test_get_settings_returns_same_object -v`",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add test for nested subcommand groups inheriting settings",
            "description": "Test settings inheritance through multiple levels of Click group nesting.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add test for deeper nesting:\n\n```python\ndef test_settings_inherited_in_nested_groups(self, runner):\n    @click.group()\n    @buvis_options\n    @click.pass_context\n    def cli(ctx):\n        pass\n\n    @cli.group()\n    @click.pass_context\n    def subgroup(ctx):\n        pass\n\n    @subgroup.command()\n    @click.pass_context\n    def deep_cmd(ctx):\n        s = get_settings(ctx)\n        click.echo(f\"log_level={s.log_level}\")\n\n    result = runner.invoke(cli, [\"--log-level\", \"DEBUG\", \"subgroup\", \"deep_cmd\"])\n    assert \"log_level=DEBUG\" in result.output\n    assert result.exit_code == 0\n```\n\nTests that Click context propagates settings through nested groups.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/test_click_integration.py::TestClickIntegration::test_settings_inherited_in_nested_groups -v`",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run full configuration test suite and verify coverage",
            "description": "Execute complete test suite to verify all integration tests pass alongside unit tests.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Run full test suite:\n```bash\nuv run pytest tests/configuration/ -v\n```\n\nVerify:\n1. All TestBuvisOptions tests from task 89 still pass\n2. All TestClickIntegration tests pass\n3. No test isolation issues between classes\n4. Exit code 0\n\nIf failures, debug and fix any context isolation or fixture issues between test classes.",
            "status": "pending",
            "testStrategy": "Run `uv run pytest tests/configuration/ -v --tb=short` and verify 100% pass rate with no warnings about fixture scope.",
            "parentId": "undefined"
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-02T19:24:08.547Z",
      "taskCount": 90,
      "completedCount": 59,
      "tags": [
        "master"
      ]
    }
  }
}